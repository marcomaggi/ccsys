\input texinfo.tex
@c %**start of header
@setfilename ccsys.info
@settitle CCSys
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSys

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSys

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsys

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a standard C11 language library;
it implements adapters for @posix{} system functions to convert the error reporting mechanism to the
use of the library CCExceptions.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsys: (ccsys).               System functions wrappers for CCExceptions.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* defines::                     General preprocessor symbols.
* semantic::                    Semantic types.
* enums::                       Enumerated constants.
* memory::                      Memory allocation, locking, mapping.
* users::                       Users and groups system calls.
* io::                          Input/output system calls.
* fs::                          File system system calls.
* sockets::                     Socket system calls.
* process::                     Process system calls.
* time::                        Time handling.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements adapters for @posix{} functions to convert the error reporting mechanism to the use of
the library CCExceptions.  The library supports some @gnu{} C Library functions and some Linux
functions.

@value{PACKAGE} installs a single header file @file{ccsys.h}.  All the function names in the @api{}
are prefixed with @code{ccsys_}; all the preprocessor symbol names are prefixed with @code{CCSYS_};
all the type names are prefixed with @code{ccsys_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
* overview api::                Programming interface.
* overview constants::          How system constants are handled.
* overview arguments::          How system call arguments and return
                                values are handled.
* overview structures::         How system structures are handled.
@end menu

@c page
@node overview linking
@section Linking code with the library


@subsubheading Using the @gnu{} Autotools

This package installs a data file for @command{pkg-config}; when searching for the installed library
with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSYS],[ccsys >= 0.1])
@end example

@noindent
which will set the variables @code{CCSYS_LIBS} and @code{CCSYS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccsys],[ccsys_version_string],,
  [AC_MSG_FAILURE([test for CCSys library failed])])
AC_CHECK_HEADERS([ccsys.h],,
  [AC_MSG_FAILURE([test for CCSys header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language.

@c ------------------------------------------------------------------------

@subsubheading One--shot compilation, Unix command line

For the one--shot compilation of a file named @file{demo.c}, we can do:

@example
gcc -std=c11 -Wall \
   `pkg-config ccsys --cflags` \
   `pkg-config ccsys --libs` \
   -o demo demo.c
@end example

@c page
@node overview api
@section Programming interface


@value{PACKAGE} defines function wrappers for the most common @posix{}, @gnu{} C Library and Linux
system calls.  Each wrapper accepts a pointer to @objtype{cce_location_t} as argument and, in case
of error, it will perform a non--local exit by jumping to the selected location.

Each wrapper function accepts the same arguments of the system call and returns the same return
value of the system call (if it completes successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

The library assumes to run on a @posix{} system, so the @posix{} system calls are available by
default.  The @gnu{} C Library and Linux calls are available only if the package was configured
with, respectively, @option{--enable-glibc} and @option{--enable-linux}.  If a system call is not
available: the associated wrapper will raise an exception of type
@objtype{cce_condition_unimplemented_t}.

@c page
@node overview constants
@section How system constants are handled


On a @posix{} platform, the system header files define a number of preprocessor symbols that expand
into constants; such constants are used to configure the behaviour of specific system function
calls.  @value{PACKAGE} is written in such a way that no system header file is included in the
package's header @file{ccsys.h}, so every constant definition is duplicated in the package's header.

All the constants are redefined as enumerated values, with the same system name prefixed with
@code{CCSYS_}.  For example, the file mode constants @code{O_RDONLY}, @code{O_WRONLY}, @code{O_RDWR}
are redefined with the following enumeration:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_WRONLY=1,
  CCSYS_O_RDWR=2,
  ...
@};

typedef enum ccsys_open_flags_enum_t ccsys_open_flags_enum_t;
@end example

@noindent
in which the constant values @samp{0}, @samp{1}, @samp{2} are the result of system inspection at
package configuration time.

If a symbol is not defined by the underlying platform, @value{PACKAGE} omits its redefinition.  For
example, in the unlikely case that the underlying platform does not define @code{O_WRONLY}, the
above redefinition would be:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_RDWR=2,
  ...
@};
@end example

@noindent
with @code{CCSYS_O_WRONLY} missing.

@c page
@node overview arguments
@section How system call arguments and return values are handled


@value{PACKAGE} attempts to implement strong typing for system call arguments with a specific
meaning.  For example, arguments like @var{flags} and @var{mode} in @cfunc{open} are both defined as
@code{int} by @posix{} but @value{PACKAGE} considers them as having semantic value, so they have
their type definition; the original system call has the prototype:

@example
int open(const char *pathname, int flags, mode_t mode);
@end example

@noindent
while the @value{PACKAGE} wrapper has the prototype:

@example
ccsys_fd_t ccsys_open (cce_location_t * L, char const * filename,
   ccsys_open_flags_t flags, ccsys_open_mode_t mode);
@end example

@noindent
both arguments and return values have a @dfn{semantic type}.

The argument and return value semantic types defined by @value{PACKAGE}, are @code{struct} type
definitions with a single field named @samp{data}; for example, here are possible definitions for
@cfunc{ccsys_open}:

@example
typedef struct ccsys_fd_t               ccsys_fd_t;
typedef struct ccsys_open_flags_t       ccsys_open_flags_t;
typedef struct ccsys_open_mode_t        ccsys_open_mode_t;

struct ccsys_fd_t               @{ int data; @};
struct ccsys_open_flags_t       @{ int data; @};
struct ccsys_open_mode_t        @{ int32_t data; @};
@end example

@noindent
when appropriate, the type of the field @samp{data} is determined at package configuration time.

@c page
@node overview structures
@section How system structures are handled


On a @posix{} platform, the system header files define a number of data structures used to exchange
values with the system itself.  @value{PACKAGE} is written in such a way that no system header file
is included in the package's header @file{ccsys.h}, so every data structure definition is duplicated
in the package's header.

Every duplicated data structure is defined as an opaque type in @file{ccsys.h}.  For example, here
is a possible redefinition for @code{struct stat}:

@example
typedef struct ccsys_stat_t     ccsys_stat_t;

struct ccsys_stat_t @{ uint8_t data[144]; @};
@end example

@noindent
for each public field in the structure, there may be a getter and a setter functions, for example
for the @code{st_dev} field:

@example
ccsys_dev_t ccsys_ref_stat_st_dev (ccsys_stat_t const * S)
void ccsys_set_stat_st_dev (ccsys_stat_t const * S, ccsys_dev_t F)
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsys_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccsys_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsys_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccsys_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node defines
@chapter General preprocessor symbols


The following symbols are defined in the header file @file{ccsys.h}.


@defmac CCSYS_ON_LINUX
Always defined.  Expands to @code{1} if the underlying platform is Linux; otherwise it expands to
@code{0}.
@end defmac


@defmac CCSYS_ON_BSD
Always defined.  Expands to @code{1} if the underlying platform is BSD; otherwise it expands to
@code{0}.
@end defmac


@defmac CCSYS_ON_CYGWIN
Always defined.  Expands to @code{1} if the underlying platform is Cygwin; otherwise it expands to
@code{0}.
@end defmac


@defmac CCSYS_ON_DARWIN
Always defined.  Expands to @code{1} if the underlying platform is Darwin; otherwise it expands to
@code{0}.
@end defmac

@c page
@node semantic
@chapter Semantic types


Semantic types are data structure type definitions; the @code{struct} has a single field named
@code{data}.  They are used by @value{PACKAGE} to enforce strong typing on function arguments and
return values.

@menu
* semantic typedefs::           Semantic type definitions.
* semantic macros::             Semantic type macros.
@end menu

@c page
@node semantic typedefs
@section Semantic type definitions


@anchor{ccsys_fd_t}
@deftp {Semantic Type} ccsys_fd_t
Type of file descriptors.  It is a singed integer.
@end deftp


@anchor{ccsys_dirfd_t}
@deftp {Semantic Type} ccsys_dirfd_t
Type of file descriptors for directories.  It is a singed integer.
@end deftp


@anchor{ccsys_file_t}
@deftp {Semantic Type} ccsys_file_t
Type of @code{FILE} streams.  It is a pointer.
@end deftp


@anchor{ccsys_off_t}
@deftp {Semantic Type} ccsys_off_t
Type of offsets.  It is a signed integer.
@end deftp


@anchor{ccsys_fd_flags_t}
@deftp {Semantic Type} ccsys_fd_flags_t
Type of arguments for some file descriptor functions.  It is a signed integer.  It is meant to be a
bitwise combination of the enumerated constants of type @objtype{ccsys_fd_flags_enum_t};
@ref{ccsys_fd_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_whence_t}
@deftp {Semantic Type} ccsys_whence_t
Type of @var{whence} arguments for file seek functions.  It is a signed integer.  It is meant to be
one of the enumerated constants of type @objtype{ccsys_whence_enum_t}; @ref{ccsys_whence_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_scatter_gather_flags_t}
@deftp {Semantic Type} ccsys_scatter_gather_flags_t
Type of @var{flags} arguments for some scatter/gather file input/output functions.  It is a signed
integer.  It is meant to be a bitwise combination of the enumerated constants of type
@objtype{ccsys_scatter_gather_flags_enum_t}; @ref{ccsys_scatter_gather_flags_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_open_flags_t}
@deftp {Semantic Type} ccsys_open_flags_t
Exact signed integer representing file open flags.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_flags_enum_t}; @ref{ccsys_open_flags_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_open_mode_t}
@deftp {Semantic Type} ccsys_open_mode_t
Exact signed integer representing file open modes.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_mode_enum_t}; @ref{ccsys_open_mode_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_stat_mode_t}
@deftp {Semantic Type} ccsys_stat_mode_t
Exact signed integer representing file modes used in @objtype{ccsys_stat_t}.  It is meant to be a
bitwise combination of the enumerated constants of type @objtype{ccsys_stat_mode_enum_t} and the
enumerated constants of type @objtype{ccsys_open_mode_enum_t}.  @ref{ccsys_stat_mode_enum_t,
Enumerated constants}.  @ref{ccsys_open_mode_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_unlinkat_flags_t}
@deftp {Semantic Type} ccsys_unlinkat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_unlinkat}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_unlinkat_flags_enum_t}.
@ref{ccsys_unlinkat_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_fstatat_flags_t}
@deftp {Semantic Type} ccsys_fstatat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_fstatat}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_at_flags_enum_t}.
@ref{ccsys_at_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_linkat_flags_t}
@deftp {Semantic Type} ccsys_linkat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_linkat}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_at_flags_enum_t}.
@ref{ccsys_at_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_renameat2_flags_t}
@deftp {Semantic Type} ccsys_renameat2_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_renameat2}.  It is meant to be a
bitwise combination of the enumerated constants of type @objtype{ccsys_renameat2_flags_enum_t}.
@ref{ccsys_renameat2_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_access_mode_t}
@deftp {Semantic Type} ccsys_access_mode_t
Exact signed integer representing the mode for @cfunc{ccsys_access}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_access_mode_enum_t}.
@ref{ccsys_access_mode_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_faccessat_flags_t}
@deftp {Semantic Type} ccsys_faccessat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_faccessat}.  It is meant to be a
bitwise combination of some of the enumerated constants of type @objtype{ccsys_at_flags_enum_t}.
@ref{ccsys_at_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_namespace_t}
@deftp {Semantic Type} ccsys_socket_namespace_t
Exact signed integer representing a socket namespace (or domain).  It is the of the argument
@var{namespace} or @var{domain} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_namespace_enum_t}; @ref{ccsys_socket_namespace_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_fchownat_flags_t}
@deftp {Semantic Type} ccsys_fchownat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_fchownat}.  It is meant to be a bitwise
combination of some of the enumerated constants of type @objtype{ccsys_at_flags_enum_t}.
@ref{ccsys_at_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_fchmodat_flags_t}
@deftp {Semantic Type} ccsys_fchmodat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_fchmodat}.  It is meant to be a bitwise
combination of some of the enumerated constants of type @objtype{ccsys_at_flags_enum_t}.
@ref{ccsys_at_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_style_t}
@deftp {Semantic Type} ccsys_socket_style_t
Exact signed integer representing a socket style (or type).  It is the of the argument @var{style}
or @var{type} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_style_enum_t}; @ref{ccsys_socket_style_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_protocol_t}
@deftp {Semantic Type} ccsys_socket_protocol_t
Exact signed integer representing a socket protocol.  It is the of the argument @var{protocol} of
@cfunc{ccsys_socket}: one of the constants of type @objtype{ccsys_socket_protocol_enum_t};
@ref{ccsys_socket_protocol_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mlockall_flags_t}
@deftp {Semantic Type} ccsys_mlockall_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mlockall}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_locking_enum_t}; @ref{ccsys_memory_locking_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_prot_t}
@deftp {Semantic Type} ccsys_mmap_prot_t
Type of the argument @var{prot} in @cfunc{ccsys_mmap} and in @cfunc{ccsys_mprotect}.  It is meant to
be a bitwise combination of the constants of type @objtype{ccsys_memory_protection_enum_t};
@ref{ccsys_memory_protection_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_flags_t}
@deftp {Semantic Type} ccsys_mmap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mmap}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_mapping_enum_t}; @ref{ccsys_memory_mapping_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_msync_flags_t}
@deftp {Semantic Type} ccsys_msync_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_msync}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_sync_enum_t}; @ref{ccsys_memory_sync_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_mremap_flags_t}
@deftp {Semantic Type} ccsys_mremap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mremap}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_remap_enum_t}; @ref{ccsys_memory_remap_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_madvise_advice_t}
@deftp {Semantic Type} ccsys_madvise_advice_t
Type of the argument @var{advice} in @cfunc{ccsys_advise}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_advice_enum_t}; @ref{ccsys_memory_advice_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_exit_status_t}
@deftp {Semantic Type} ccsys_exit_status_t
Type of the argument @var{status} in @cfunc{ccsys_exit}.  It is meant to be one of the constants of
type @objtype{ccsys_exit_status_enum_t}; @ref{ccsys_exit_status_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_waitpid_status_t}
@deftp {Semantic Type} ccsys_waitpid_status_t
Type of the argument @var{wstatus} in @cfunc{ccsys_waitpid}.
@end deftp


@anchor{ccsys_waitpid_options_t}
@deftp {Semantic Type} ccsys_waitpid_options_t
Type of the argument @var{options} in @cfunc{ccsys_waitpid}.  It is meant to be a bitwise
combination of the constants of type @objtype{ccsys_waitpid_options_enum_t};
@ref{ccsys_waitpid_options_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_sygnum_t}
@deftp {Semantic Type} ccsys_signum_t
Type of exact integers representing interprocess signal numbers.  It is meant to be one of the
constants of type @objtype{ccsys_signum_enum_t}; @ref{ccsys_signum_enum_t, Enumerated constants}.
@end deftp

@c page
@node semantic macros
@section Semantic type macros


@deftypefn {Preprocessor Macro} {int} ccsys_dref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{int}.  Expand into:

@example
((int)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {unsigned int} ccsys_udref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{unsigned int}.
Expand into:

@example
((unsigned int)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {long} ccsys_dref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{long}.  Expand into:

@example
((long)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {unsigned long} ccsys_udref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{unsigned long}.
Expand into:

@example
((unsigned long) ((@var{D}).data))
@end example
@end deftypefn

@c page
@node enums
@chapter Enumerated constants


The following symbols are defined in the header file @file{ccsys.h}.


@EnumeratedConstant{CCSYS_PATH_MAX}
@anchor{ccsys_limits_enum_t}
@deftp {Enum Typedef} ccsys_limits_enum_t
Platform limits constants.  It defines the following constants:

@example
CCSYS_PATH_MAX
@end example
@end deftp


@EnumeratedConstant{CCSYS_EXIT_SUCCESS}
@EnumeratedConstant{CCSYS_EXIT_FAILURE}
@anchor{ccsys_exit_status_enum_t}
@deftp {Enum Typedef} ccsys_exit_status_enum_t
Exit statuses for @cfunc{ccsys_exit}.  It defines the following constants:

@example
CCSYS_EXIT_SUCCESS
CCSYS_EXIT_FAILURE
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_exit_status_t};
@ref{ccsys_exit_status_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_O_RDONLY}
@EnumeratedConstant{CCSYS_O_WRONLY}
@EnumeratedConstant{CCSYS_O_RDWR}
@EnumeratedConstant{CCSYS_O_APPEND}
@EnumeratedConstant{CCSYS_O_ASYNC}
@EnumeratedConstant{CCSYS_O_CLOEXEC}
@EnumeratedConstant{CCSYS_O_CREAT}
@EnumeratedConstant{CCSYS_O_DIRECT}
@EnumeratedConstant{CCSYS_O_DIRECTORY}
@EnumeratedConstant{CCSYS_O_DSYNC}
@EnumeratedConstant{CCSYS_O_EXCL}
@EnumeratedConstant{CCSYS_O_LARGEFILE}
@EnumeratedConstant{CCSYS_O_NDELAY}
@EnumeratedConstant{CCSYS_O_NOATIME}
@EnumeratedConstant{CCSYS_O_NOCTTY}
@EnumeratedConstant{CCSYS_O_NOFOLLOW}
@EnumeratedConstant{CCSYS_O_NONBLOCK}
@EnumeratedConstant{CCSYS_O_PATH}
@EnumeratedConstant{CCSYS_O_SYNC}
@EnumeratedConstant{CCSYS_O_TMPFILE}
@EnumeratedConstant{CCSYS_O_TRUNC}
@anchor{ccsys_open_flags_enum_t}
@deftp {Enum Typedef} ccsys_open_flags_enum_t
Type of file open flag constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{flags} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_O_RDONLY    CCSYS_O_WRONLY    CCSYS_O_RDWR

CCSYS_O_APPEND    CCSYS_O_ASYNC     CCSYS_O_CLOEXEC
CCSYS_O_CREAT     CCSYS_O_DIRECT    CCSYS_O_DIRECTORY
CCSYS_O_DSYNC     CCSYS_O_EXCL      CCSYS_O_LARGEFILE
CCSYS_O_NDELAY    CCSYS_O_NOATIME   CCSYS_O_NOCTTY
CCSYS_O_NOFOLLOW  CCSYS_O_NONBLOCK  CCSYS_O_PATH
CCSYS_O_SYNC      CCSYS_O_TMPFILE   CCSYS_O_TRUNC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_flags_t}; @ref{ccsys_open_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_S_IRUSR}
@EnumeratedConstant{CCSYS_S_IWUSR}
@EnumeratedConstant{CCSYS_S_IXUSR}
@EnumeratedConstant{CCSYS_S_IRGRP}
@EnumeratedConstant{CCSYS_S_IWGRP}
@EnumeratedConstant{CCSYS_S_IXGRP}
@EnumeratedConstant{CCSYS_S_IROTH}
@EnumeratedConstant{CCSYS_S_IWOTH}
@EnumeratedConstant{CCSYS_S_IXOTH}
@EnumeratedConstant{CCSYS_S_IRWXU}
@EnumeratedConstant{CCSYS_S_IRWXG}
@EnumeratedConstant{CCSYS_S_IRWXO}
@EnumeratedConstant{CCSYS_S_ISUID}
@EnumeratedConstant{CCSYS_S_ISGID}
@EnumeratedConstant{CCSYS_S_ISVTX}
@anchor{ccsys_open_mode_enum_t}
@deftp {Enum Typedef} ccsys_open_mode_enum_t
Type of file open mode constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{mode} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_S_IRUSR   CCSYS_S_IWUSR   CCSYS_S_IXUSR
CCSYS_S_IRGRP   CCSYS_S_IWGRP   CCSYS_S_IXGRP
CCSYS_S_IROTH   CCSYS_S_IWOTH   CCSYS_S_IXOTH
CCSYS_S_IRWXU   CCSYS_S_IRWXG   CCSYS_S_IRWXO
CCSYS_S_ISUID   CCSYS_S_ISGID   CCSYS_S_ISVTX
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_mode_t}; @ref{ccsys_open_mode_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_FD_CLOEXEC}
@anchor{ccsys_fd_flags_enum_t}
@deftp {Enum Typedef} ccsys_fd_flags_enum_t
Type of file descriptor flags constants.  It defines the following constants:

@example
CCSYS_FD_CLOEXEC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_fd_flags_t}; @ref{ccsys_fd_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SEEK_SET}
@EnumeratedConstant{CCSYS_SEEK_CUR}
@EnumeratedConstant{CCSYS_SEEK_END}
@anchor{ccsys_whence_enum_t}
@deftp {Enum Typedef} ccsys_whence_enum_t
Type of @var{whence} arguments to file seek functions.  It defines the following constants:

@example
CCSYS_SEEK_SET
CCSYS_SEEK_CUR
CCSYS_SEEK_END
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_whence_t};
@ref{ccsys_whence_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_RWF_HIPRI}
@EnumeratedConstant{CCSYS_RWF_NOWAIT}
@anchor{ccsys_scatter_gather_flags_enum_t}
@deftp {Enum Typedef} ccsys_scatter_gather_flags_enum_t
Type of @var{flags} arguments to some scatter/gather file input/output functions.  It defines the
following constants:

@example
CCSYS_RWF_HIPRI
CCSYS_RWF_NOWAIT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_scatter_gather_flags_t}; @ref{ccsys_scatter_gather_flags_t, Semantic type
definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AT_REMOVEDIR}
@anchor{ccsys_unlinkat_flags_enum_t}
@deftp {Enum Typedef} ccsys_unlinkat_flags_enum_t
Type of flags for @code{at()} functions.  These constants are meant to be used, for example, as
value for the argument @var{flags} of @cfunc{ccsys_unlinkat}.  It defines the following constants:

@example
CCSYS_AT_REMOVEDIR
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_unlinkat_flags_t}; @ref{ccsys_unlinkat_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AT_EMPTY_PATH}
@EnumeratedConstant{CCSYS_AT_NO_AUTOMOUNT}
@EnumeratedConstant{CCSYS_AT_SYMLINK_FOLLOW}
@EnumeratedConstant{CCSYS_AT_SYMLINK_NOFOLLOW}
@anchor{ccsys_at_flags_enum_t}
@deftp {Enum Typedef} ccsys_at_flags_enum_t
Type of flags for some ``at'' functions like @cfunc{ccsys_fstatat} and @cfunc{ccsys_linkat}.  It
defines the following constants:

@example
CCSYS_AT_EMPTY_PATH
CCSYS_AT_NO_AUTOMOUNT
CCSYS_AT_SYMLINK_FOLLOW
CCSYS_AT_SYMLINK_NOFOLLOW
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_fstatat_flags_t} and @objtype{ccsys_linkat_flags_t}.  @ref{ccsys_fstatat_flags_t,
Semantic type definitions}.  @ref{ccsys_linkat_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_S_IFMT}
@EnumeratedConstant{CCSYS_S_IFSOCK}
@EnumeratedConstant{CCSYS_S_IFLNK}
@EnumeratedConstant{CCSYS_S_IFREG}
@EnumeratedConstant{CCSYS_S_IFBLK}
@EnumeratedConstant{CCSYS_S_IFDIR}
@EnumeratedConstant{CCSYS_S_IFCHR}
@EnumeratedConstant{CCSYS_S_IFIFO}
@anchor{ccsys_stat_mode_enum_t}
@deftp {Enum Typedef} ccsys_stat_mode_enum_t
Type of flags for the interpretation of the field @code{st_mode} in @objtype{struct stat}.  It
defines the following constants:

@example
CCSYS_S_IFMT    CCSYS_S_IFSOCK  CCSYS_S_IFLNK
CCSYS_S_IFREG   CCSYS_S_IFBLK   CCSYS_S_IFDIR
CCSYS_S_IFCHR   CCSYS_S_IFIFO
@end example
@end deftp


@EnumeratedConstant{CCSYS_RENAME_EXCHANGE}
@EnumeratedConstant{CCSYS_RENAME_NOREPLACE}
@EnumeratedConstant{CCSYS_RENAME_WHITEOUT}
@anchor{ccsys_renameat2_flags_enum_t}
@deftp {Enum Typedef} ccsys_renameat2_flags_enum_t
Type of flags for @cfunc{ccsys_renameat2}.  It defines the following constants:

@example
CCSYS_RENAME_EXCHANGE
CCSYS_RENAME_NOREPLACE
CCSYS_RENAME_WHITEOUT
@end example
@end deftp


@EnumeratedConstant{CCSYS_F_OK}
@EnumeratedConstant{CCSYS_R_OK}
@EnumeratedConstant{CCSYS_W_OK}
@EnumeratedConstant{CCSYS_X_OK}
@anchor{ccsys_access_mode_enum_t}
@deftp {Enum Typedef} ccsys_access_mode_enum_t
Type of flags for @cfunc{ccsys_access}.  It defines the following constants:

@example
CCSYS_F_OK  CCSYS_R_OK  CCSYS_W_OK  CCSYS_X_OK
@end example
@end deftp


@EnumeratedConstant{CCSYS_SOCK_STREAM}
@EnumeratedConstant{CCSYS_SOCK_DGRAM}
@EnumeratedConstant{CCSYS_SOCK_SEQPACKET}
@EnumeratedConstant{CCSYS_SOCK_RAW}
@EnumeratedConstant{CCSYS_SOCK_RDM}
@EnumeratedConstant{CCSYS_SOCK_PACKET}
@anchor{ccsys_socket_namespace_enum_t}
@deftp {Enum Typedef} ccsys_socket_namespace_enum_t
Type of socket namespace selection constants.  These constants are meant to be used, for example, as
value for the argument @var{domain} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_DGRAM
CCSYS_SOCK_PACKET
CCSYS_SOCK_RAW
CCSYS_SOCK_RDM
CCSYS_SOCK_SEQPACKET
CCSYS_SOCK_STREAM
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_namespce_t}; @ref{ccsys_socket_namespace_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AF_UNIX}
@EnumeratedConstant{CCSYS_AF_LOCAL}
@EnumeratedConstant{CCSYS_AF_INET}
@EnumeratedConstant{CCSYS_AF_INET6}
@EnumeratedConstant{CCSYS_AF_IPX}
@EnumeratedConstant{CCSYS_AF_NETLINK}
@EnumeratedConstant{CCSYS_AF_X25}
@EnumeratedConstant{CCSYS_AF_AX25}
@EnumeratedConstant{CCSYS_AF_ATMPVC}
@EnumeratedConstant{CCSYS_AF_APPLETALK}
@EnumeratedConstant{CCSYS_AF_PACKET}
@EnumeratedConstant{CCSYS_AF_ALG}
@anchor{ccsys_socket_style_enum_t}
@deftp {Enum Typedef} ccsys_socket_style_enum_t
Type of socket style selection constants.  These constants are meant to be used, for example, as
value for the argument @var{type} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_AF_UNIX       CCSYS_AF_LOCAL   CCSYS_AF_INET
CCSYS_AF_INET6      CCSYS_AF_IPX     CCSYS_AF_NETLINK
CCSYS_AF_X25        CCSYS_AF_AX25    CCSYS_AF_ATMPVC
CCSYS_AF_APPLETALK  CCSYS_AF_PACKET  CCSYS_AF_ALG
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_style_t}; @ref{ccsys_socket_style_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SOCK_PROTOCOL_IP}
@anchor{ccsys_socket_protocol_enum_t}
@deftp {Enum Typedef} ccsys_socket_protocol_enum_t
Type of socket protocol selection constants.  These constants are meant to be used, for example, as
value for the argument @var{protocol} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_PROTOCOL_IP
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_protocol_t}; @ref{ccsys_socket_protocol_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MCL_CURRENT}
@EnumeratedConstant{CCSYS_MCL_FUTURE}
@EnumeratedConstant{CCSYS_MCL_ONFAULT}
@anchor{ccsys_memory_locking_enum_t}
@deftp {Enum Typedef} ccsys_memory_locking_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mlockall}.  It defines the
following constants:

@example
CCSYS_MCL_CURRENT
CCSYS_MCL_FUTURE
CCSYS_MCL_ONFAULT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mlockall_flags_t}; @ref{ccsys_mlockall_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_PROT_EXEC}
@EnumeratedConstant{CCSYS_PROT_READ}
@EnumeratedConstant{CCSYS_PROT_WRITE}
@EnumeratedConstant{CCSYS_PROT_NONE}
@anchor{ccsys_memory_protection_enum_t}
@deftp {Enum Typedef} ccsys_memory_protection_enum_t
Enumeration of constants for the argument @var{prot} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_PROT_EXEC
CCSYS_PROT_READ
CCSYS_PROT_WRITE
CCSYS_PROT_NONE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_prot_t}; @ref{ccsys_mmap_prot_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MAP_SHARED}
@EnumeratedConstant{CCSYS_MAP_PRIVATE}
@EnumeratedConstant{CCSYS_MAP_32BIT}
@EnumeratedConstant{CCSYS_MAP_ANON}
@EnumeratedConstant{CCSYS_MAP_ANONYMOUS}
@EnumeratedConstant{CCSYS_MAP_DENYWRITE}
@EnumeratedConstant{CCSYS_MAP_EXECUTABLE}
@EnumeratedConstant{CCSYS_MAP_FILE}
@EnumeratedConstant{CCSYS_MAP_FIXED}
@EnumeratedConstant{CCSYS_MAP_GROWSDOWN}
@EnumeratedConstant{CCSYS_MAP_HUGETLB}
@EnumeratedConstant{CCSYS_MAP_HUGE_2MB}
@EnumeratedConstant{CCSYS_MAP_HUGE_1GB}
@EnumeratedConstant{CCSYS_MAP_LOCKED}
@EnumeratedConstant{CCSYS_MAP_NONBLOCK}
@EnumeratedConstant{CCSYS_MAP_NORESERVE}
@EnumeratedConstant{CCSYS_MAP_POPULATE}
@EnumeratedConstant{CCSYS_MAP_STACK}
@EnumeratedConstant{CCSYS_MAP_UNINITIALIZED}
@EnumeratedConstant{CCSYS_MAP_AUTOGROW}
@EnumeratedConstant{CCSYS_MAP_AUTORESRV}
@EnumeratedConstant{CCSYS_MAP_COPY}
@EnumeratedConstant{CCSYS_MAP_LOCAL}
@anchor{ccsys_memory_mapping_enum_t}
@deftp {Enum Typedef} ccsys_memory_mapping_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_MAP_SHARED        CCSYS_MAP_PRIVATE     CCSYS_MAP_32BIT
CCSYS_MAP_ANON          CCSYS_MAP_ANONYMOUS   CCSYS_MAP_DENYWRITE
CCSYS_MAP_EXECUTABLE    CCSYS_MAP_FILE        CCSYS_MAP_FIXED
CCSYS_MAP_GROWSDOWN     CCSYS_MAP_HUGETLB     CCSYS_MAP_HUGE_2MB
CCSYS_MAP_HUGE_1GB      CCSYS_MAP_LOCKED      CCSYS_MAP_NONBLOCK
CCSYS_MAP_NORESERVE     CCSYS_MAP_POPULATE    CCSYS_MAP_STACK
CCSYS_MAP_UNINITIALIZED CCSYS_MAP_AUTOGROW    CCSYS_MAP_AUTORESRV
CCSYS_MAP_COPY          CCSYS_MAP_LOCAL
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_flags_t}; @ref{ccsys_mmap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MS_ASYNC}
@EnumeratedConstant{CCSYS_MS_SYNC}
@EnumeratedConstant{CCSYS_MS_INVALIDATE}
@anchor{ccsys_memory_sync_enum_t}
@deftp {Enum Typedef} ccsys_memory_sync_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_msync}.  It defines the
following constants:

@example
CCSYS_MS_ASYNC
CCSYS_MS_SYNC
CCSYS_MS_INVALIDATE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_msync_flags_t}; @ref{ccsys_msync_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MREMAP_MAYMOVE}
@EnumeratedConstant{CCSYS_MREMAP_FIXED}
@anchor{ccsys_memory_remap_enum_t}
@deftp {Enum Typedef} ccsys_memory_remap_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mremap}.  It defines the
following constants:

@example
CCSYS_MREMAP_MAYMOVE
CCSYS_MREMAP_FIXED
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mremap_flags_t}; @ref{ccsys_mremap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MADV_NORMAL}
@EnumeratedConstant{CCSYS_MADV_RANDOM}
@EnumeratedConstant{CCSYS_MADV_SEQUENTIAL}
@EnumeratedConstant{CCSYS_MADV_WILLNEED}
@EnumeratedConstant{CCSYS_MADV_DONTNEED}
@EnumeratedConstant{CCSYS_MADV_REMOVE}
@EnumeratedConstant{CCSYS_MADV_DONTFORK}
@EnumeratedConstant{CCSYS_MADV_DOFORK}
@EnumeratedConstant{CCSYS_MADV_HWPOISON}
@EnumeratedConstant{CCSYS_MADV_MERGEABLE}
@EnumeratedConstant{CCSYS_MADV_UNMERGEABLE}
@EnumeratedConstant{CCSYS_MADV_SOFT_OFFLINE}
@EnumeratedConstant{CCSYS_MADV_HUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_NOHUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_DONTDUMP}
@EnumeratedConstant{CCSYS_MADV_DODUMP}
@EnumeratedConstant{CCSYS_MADV_FREE}
@anchor{ccsys_memory_advice_enum_t}
@deftp {Enum Typedef} ccsys_memory_advice_enum_t
Enumeration of constants for the argument @var{advice} in @cfunc{ccsys_madvise}.  It defines the
following constants:

@example
CCSYS_MADV_NORMAL       CCSYS_MADV_RANDOM       CCSYS_MADV_SEQUENTIAL
CCSYS_MADV_WILLNEED     CCSYS_MADV_DONTNEED     CCSYS_MADV_REMOVE
CCSYS_MADV_DONTFORK     CCSYS_MADV_DOFORK       CCSYS_MADV_HWPOISON
CCSYS_MADV_MERGEABLE    CCSYS_MADV_UNMERGEABLE  CCSYS_MADV_SOFT_OFFLINE
CCSYS_MADV_HUGEPAGE     CCSYS_MADV_NOHUGEPAGE   CCSYS_MADV_DONTDUMP
CCSYS_MADV_DODUMP       CCSYS_MADV_FREE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_madvise_advice_t}; @ref{ccsys_madvise_advice_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_WNOHANG}
@EnumeratedConstant{CCSYS_WUNTRACED}
@EnumeratedConstant{CCSYS_WCONTINUED}
@anchor{ccsys_waitpid_options_enum_t}
@deftp {Enum Typedef} ccsys_waitpid_options_enum_t
Enumeration of constants representing process wait options.  It defines the following constants:

@example
CCSYS_WNOHANG
CCSYS_WUNTRACED
CCSYS_WCONTINUED
@end example
@end deftp


@EnumeratedConstant{CCSYS_EPERM}
@EnumeratedConstant{CCSYS_ENOENT}
@EnumeratedConstant{CCSYS_ESRCH}
@EnumeratedConstant{CCSYS_EINTR}
@EnumeratedConstant{CCSYS_EIO}
@EnumeratedConstant{CCSYS_ENXIO}
@EnumeratedConstant{CCSYS_E2BIG}
@EnumeratedConstant{CCSYS_ENOEXEC}
@EnumeratedConstant{CCSYS_EBADF}
@EnumeratedConstant{CCSYS_ECHILD}
@EnumeratedConstant{CCSYS_EPROCLIM}
@EnumeratedConstant{CCSYS_EAGAIN}
@EnumeratedConstant{CCSYS_ENOMEM}
@EnumeratedConstant{CCSYS_EACCES}
@EnumeratedConstant{CCSYS_EFAULT}
@EnumeratedConstant{CCSYS_ENOTBLK}
@EnumeratedConstant{CCSYS_EBUSY}
@EnumeratedConstant{CCSYS_EEXIST}
@EnumeratedConstant{CCSYS_EXDEV}
@EnumeratedConstant{CCSYS_ENODEV}
@EnumeratedConstant{CCSYS_ENOTDIR}
@EnumeratedConstant{CCSYS_EISDIR}
@EnumeratedConstant{CCSYS_EINVAL}
@EnumeratedConstant{CCSYS_ENFILE}
@EnumeratedConstant{CCSYS_EMFILE}
@EnumeratedConstant{CCSYS_ENOTTY}
@EnumeratedConstant{CCSYS_ETXTBSY}
@EnumeratedConstant{CCSYS_EFBIG}
@EnumeratedConstant{CCSYS_ENOSPC}
@EnumeratedConstant{CCSYS_ESPIPE}
@EnumeratedConstant{CCSYS_EROFS}
@EnumeratedConstant{CCSYS_EMLINK}
@EnumeratedConstant{CCSYS_EPIPE}
@EnumeratedConstant{CCSYS_EDOM}
@EnumeratedConstant{CCSYS_ERANGE}
@EnumeratedConstant{CCSYS_EDEADLK}
@EnumeratedConstant{CCSYS_ENAMETOOLONG}
@EnumeratedConstant{CCSYS_ENOLCK}
@EnumeratedConstant{CCSYS_ENOSYS}
@EnumeratedConstant{CCSYS_ENOTEMPTY}
@EnumeratedConstant{CCSYS_ELOOP}
@EnumeratedConstant{CCSYS_EWOULDBLOCK}
@EnumeratedConstant{CCSYS_ENOMSG}
@EnumeratedConstant{CCSYS_EIDRM}
@EnumeratedConstant{CCSYS_ECHRNG}
@EnumeratedConstant{CCSYS_EL2NSYNC}
@EnumeratedConstant{CCSYS_EL3HLT}
@EnumeratedConstant{CCSYS_EL3RST}
@EnumeratedConstant{CCSYS_ELNRNG}
@EnumeratedConstant{CCSYS_EUNATCH}
@EnumeratedConstant{CCSYS_ENOCSI}
@EnumeratedConstant{CCSYS_EL2HLT}
@EnumeratedConstant{CCSYS_EBADE}
@EnumeratedConstant{CCSYS_EBADR}
@EnumeratedConstant{CCSYS_EXFULL}
@EnumeratedConstant{CCSYS_ENOANO}
@EnumeratedConstant{CCSYS_EBADRQC}
@EnumeratedConstant{CCSYS_EBADSLT}
@EnumeratedConstant{CCSYS_EDEADLOCK}
@EnumeratedConstant{CCSYS_EBFONT}
@EnumeratedConstant{CCSYS_ENOSTR}
@EnumeratedConstant{CCSYS_ENODATA}
@EnumeratedConstant{CCSYS_ETIME}
@EnumeratedConstant{CCSYS_ENOSR}
@EnumeratedConstant{CCSYS_ENONET}
@EnumeratedConstant{CCSYS_ENOPKG}
@EnumeratedConstant{CCSYS_EREMOTE}
@EnumeratedConstant{CCSYS_ENOLINK}
@EnumeratedConstant{CCSYS_EADV}
@EnumeratedConstant{CCSYS_ESRMNT}
@EnumeratedConstant{CCSYS_ECOMM}
@EnumeratedConstant{CCSYS_EPROTO}
@EnumeratedConstant{CCSYS_EMULTIHOP}
@EnumeratedConstant{CCSYS_EDOTDOT}
@EnumeratedConstant{CCSYS_EBADMSG}
@EnumeratedConstant{CCSYS_EOVERFLOW}
@EnumeratedConstant{CCSYS_ENOTUNIQ}
@EnumeratedConstant{CCSYS_EBADFD}
@EnumeratedConstant{CCSYS_EREMCHG}
@EnumeratedConstant{CCSYS_ELIBACC}
@EnumeratedConstant{CCSYS_ELIBBAD}
@EnumeratedConstant{CCSYS_ELIBSCN}
@EnumeratedConstant{CCSYS_ELIBMAX}
@EnumeratedConstant{CCSYS_ELIBEXEC}
@EnumeratedConstant{CCSYS_EILSEQ}
@EnumeratedConstant{CCSYS_ERESTART}
@EnumeratedConstant{CCSYS_ESTRPIPE}
@EnumeratedConstant{CCSYS_EUSERS}
@EnumeratedConstant{CCSYS_ENOTSOCK}
@EnumeratedConstant{CCSYS_EDESTADDRREQ}
@EnumeratedConstant{CCSYS_EMSGSIZE}
@EnumeratedConstant{CCSYS_EPROTOTYPE}
@EnumeratedConstant{CCSYS_ENOPROTOOPT}
@EnumeratedConstant{CCSYS_EPROTONOSUPPORT}
@EnumeratedConstant{CCSYS_ESOCKTNOSUPPORT}
@EnumeratedConstant{CCSYS_EOPNOTSUPP}
@EnumeratedConstant{CCSYS_EPFNOSUPPORT}
@EnumeratedConstant{CCSYS_EAFNOSUPPORT}
@EnumeratedConstant{CCSYS_EADDRINUSE}
@EnumeratedConstant{CCSYS_EADDRNOTAVAIL}
@EnumeratedConstant{CCSYS_ENETDOWN}
@EnumeratedConstant{CCSYS_ENETUNREACH}
@EnumeratedConstant{CCSYS_ENETRESET}
@EnumeratedConstant{CCSYS_ECONNABORTED}
@EnumeratedConstant{CCSYS_ECONNRESET}
@EnumeratedConstant{CCSYS_ENOBUFS}
@EnumeratedConstant{CCSYS_EISCONN}
@EnumeratedConstant{CCSYS_ENOTCONN}
@EnumeratedConstant{CCSYS_ESHUTDOWN}
@EnumeratedConstant{CCSYS_ETOOMANYREFS}
@EnumeratedConstant{CCSYS_ETIMEDOUT}
@EnumeratedConstant{CCSYS_ECONNREFUSED}
@EnumeratedConstant{CCSYS_EHOSTDOWN}
@EnumeratedConstant{CCSYS_EHOSTUNREACH}
@EnumeratedConstant{CCSYS_EALREADY}
@EnumeratedConstant{CCSYS_EINPROGRESS}
@EnumeratedConstant{CCSYS_ESTALE}
@EnumeratedConstant{CCSYS_EUCLEAN}
@EnumeratedConstant{CCSYS_ENOTNAM}
@EnumeratedConstant{CCSYS_ENAVAIL}
@EnumeratedConstant{CCSYS_EISNAM}
@EnumeratedConstant{CCSYS_EREMOTEIO}
@EnumeratedConstant{CCSYS_EDQUOT}
@EnumeratedConstant{CCSYS_ENOMEDIUM}
@EnumeratedConstant{CCSYS_EMEDIUMTYPE}
@EnumeratedConstant{CCSYS_ECANCELED}
@EnumeratedConstant{CCSYS_ENOKEY}
@EnumeratedConstant{CCSYS_EKEYEXPIRED}
@EnumeratedConstant{CCSYS_EKEYREVOKED}
@EnumeratedConstant{CCSYS_EKEYREJECTED}
@EnumeratedConstant{CCSYS_EOWNERDEAD}
@EnumeratedConstant{CCSYS_ENOTRECOVERABLE}
@EnumeratedConstant{CCSYS_EBADRPC}
@EnumeratedConstant{CCSYS_ERPCMISMATCH}
@EnumeratedConstant{CCSYS_EPROGUNAVAIL}
@EnumeratedConstant{CCSYS_EPROGMISMATCH}
@EnumeratedConstant{CCSYS_EPROCUNAVAIL}
@EnumeratedConstant{CCSYS_EFTYPE}
@EnumeratedConstant{CCSYS_EAUTH}
@EnumeratedConstant{CCSYS_ENEEDAUTH}
@EnumeratedConstant{CCSYS_ENOTSUP}
@EnumeratedConstant{CCSYS_EBACKGROUND}
@EnumeratedConstant{CCSYS_EDIED}
@EnumeratedConstant{CCSYS_ERFKILL}
@EnumeratedConstant{CCSYS_EHWPOISON}
@anchor{ccsys_errno_enum_t}
@deftp {Enum Typedef} ccsys_errno_enum_t
Enumeration constants representing @code{errno} codes.  It defines the following constants:

@example
CCSYS_EPERM             CCSYS_ENOENT            CCSYS_ESRCH
CCSYS_EINTR             CCSYS_EIO               CCSYS_ENXIO
CCSYS_E2BIG             CCSYS_ENOEXEC           CCSYS_EBADF
CCSYS_ECHILD            CCSYS_EPROCLIM          CCSYS_EAGAIN
CCSYS_ENOMEM            CCSYS_EACCES            CCSYS_EFAULT
CCSYS_ENOTBLK           CCSYS_EBUSY             CCSYS_EEXIST
CCSYS_EXDEV             CCSYS_ENODEV            CCSYS_ENOTDIR
CCSYS_EISDIR            CCSYS_EINVAL            CCSYS_ENFILE
CCSYS_EMFILE            CCSYS_ENOTTY            CCSYS_ETXTBSY
CCSYS_EFBIG             CCSYS_ENOSPC            CCSYS_ESPIPE
CCSYS_EROFS             CCSYS_EMLINK            CCSYS_EPIPE
CCSYS_EDOM              CCSYS_ERANGE            CCSYS_EDEADLK
CCSYS_ENAMETOOLONG      CCSYS_ENOLCK            CCSYS_ENOSYS
CCSYS_ENOTEMPTY         CCSYS_ELOOP             CCSYS_EWOULDBLOCK
CCSYS_ENOMSG            CCSYS_EIDRM             CCSYS_ECHRNG
CCSYS_EL2NSYNC          CCSYS_EL3HLT            CCSYS_EL3RST
CCSYS_ELNRNG            CCSYS_EUNATCH           CCSYS_ENOCSI
CCSYS_EL2HLT            CCSYS_EBADE             CCSYS_EBADR
CCSYS_EXFULL            CCSYS_ENOANO            CCSYS_EBADRQC
CCSYS_EBADSLT           CCSYS_EDEADLOCK         CCSYS_EBFONT
CCSYS_ENOSTR            CCSYS_ENODATA           CCSYS_ETIME
CCSYS_ENOSR             CCSYS_ENONET            CCSYS_ENOPKG
CCSYS_EREMOTE           CCSYS_ENOLINK           CCSYS_EADV
CCSYS_ESRMNT            CCSYS_ECOMM             CCSYS_EPROTO
CCSYS_EMULTIHOP         CCSYS_EDOTDOT           CCSYS_EBADMSG
CCSYS_EOVERFLOW         CCSYS_ENOTUNIQ          CCSYS_EBADFD
CCSYS_EREMCHG           CCSYS_ELIBACC           CCSYS_ELIBBAD
CCSYS_ELIBSCN           CCSYS_ELIBMAX           CCSYS_ELIBEXEC
CCSYS_EILSEQ            CCSYS_ERESTART          CCSYS_ESTRPIPE
CCSYS_EUSERS            CCSYS_ENOTSOCK          CCSYS_EDESTADDRREQ
CCSYS_EMSGSIZE          CCSYS_EPROTOTYPE        CCSYS_ENOPROTOOPT
CCSYS_EPROTONOSUPPORT   CCSYS_ESOCKTNOSUPPORT   CCSYS_EOPNOTSUPP
CCSYS_EPFNOSUPPORT      CCSYS_EAFNOSUPPORT      CCSYS_EADDRINUSE
CCSYS_EADDRNOTAVAIL     CCSYS_ENETDOWN          CCSYS_ENETUNREACH
CCSYS_ENETRESET         CCSYS_ECONNABORTED      CCSYS_ECONNRESET
CCSYS_ENOBUFS           CCSYS_EISCONN           CCSYS_ENOTCONN
CCSYS_ESHUTDOWN         CCSYS_ETOOMANYREFS      CCSYS_ETIMEDOUT
CCSYS_ECONNREFUSED      CCSYS_EHOSTDOWN         CCSYS_EHOSTUNREACH
CCSYS_EALREADY          CCSYS_EINPROGRESS       CCSYS_ESTALE
CCSYS_EUCLEAN           CCSYS_ENOTNAM           CCSYS_ENAVAIL
CCSYS_EISNAM            CCSYS_EREMOTEIO         CCSYS_EDQUOT
CCSYS_ENOMEDIUM         CCSYS_EMEDIUMTYPE       CCSYS_ECANCELED
CCSYS_ENOKEY            CCSYS_EKEYEXPIRED       CCSYS_EKEYREVOKED
CCSYS_EKEYREJECTED      CCSYS_EOWNERDEAD        CCSYS_ENOTRECOVERABLE
CCSYS_EBADRPC           CCSYS_ERPCMISMATCH      CCSYS_EPROGUNAVAIL
CCSYS_EPROGMISMATCH     CCSYS_EPROCUNAVAIL      CCSYS_EFTYPE
CCSYS_EAUTH             CCSYS_ENEEDAUTH         CCSYS_ENOTSUP
CCSYS_EBACKGROUND       CCSYS_EDIED             CCSYS_ERFKILL
CCSYS_EHWPOISON
@end example
@end deftp


@EnumeratedConstant{CCSYS_SIGABRT}
@EnumeratedConstant{CCSYS_SIGALRM}
@EnumeratedConstant{CCSYS_SIGBUS}
@EnumeratedConstant{CCSYS_SIGCHLD}
@EnumeratedConstant{CCSYS_SIGCLD}
@EnumeratedConstant{CCSYS_SIGCONT}
@EnumeratedConstant{CCSYS_SIGEMT}
@EnumeratedConstant{CCSYS_SIGFPE}
@EnumeratedConstant{CCSYS_SIGHUP}
@EnumeratedConstant{CCSYS_SIGILL}
@EnumeratedConstant{CCSYS_SIGINFO}
@EnumeratedConstant{CCSYS_SIGINT}
@EnumeratedConstant{CCSYS_SIGIO}
@EnumeratedConstant{CCSYS_SIGIOT}
@EnumeratedConstant{CCSYS_SIGKILL}
@EnumeratedConstant{CCSYS_SIGLOST}
@EnumeratedConstant{CCSYS_SIGPIPE}
@EnumeratedConstant{CCSYS_SIGPOLL}
@EnumeratedConstant{CCSYS_SIGPROF}
@EnumeratedConstant{CCSYS_SIGQUIT}
@EnumeratedConstant{CCSYS_SIGSEGV}
@EnumeratedConstant{CCSYS_SIGSTOP}
@EnumeratedConstant{CCSYS_SIGSYS}
@EnumeratedConstant{CCSYS_SIGTERM}
@EnumeratedConstant{CCSYS_SIGTRAP}
@EnumeratedConstant{CCSYS_SIGTSTP}
@EnumeratedConstant{CCSYS_SIGTTIN}
@EnumeratedConstant{CCSYS_SIGTTOU}
@EnumeratedConstant{CCSYS_SIGURG}
@EnumeratedConstant{CCSYS_SIGUSR1}
@EnumeratedConstant{CCSYS_SIGUSR2}
@EnumeratedConstant{CCSYS_SIGVRALRM}
@EnumeratedConstant{CCSYS_SIGWINCH}
@EnumeratedConstant{CCSYS_SIGXCPU}
@EnumeratedConstant{CCSYS_SIGXSFZ}
@EnumeratedConstant{CCSYS_NSIG}
@anchor{ccsys_signum_enum_t}
@deftp {Enum Typedef} ccsys_signum_enum_t
Interprocess signal numbers.  It defines the following constants:

@example
CCSYS_SIGABRT           CCSYS_SIGALRM           CCSYS_SIGBUS
CCSYS_SIGCHLD           CCSYS_SIGCLD            CCSYS_SIGCONT
CCSYS_SIGEMT            CCSYS_SIGFPE            CCSYS_SIGHUP
CCSYS_SIGILL            CCSYS_SIGINFO           CCSYS_SIGINT
CCSYS_SIGIO             CCSYS_SIGIOT            CCSYS_SIGKILL
CCSYS_SIGLOST           CCSYS_SIGPIPE           CCSYS_SIGPOLL
CCSYS_SIGPROF           CCSYS_SIGQUIT           CCSYS_SIGSEGV
CCSYS_SIGSTOP           CCSYS_SIGSYS            CCSYS_SIGTERM
CCSYS_SIGTRAP           CCSYS_SIGTSTP           CCSYS_SIGTTIN
CCSYS_SIGTTOU           CCSYS_SIGURG            CCSYS_SIGUSR1
CCSYS_SIGUSR2           CCSYS_SIGVRALRM         CCSYS_SIGWINCH
CCSYS_SIGXCPU           CCSYS_SIGXSFZ
CCSYS_NSIG
@end example
@end deftp

@c page
@node memory
@chapter Memory allocation, locking, mapping

@menu
* memory basic::                Basic memory allocation.
* memory handler::              Basic memory handling.
* memory gmalloc::              Guarded allocation: @cfunc{malloc}.
* memory gcalloc::              Guarded allocation: @cfunc{calloc}.
* memory grealloc::             Guarded allocation: @cfunc{realloc}.
* memory locking::              Locking memory pages.
* memory mapping::              Memory mapping system calls.
@end menu

@c page
@node memory basic
@section Basic memory allocation


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc (cce_destination_t @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_realloc (cce_destination_t @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_calloc (cce_destination_t @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun void ccsys_free (cce_destination_t @var{L}, void * @var{ptr})
This is a plain wrapper for @cfunc{free}.  At present the argument @var{L} is unused.  This function
exists so that we can access this function by only including the header file @file{ccsys.h} and not
including the system header @file{stdlib.h}.
@end deftypefun

@c page
@node memory handler
@section Basic memory handling


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *        P = ccsys_malloc(L, 4096);
  ccsys_cleanup_handler_malloc_init(L, P_H, P);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void ccsys_error_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_malloc_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{P})
@deftypefnx {Preprocessor Macro} void ccsys_handler_malloc_init (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_malloc_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_malloc_init}.
@end table
@end deftypefn

@c page
@node memory gmalloc
@section Guarded allocation: @cfunc{malloc}


To allocate memory using a cleanup handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_malloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
@deftypefnx {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory gcalloc
@section Guarded allocation: @cfunc{calloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_calloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_calloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory grealloc
@section Guarded allocation: @cfunc{realloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_realloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefun {void *} ccsys_realloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory locking
@section Locking memory pages


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mlock (cce_destination_t @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{mlock}.
@end deftypefun


@deftypefun void ccsys_munlock (cce_destination_t @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{munlock}.
@end deftypefun


@deftypefun void ccsys_mlockall (cce_destination_t @var{L}, ccsys_mlockall_flags_t @var{flags})
Wrapper for @cfunc{mlockall}.  The argument @var{flags} is meant to be a bitwise combination of the
constants of type @objtype{ccsys_memory_locking_enum_t}.
@end deftypefun


@deftypefun void ccsys_munlockall (cce_location_t * @var{L})
Wrapper for @cfunc{munlockall}.
@end deftypefun

@c page
@node memory mapping
@section Memory mapping system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_mmap (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_mmap_prot_t @var{prot}, ccsys_mmap_flags_t @var{flags}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset})
Wrapper for @cfunc{mmap}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_mapping_enum_t}.
@end deftypefun


@deftypefun int ccsys_munmap (cce_destination_t @var{L}, void * @var{addr}, size_t @var{length})
Wrapper for @cfunc{munmap}.
@end deftypefun


@deftypefun int ccsys_msync (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_msync_flags_t @var{flags})
Wrapper for @cfunc{msync}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_sync_enum_t}.
@end deftypefun


@deftypefun int ccsys_mprotect (cce_destination_t @var{L}, void * @var{addr}, size_t @var{len}, ccsys_mmap_prot_t @var{prot})
Wrapper for @cfunc{mprotect}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.
@end deftypefun


@deftypefun {void *} ccsys_mremap (cce_destination_t @var{L}, void * @var{old_address}, size_t @var{length}, size_t @var{new_length}, ccsys_mremap_flags_t @var{flags}, void * @var{new_address})
Wrapper for @cfunc{mremap}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_remap_enum_t}.

@quotation
@strong{NOTE}  This function is specific to Linux platforms.
@end quotation
@end deftypefun


@deftypefun void ccsys_madvise (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_madvise_advice_t @var{advice})
Wrapper for @cfunc{madvise}.

The argument @var{advice} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_advice_enum_t}.

@quotation
@strong{NOTE}  This function is implemented by the @gnu{} C Library.
@end quotation
@end deftypefun

@c page
@node users
@chapter Users and groups system calls


@menu
* users persona::               Reading the persona of a process.
* users setuid::                Setting the user identity.
* users setgid::                Setting the group identity.
* users groups::                Setting and getting additional
                                group identities.
* users login::                 Who logged in.
* users usrdb::                 The users database.
* users grpdb::                 The groups database.
@end menu

@c page
@node users persona
@section Reading the persona of a process


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_uid_t ccsys_getuid (void)
Wrapper for @cfunc{getuid}; @manpage{getuid, Get user identity}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_getgid (void)
Wrapper for @cfunc{getgid}; @manpage{getgid, Get group identity}.
@end deftypefun


@deftypefun ccsys_uid_t ccsys_geteuid (void)
Wrapper for @cfunc{geteuid}; @manpage{getuid, Get user identity}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_getegid (void)
Wrapper for @cfunc{getegid}; @manpage{getuid, Get group identity}.
@end deftypefun

@c page
@node users setuid
@section Setting the user identity


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_setuid (cce_destination_t @var{L}, ccsys_uid_t @var{uid})
Wrapper for @cfunc{setuid}; @manpage{setuid, Setting the user identity}.
@end deftypefun


@deftypefun void ccsys_seteuid (cce_destination_t @var{L}, ccsys_uid_t @var{uid})
Wrapper for @cfunc{seteuid}; @manpage{seteuid, Setting the user identity}.
@end deftypefun


@deftypefun void ccsys_setreuid (cce_destination_t @var{L}, ccsys_uid_t @var{ruid}, ccsys_uid_t @var{euid})
Wrapper for @cfunc{setreuid}; @manpage{setreuid, Setting the user identity}.
@end deftypefun

@c page
@node users setgid
@section Setting the group identity


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_setgid (cce_destination_t @var{L}, ccsys_gid_t @var{gid})
Wrapper for @cfunc{setgid}; @manpage{setgid, Setting the user identity}.
@end deftypefun


@deftypefun void ccsys_setegid (cce_destination_t @var{L}, ccsys_gid_t @var{gid})
Wrapper for @cfunc{setegid}; @manpage{setegid, Setting the user identity}.
@end deftypefun


@deftypefun void ccsys_setregid (cce_destination_t @var{L}, ccsys_gid_t @var{rgid}, ccsys_gid_t @var{egid})
Wrapper for @cfunc{setregid}; @manpage{setregid, Setting the user identity}.
@end deftypefun

@c page
@node users groups
@section Setting and getting additional group identities


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_getgroups (cce_destination_t @var{L}, int @var{count}, ccsys_gid_t * @var{groups})
Wrapper for @cfunc{getgroups}; @manpage{getgroups, Get list of supplementary group IDs}.
@end deftypefun


@deftypefun int ccsys_getgroups_acquire_groups_number (cce_destination_t @var{L})
Special wrapper for @cfunc{getgroups} which returns the number of supplementary groups for the
process.
@end deftypefun


@deftypefun void ccsys_setgroups (cce_destination_t @var{L}, size_t @var{size},  ccsys_gid_t const * @var{groups})
Wrapper for @cfunc{setgroups}; @manpage{setgroups, Set list of supplementary group IDs}.
@end deftypefun


@deftypefun void ccsys_initgroups (cce_destination_t @var{L}, char const * @var{user}, ccsys_gid_t @var{gid})
Wrapper for @cfunc{initgroups}; @manpage{initgroups, Initialize the supplementary group access
list}.
@end deftypefun


@deftypefun void ccsys_getgrouplist (cce_destination_t @var{L}, char const * @var{user}, ccsys_gid_t @var{gid}, ccsys_gid_t * @var{groups}, int * @var{ngroups})
Wrapper for @cfunc{getgrouplist}; @manpage{getgrouplist, Get list of groups to which a user
belongs}.
@end deftypefun


@deftypefun int ccsys_getgrouplist_acquire_groups_number (cce_destination_t @var{L}, char const * @var{username})
Special wrapper for @cfunc{getgrouplist} which returns the number of groups for the selected user.
@end deftypefun

@menu
* users groups one::            Using @cfunc{ccsys_getgroups}.
* users groups two::            Using @cfunc{ccsys_getgrouplist}.
@end menu

@c page
@node users groups one
@subsection Using @cfunc{ccsys_getgroups}


As usage example of @cfunc{ccsys_getgroups} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  int         count;

  count = ccsys_getgroups_acquire_groups_number(L);
  @{
    ccsys_gid_t       groups[count];
    int               ngroups;

    ngroups = ccsys_getgroups(L, count, groups);

    for (int i=0; i<ngroups; ++i) @{
      printf("groups[%d]=%d\n", i, groups[i].data);
    @}
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users groups two
@subsection Using @cfunc{ccsys_getgrouplist}


As usage example of @cfunc{ccsys_getgrouplist} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        username = "marco";
  int                 count;

  count = ccsys_getgrouplist_acquire_groups_number(L, username);
  @{
    ccsys_gid_t       gid;
    int               ngroups = count;
    ccsys_gid_t       groups[ngroups];

    gid.data = 0;
    ccsys_getgrouplist(L, username, gid, groups, &ngroups);

    for (int i=0; i<ngroups; ++i) @{
      printf("groups[%d]=%d\n", i, groups[i].data);
    @}
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users login
@section Who logged in


The following symbols are defined in the header file @file{ccsys.h}.


@deftypevr {Preprocessor Symbol} int CCSYS_L_CUSERID
The maximum number of character to allocate to store a full user name.
@end deftypevr


@deftypefun void ccsys_getlogin_r (cce_destination_t L, char * buf, size_t maxlen)
Wrapper for @cfunc{getlogin_r}; @manpage{getlogin_r, Get the user name}.
@end deftypefun


@menu
* users login one::             Using @cfunc{getlogin_r}.
@end menu

@c page
@node users login one
@subsection Using @cfunc{getlogin_r}


As usage example of @cfunc{getlogin_r} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  size_t      maxlen = CCSYS_L_CUSERID;
  char        username[maxlen];

  ccsys_getlogin_r(L, username, maxlen);
  printf("login user=%s\n", username);
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users usrdb
@section The users database


@menu
* users usrdb struct::          The database entry structure.
* users usrdb lookup::          Looking up one user.
* users usrdb scan::            Scanning the database.
@end menu

@c page
@node users usrdb struct
@subsection The database entry structure


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_passwd_t
Opaque wrapper for @objtype{struct passwd}.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_NAME
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_name};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_PASSWD
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_passwd};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_UID
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_uid};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_GID
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_gid};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_GECOS
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_gecos};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_DIR
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_dir};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_PASSWD_PW_SHELL
Always defined.  Expands to @code{1} if @objtype{struct passwd} has the field @code{pw_shell};
otherwise it expands to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Field accessors


The following field accessors are defined only if @objtype{struct passwd} has the associated field;
otherwise they are not implemented.


@deftypefun {char const *} ccsys_ref_passwd_pw_name (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_name (ccsys_passwd_t const @var{S}, char const * @var{F})
Getter and setter for the field @code{pw_name} of @var{S}.
@end deftypefun


@deftypefun {char const *} ccsys_ref_passwd_pw_passwd (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_passwd (ccsys_passwd_t * @var{S}, char const * @var{F})
Getter and setter for the field @code{pw_passwd} of @var{S}.
@end deftypefun


@deftypefun ccsys_uid_t ccsys_ref_passwd_pw_uid (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_uid (ccsys_passwd_t * @var{S}, ccsys_uid_t @var{F})
Getter and setter for the field @code{pw_uid} of @var{S}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_ref_passwd_pw_gid (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_gid (ccsys_passwd_t * @var{S}, ccsys_gid_t @var{F})
Getter and setter for the field @code{pw_gid} of @var{S}.
@end deftypefun


@deftypefun {char const *} ccsys_ref_passwd_pw_gecos (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_gecos (ccsys_passwd_t * @var{S}, char const * @var{F})
Getter and setter for the field @code{pw_gecos} of @var{S}.
@end deftypefun


@deftypefun {char const *} ccsys_ref_passwd_pw_dir (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_dir (ccsys_passwd_t * @var{S}, char const * @var{F})
Getter and setter for the field @code{pw_dir} of @var{S}.
@end deftypefun


@deftypefun {char const *} ccsys_ref_passwd_pw_shell (ccsys_passwd_t const * @var{S})
@deftypefunx void ccsys_set_passwd_pw_shell (ccsys_passwd_t * @var{S}, char const * @var{F})
Getter and setter for the field @code{pw_shell} of @var{S}.
@end deftypefun

@c page
@node users usrdb lookup
@subsection Looking up one user


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {ccsys_passwd_t const *} ccsys_getpwuid (cce_destination_t @var{L}, ccsys_uid_t @var{uid})
Wrapper for @cfunc{getpwuid}; @manpage{getpwuid, Get password file entry}.  Notice that this
function never returns @cnull{}: in case of error an exception is raised.
@end deftypefun


@deftypefun {ccsys_passwd_t const *} ccsys_getpwnam (cce_destination_t @var{L}, ccsys_uid_t @var{uid})
Wrapper for @cfunc{getpwnam}; @manpage{getpwnam, Get password file entry}.  Notice that this
function never returns @cnull{}: in case of error an exception is raised.
@end deftypefun


@deftypefun bool ccsys_getpwuid_r (cce_destination_t @var{L}, ccsys_uid_t @var{uid}, ccsys_passwd_t * @var{result_buf}, char * @var{bufptr}, size_t @var{buflen}, ccsys_passwd_t ** @var{result})
Wrapper for @cfunc{getpwuid_r}; @manpage{getpwuid_r, Get password file entry}.  Notice that this
function never stores @cnull{} in the variable pointed to by @var{result}: in case of error an
exception is raised.

If the call to @cfunc{getpwuid_r} is successful: the return value is @true{}.  If @cfunc{getpwuid_r}
fails with @code{ERANGE}: the return value is @false{}, it means the region of memory pointer to by
@var{bufptr} is not wide enough to hold the results.
@end deftypefun


@deftypefun bool ccsys_getpwnam_r (cce_destination_t @var{L}, ccsys_uid_t @var{uid}, ccsys_passwd_t * @var{result_buf}, char * @var{bufptr}, size_t @var{buflen}, ccsys_passwd_t ** @var{result})
Wrapper for @cfunc{getpwnam_r}; @manpage{getpwnam_r, Get password file entry}.  Notice that this
function never stores @cnull{} in the variable pointed to by @var{result}: in case of error an
exception is raised.

If the call to @cfunc{getpwnam_r} is successful: the return value is @true{}.  If @cfunc{getpwnam_r}
fails with @code{ERANGE}: the return value is @false{}, it means the region of memory pointer to by
@var{bufptr} is not wide enough to hold the results.
@end deftypefun

@menu
* users usrdb lookup one::      Using @cfunc{getpwuid}.
* users usrdb lookup two::      Using @cfunc{getpwnam}.
* users usrdb lookup three::    Using @cfunc{getpwuid_r}.
* users usrdb lookup four::     Using @cfunc{getpwnam_r}.
@end menu

@c page
@node users usrdb lookup one
@subsubsection Using @cfunc{getpwuid}


As usage example of @cfunc{getpwuid} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_passwd_t const *      S;

  S = ccsys_getpwuid(L, ccsys_getuid());

  fprint("pw_name=%s\n",   ccsys_ref_passwd_pw_name(S));
  fprint("pw_passwd=%s\n", ccsys_ref_passwd_pw_passwd(S));
  fprint("pw_uid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_uid(S)));
  fprint("pw_gid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_gid(S)));
  fprint("pw_gecos=%s\n",  ccsys_ref_passwd_pw_gecos(S));
  fprint("pw_dir=%s\n",    ccsys_ref_passwd_pw_dir(S));
  fprint("pw_shell=%s\n",  ccsys_ref_passwd_pw_shell(S));

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users usrdb lookup two
@subsubsection Using @cfunc{getpwnam}


As usage example of @cfunc{getpwnam} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_passwd_t const *        S;

  S = ccsys_getpwnam(L, "root");

  fprint("pw_name=%s\n",   ccsys_ref_passwd_pw_name(S));
  fprint("pw_passwd=%s\n", ccsys_ref_passwd_pw_passwd(S));
  fprint("pw_uid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_uid(S)));
  fprint("pw_gid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_gid(S)));
  fprint("pw_gecos=%s\n",  ccsys_ref_passwd_pw_gecos(S));
  fprint("pw_dir=%s\n",    ccsys_ref_passwd_pw_dir(S));
  fprint("pw_shell=%s\n",  ccsys_ref_passwd_pw_shell(S));

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users usrdb lookup three
@subsubsection Using @cfunc{getpwuid_r}


As usage example of @cfunc{getpwuid_r} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_passwd_t      S;
  ccsys_passwd_t *    R;
  size_t              buflen = 4 * 4096;
  char                bufptr[buflen];
  bool                rv;

  rv = ccsys_getpwuid_r(L, ccsys_getuid(), &S, bufptr, buflen, &R);
  assert(true == rv);

  fprint("pw_name=%s\n",   ccsys_ref_passwd_pw_name(S));
  fprint("pw_passwd=%s\n", ccsys_ref_passwd_pw_passwd(S));
  fprint("pw_uid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_uid(S)));
  fprint("pw_gid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_gid(S)));
  fprint("pw_gecos=%s\n",  ccsys_ref_passwd_pw_gecos(S));
  fprint("pw_dir=%s\n",    ccsys_ref_passwd_pw_dir(S));
  fprint("pw_shell=%s\n",  ccsys_ref_passwd_pw_shell(S));

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users usrdb lookup four
@subsubsection Using @cfunc{getpwnam_r}


As usage example of @cfunc{getpwnam_r} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_passwd_t      S;
  ccsys_passwd_t *    R;
  size_t              buflen = 4 * 4096;
  char                bufptr[buflen];
  bool                rv;

  rv = ccsys_getpwnam_r(L, "root", &S, bufptr, buflen, &R);
  assert(true == rv);

  fprint("pw_name=%s\n",   ccsys_ref_passwd_pw_name(S));
  fprint("pw_passwd=%s\n", ccsys_ref_passwd_pw_passwd(S));
  fprint("pw_uid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_uid(S)));
  fprint("pw_gid=%d\n",    ccsys_dref(ccsys_ref_passwd_pw_gid(S)));
  fprint("pw_gecos=%s\n",  ccsys_ref_passwd_pw_gecos(S));
  fprint("pw_dir=%s\n",    ccsys_ref_passwd_pw_dir(S));
  fprint("pw_shell=%s\n",  ccsys_ref_passwd_pw_shell(S));

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users usrdb scan
@subsection Scanning the database


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_setpwent (cce_destination_t @var{L})
Wrapper for @cfunc{setpwent}; @manpage{setpwent, Get password file entry}.
@end deftypefun


@deftypefun void ccsys_endpwent (cce_destination_t @var{L})
Wrapper for @cfunc{endpwent}; @manpage{endpwent, Get password file entry}.
@end deftypefun


@deftypefun {ccsys_passwd_t const *} ccsys_getpwent (cce_destination_t @var{L})
Wrapper for @cfunc{getpwent}; @manpage{getpwent, Get password file entry}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun void ccsys_cleanup_handler_endpwent_init (cce_destination_t @var{L}, cce_handler_t * @var{H})
@deftypefunx void ccsys_error_handler_endpwent_init (cce_destination_t @var{L}, cce_handler_t * @var{H})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
reset the users database pointer using the standard function @cfunc{endpwent}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_endpwent_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H})
@deftypefnx {Preprocessor Macro} void ccsys_handler_endpwent_init (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_endpwent_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_endpwent_init}.
@end table
@end deftypefn


@menu
* users usrdb scan one::        Using @cfunc{ccsys_getpwent}.
@end menu

@c page
@node users usrdb scan one
@subsubsection Using @cfunc{ccsys_getpwent}


As usage example of @cfunc{ccsys_getpwent} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t endpwent_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_setpwent(L);
  ccsys_handler_endpwent_init(L, endpwent_H);

  for (ccsys_passwd_t const * S = ccsys_getpwent(L);
       NULL != S;
       S = ccsys_getpwent(L)) @{
    printf("pw_name=%s\n", ccsys_ref_passwd_pw_name(S));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node users grpdb
@section The groups database


@menu
* users grpdb struct::          The database entry structure.
* users grpdb lookup::          Looking up one user.
* users grpdb scan::            Scanning the database.
@end menu

@c page
@node users grpdb struct
@subsection The database entry structure


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_group_t
Opaque wrapper for @objtype{struct group}.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_GROUP_GR_NAME
Always defined.  Expands to @code{1} if @objtype{struct group} has the field @code{gr_name};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_GROUP_GR_GID
Always defined.  Expands to @code{1} if @objtype{struct group} has the field @code{gr_gid};
otherwise it expands to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_GROUP_GR_MEM
Always defined.  Expands to @code{1} if @objtype{struct group} has the field @code{gr_mem};
otherwise it expands to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Field getters


The following field accessors are defined only if @objtype{struct group} has the associated field;
otherwise they are not implemented.


@deftypefun {char const *} ccsys_ref_group_gr_name (ccsys_passwd_t const * @var{S})
Getter for the field @code{gr_name} of @var{S}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_ref_group_gr_gid (ccsys_passwd_t const * @var{S})
Getter for the field @code{gr_gid} of @var{S}.
@end deftypefun


@deftypefun {char const * const *} ccsys_ref_group_gr_mem (ccsys_passwd_t const * @var{S})
Getter for the field @code{gr_mem} of @var{S}.
@end deftypefun

@c page
@node users grpdb lookup
@subsection Looking up one user


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {ccsys_group_t const *} ccsys_getgrgid (cce_destination_t @var{L}, ccsys_gid_t @var{gid})
Wrapper for @cfunc{getgrgid}; @manpage{getgrgid, Get group file entry}.  Notice that this function
never returns @cnull{}: in case of error an exception is raised.
@end deftypefun


@deftypefun {ccsys_group_t const *} ccsys_getgrnam (cce_destination_t @var{L}, ccsys_gid_t @var{gid})
Wrapper for @cfunc{getgrnam}; @manpage{getgrnam, Get group file entry}.  Notice that this function
never returns @cnull{}: in case of error an exception is raised.
@end deftypefun


@deftypefun bool ccsys_getgrgid_r (cce_destination_t @var{L}, ccsys_gid_t @var{gid}, ccsys_group_t * @var{result_buf}, char * @var{bufptr}, size_t @var{buflen}, ccsys_group_t ** @var{result})
Wrapper for @cfunc{getgrgid_r}; @manpage{getgrgid_r, Get group file entry}.  Notice that this
function never stores @cnull{} in the variable pointed to by @var{result}: in case of error an
exception is raised.

If the call to @cfunc{getgrgid_r} is successful: the return value is @true{}.  If @cfunc{getgrgid_r}
fails with @code{ERANGE}: the return value is @false{}, it means the region of memory pointer to by
@var{bufptr} is not wide enough to hold the results.
@end deftypefun


@deftypefun bool ccsys_getgrnam_r (cce_destination_t @var{L}, ccsys_gid_t @var{gid}, ccsys_group_t * @var{result_buf}, char * @var{bufptr}, size_t @var{buflen}, ccsys_group_t ** @var{result})
Wrapper for @cfunc{getgrnam_r}; @manpage{getgrnam_r, Get group file entry}.  Notice that this
function never stores @cnull{} in the variable pointed to by @var{result}: in case of error an
exception is raised.

If the call to @cfunc{getgrnam_r} is successful: the return value is @true{}.  If @cfunc{getgrnam_r}
fails with @code{ERANGE}: the return value is @false{}, it means the region of memory pointer to by
@var{bufptr} is not wide enough to hold the results.
@end deftypefun

@c page
@node users grpdb scan
@subsection Scanning the database


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_setgrent (cce_destination_t @var{L})
Wrapper for @cfunc{setgrent}; @manpage{setgrent, Get group file entry}.
@end deftypefun


@deftypefun void ccsys_endgrent (cce_destination_t @var{L})
Wrapper for @cfunc{endgrent}; @manpage{endgrent, Get group file entry}.
@end deftypefun


@deftypefun {ccsys_group_t const *} ccsys_getgrent (cce_destination_t @var{L})
Wrapper for @cfunc{getgrent}; @manpage{getgrent, Get group file entry}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun void ccsys_cleanup_handler_endgrent_init (cce_destination_t @var{L}, cce_handler_t * @var{H})
@deftypefunx void ccsys_error_handler_endgrent_init (cce_destination_t @var{L}, cce_handler_t * @var{H})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
reset the users database pointer using the standard function @cfunc{endgrent}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_endgrent_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H})
@deftypefnx {Preprocessor Macro} void ccsys_handler_endgrent_init (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_endgrent_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_endgrent_init}.
@end table
@end deftypefn

@c page
@node io
@chapter Input/output system calls


@menu
* io constants::                Global constants.
* io fds::                      File descriptor helpers.
* io open::                     Opening files.
* io pipes::                    Creating pipes.
* io fifos::                    Creating FIFOs.
* io close::                    Closing file descriptors.
* io read write::               Reading and writing files.
* io scatter gather::           Scatter-gather input/output.
* io dup::                      Duplicating file descriptors.
* io select::                   Waiting for input/output.
* io sync::                     Committing file system caches to disk.
* io streams::                  Stream input/output.
@end menu

@c page
@node io constants
@section Global constants


@cindex Standard file descriptors
@cindex File descriptors, standard


The following symbols are defined in the header file @file{ccsys.h}.


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDIN
Constant representing the standard input file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDOUT
Constant representing the standard output file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDERR
Constant representing the standard error file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_SETSIZE
Constant representing the maximum value for the argument @var{nfds} to @cfunc{ccsys_select}.
@end deftypevr


@deftypevr Constant {ccsys_dirfd_t const} CCSYS_AT_FDCWD
Constant representing the current directory for the argument @var{dirfd} to @cfunc{ccsys_openat} and
@cfunc{ccsys_linkat}.
@end deftypevr

@c page
@node io fds
@section File descriptor helpers


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_dirfd_t ccsys_fd_to_dirfd (ccsys_fd_t @var{fd})
@deftypefunx ccsys_fd_t ccsys_fd_drom_dirfd (ccsys_dirfd_t @var{dirfd})
@deftypefunx ccsys_dirfd_t ccsys_dirfd_from_fd (ccsys_fd_t @var{fd})
@deftypefunx ccsys_fd_t ccsys_dirfd_to_fd (ccsys_dirfd_t @var{dirfd})
Convert between file descriptor semantic types.
@end deftypefun


@deftypefun bool ccsys_fd_equal (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return @true{} if the arguments are equal, otherwise return @false{}.  We can also perform this
operation using the @code{=} operator.
@end deftypefun


@deftypefun bool ccsys_fd_less_than (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_less_than_or_equal_to (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_greater_than (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_greater_than_or_equal_to (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return @true{} if the @vari{fd} with respect to @varii{fd} is: less than, less than or equal to,
greater than, greater than or equal to; otherwise return @false{}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_fd_min (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx ccsys_fd_t ccsys_fd_max (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return the minimum or maximum between the arguments.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_fd_incr (ccsys_fd_t @var{fd})
Increment the file descriptor in @var{fd} and return the result.  This function is useful to
generate the first argument to @cfunc{ccsys_select}; @ref{io select, ccsys_select} for details.
@end deftypefun


@c page
@node io open
@section Opening files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_open (cce_destination_t @var{L}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{open}.  @manpage{open, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_openat (cce_destination_t @var{L}, ccsys_dirfd_t @var{filedes}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{openat}.  @manpage{openat, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


We can use  @cfunc{ccsys_openat} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dir_H[1];
cce_cleanup_handler_t   dirstream_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  static char const * dirname  = "dir.d";
  static char const * filename = "name.ext";
  ccsys_dirfd_t       dirfd;

  /* Create the directory. */
  @{
    ccsys_open_mode_t   mode;

    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdir(L, dirname, mode);
    ccsys_handler_rmdir_init(L, dir_H, dirname);
  @}

  /* Open the directory.  The descriptor in "dirfd" is released
     automatically when "dirstream" is released. */
  @{
    ccsys_dir_t *     dirstream;

    dirstream = ccsys_opendir(L, dirname);
    ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
    dirfd = ccsys_dirfd(L, dirstream);
  @}

  /* Open the file. */
  @{
    ccsys_open_flags_t    flags;
    ccsys_open_mode_t     mode;
    ccsys_fd_t            fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, dirfd, filename, flags, mode);
    ccsys_handler_filedes_init(L, file_H, fd);

    /* Do something with "fd" here. */
  @}

  /* Remove the file. */
  @{
    ccsys_unlinkat_flags_t flags;

    flags.data = 0;
    ccsys_unlinkat(L, dirfd, filename, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io pipes
@section Creating pipes


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_pipe (cce_destination_t @var{L}, ccsys_fd_t @var{pipefd}[2])
Wrapper for @cfunc{pipe}.  @manpage{pipe, Create pipes}.
@end deftypefun


@deftypefun void ccsys_pipe2 (cce_destination_t @var{L}, ccsys_fd_t @var{pipefd}[2], ccsys_open_flags_t @var{flags})
Wrapper for @cfunc{pipe2}.  @manpage{pipe2, Create pipes}.
@end deftypefun

@menu
* io pipes handlers::           Pipes cleanup and error handlers.
* io pipes one::                Using @cfunc{ccsys_pipe}.
* io pipes two::                Using @cfunc{ccsys_pipe2}.
@end menu

@c page
@node io pipes handlers
@subsection Pipes cleanup and error handlers


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_fd_t    pipefd[2];
  ccsys_pipe(L, pipefd);
  ccsys_handler_pipedes_init(L, H, pipefd);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_pipedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
@deftypefunx void ccsys_error_handler_pipedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptors in @var{pipedes} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
@deftypefnx {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_pipedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_pipedes_init}.
@end table
@end deftypefn

@c page
@node io pipes one
@subsection Using @cfunc{ccsys_pipe}


As usage example of @cfunc{ccsys_pipe} see the following code.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  ccsys_fd_t    pipefd[2];

  /* Create the pipe. */
  @{
    ccsys_pipe(L, pipefd);
    ccsys_handler_pipedes_init(L, H, pipefd);
  @}

  /* Write to the pipe. */
  @{
    char *    buf = "0123456789";
    size_t    len = strlen(buf);
    size_t    N;
    N = ccsys_write(L, pipefd[1], buf, len);
    assert(N == len);
  @}

  /* Read from the pipe. */
  @{
    size_t    len = 256;
    char      buf[len];
    size_t    N;
    N = ccsys_read(L, pipefd[0], buf, len);
    assert(N == strlen("0123456789"));
    assert(0 == strncmp(buf, "0123456789", N));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io pipes two
@subsection Using @cfunc{ccsys_pipe2}


As usage example of @cfunc{ccsys_pipe2} see the following code.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  ccsys_fd_t          pipefd[2];

  /* Create the pipe. */
  @{
    ccsys_open_flags_t        flags;
    flags.data = CCSYS_O_CLOEXEC;
    ccsys_pipe2(L, pipefd, flags);
    ccsys_handler_pipedes_init(L, H, pipefd);
  @}

  /* Write to the pipe. */
  @{
    char *    buf = "0123456789";
    size_t    len = strlen(buf);
    size_t    N;
    N = ccsys_write(L, pipefd[1], buf, len);
    assert(N == len);
  @}

  /* Read from the pipe. */
  @{
    size_t    len = 256;
    char      buf[len];
    size_t    N;
    N = ccsys_read(L, pipefd[0], buf, len);
    assert(N == strlen("0123456789"));
    assert(0 == strncmp(buf, "0123456789", N));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io fifos
@section Creating FIFOs


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkfifo (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifo}.  @manpage{mkfifo, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun void ccsys_mkfifoat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifoat}.  @manpage{mkfifoat, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@menu
* io fifos mkfifo::             Usage example for @cfunc{ccsys_mkfifo}.
* io fifos mkfifoat::           Usage example for @cfunc{ccsys_mkfifoat}.
@end menu

@c page
@node io fifos mkfifo
@subsection Usage example for @cfunc{ccsys_mkfifo}


As example of @cfunc{ccsys_mkfifo} usage consider the following, which:

@enumerate
@item
Creates a named @fifo{}.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{remove};
waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    char const * fifoname);
void sample_child  (char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t fifo_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * fifoname = "fifo.ext";
    ccsys_pid_t         pid;

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t         mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifo(L, fifoname, mode);
      ccsys_handler_remove_init(L, fifo_H, fifoname);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;
        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child  (char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io fifos mkfifoat
@subsection Usage example for @cfunc{ccsys_mkfifoat}


As example of @cfunc{ccsys_mkfifoat} usage consider the following, which:

@enumerate
@item
Creates a directory.

@item
Creates a named @fifo{} in the directory.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{unlinkat};
removes the directory; waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    ccsys_dirfd_t dirfd, char const * fifoname);
void sample_child  (ccsys_dirfd_t dirfd, char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t dir_H[1];
  cce_cleanup_handler_t dirstream_H[1];
  cce_cleanup_handler_t fifo_H[1];
  ccsys_at_link_t       fifo_unlink_data;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * dirname  = "name.d";
    static char const * fifoname = "fifo.ext";
    ccsys_dirfd_t       dirfd;
    ccsys_pid_t         pid;

    /* Create the directory. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRWXU;
      ccsys_mkdir(L, dirname, mode);
      ccsys_handler_rmdir_init(L, dir_H, dirname);
    @}

    /* Open the directory. */
    @{
      ccsys_dir_t *     dirstream;
      dirstream = ccsys_opendir(L, dirname);
      ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
      dirfd = ccsys_dirfd(L, dirstream);
    @}

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifoat(L, dirfd, fifoname, mode);
      fifo_unlink_data.dirfd    = dirfd;
      fifo_unlink_data.pathname = fifoname;
      ccsys_handler_unlinkat_init(L, fifo_H, &fifo_unlink_data);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, dirfd, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;

        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(dirfd, fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L,
               ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child (ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io close
@section Closing file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_close (cce_destination_t @var{L}, ccsys_fd_t @var{filedes})
Wrapper for @cfunc{close}.  @manpage{close, Close a file descriptor}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading File descriptor handlers

We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_open_flags_t  flags;
  ccsys_open_mode_t   mode;
  ccsys_fd_t          fd;

  flags.data = CCSYS_O_CREAT;
  mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd = ccsys_open(L, filename, flags, mode);
  ccsys_handler_filedes_init(L, H, fd);

  /* Do something with "fd" here. */
  cce_run_cleanup_handlers(L);
@}
@end example


@deftypefun void ccsys_cleanup_handler_filedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefunx void ccsys_error_handler_filedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptor @var{fd} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_filedes_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefnx {Preprocessor Macro} void ccsys_handler_filedes_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{fd})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_filedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_filedes_init}.
@end table
@end deftypefn

@c page
@node io read write
@section Reading and writing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun size_t ccsys_read (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{read}; @manpage{read, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{read} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pread (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pread}; @manpage{pread, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{pread} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_write (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{write}; @manpage{read, Write to a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{write} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pwrite (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwrite}; @manpage{pwrite, Writing to a file descriptor}.  Notice the return value
of type @objtype{size_t}: the negative values returned by @cfunc{pwrite} are consumed by this
function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun ccsys_off_t ccsys_lseek (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset}, ccsys_whence_t @var{whence})
Wrapper for @cfunc{lseek}; @manpage{lseek, Reposition a read/write file offset}.
@end deftypefun

@menu
* io read write one::           @cfunc{ccsys_read} and @cfunc{ccsys_write}.
* io read write two::           @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}.
@end menu

@c page
@node io read write one
@subsection @cfunc{ccsys_read} and @cfunc{ccsys_write}


As example of using @cfunc{ccsys_read} and @cfunc{ccsys_write} see the following code which opens a
file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    N = ccsys_write(L, fd, buf, len);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    N = ccsys_read(L, fd, buf, len);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io read write two
@subsection @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}


As example of using @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    offset.data = 0;
    N = ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Reading. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    N = ccsys_pread(L, fd, buf, len, offset);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather
@section Scatter--gather input/output


@menu
* io scatter gather api::       Scatter--gather input/output @api{}.
* io scatter gather one::       Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}.
* io scatter gather two::       Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}.
@end menu

@c page
@node io scatter gather api
@subsection Scatter--gather input/output @api{}


For all the functions: notice the return value of type @objtype{size_t}: the negative values
returned by the system function is consumed by the wrapper function, so either the return value is
an unsigned integer or an exception is raised.

The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_iovec_t
Wrapper type for @objtype{struct iovec}.
@end deftp


@deftypefun size_t ccsys_readv (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{readv}; @manpage{readv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_writev (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{writev}; @manpage{writev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{preadv}; @manpage{preadv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwritev}; @manpage{pwritev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv2 (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{preadv2}; @manpage{preadv2, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev2 (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{pwritev2}; @manpage{pwritev2, Write to a file descriptor using multiple buffers}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_IOVEC_IOV_BASE
Defined to @code{1} if @objtype{struct iovec} has the field @code{iov_base}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_IOVEC_IOV_LEN
Defined to @code{1} if @objtype{struct iovec} has the field @code{iov_len}; otherwise it is defined
to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Structure field accessors


The following accessors are defined only if the corresponding structure field is defined.


@deftypefun void ccsys_set_iovec_iov_base (ccsys_iovect_t const * @var{S}, void * @var{F})
@deftypefunx void * ccsys_ref_iovec_iov_base (ccsys_iovect_t const * @var{S})
Setter and getter for the field @code{iov_base} in the structure referenced by @var{S}.
@end deftypefun


@deftypefun void ccsys_set_iovec_iov_len (ccsys_iovect_t const * @var{S}, size_t @var{F})
@deftypefunx size_t ccsys_ref_iovec_iov_len (ccsys_iovect_t const * @var{S})
Setter and getter for the field @code{iov_len} in the structure referenced by @var{S}.
@end deftypefun

@c page
@node io scatter gather one
@subsection Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}


As example of using @cfunc{ccsys_readv} and @cfunc{ccsys_writev} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_writev(L, fd, vec, buf_count);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_readv(L, fd, vec, buf_count);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather two
@subsection Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}


As example of using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev} see the following code which
opens a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_pwritev(L, fd, vec, buf_count, offset);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_preadv(L, fd, vec, buf_count, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup
@section Duplicating file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_dup (cce_destination_t @var{L}, ccsys_fd_t @var{old})
Wrapper for @cfunc{dup}; @manpage{dup, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_destination_t @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new})
Wrapper for @cfunc{dup2}; @manpage{dup2, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_destination_t @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new}, ccsys_open_flags_t @var{flags})
Wrapper for @cfunc{dup3}; @manpage{dup3, Duplicate a file descriptor}.
@end deftypefun


@menu
* io dup one::                  Using @cfunc{ccsys_dup}.
* io dup two::                  Using @cfunc{ccsys_dup2}.
* io dup three::                Using @cfunc{ccsys_dup3}.
@end menu

@c page
@node io dup one
@subsection Using @cfunc{ccsys_dup}


As example of using @cfunc{ccsys_dup} see the following code which opens a file, duplicates the file
descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
 @} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
   @}

  /* Duplicate the file descriptor. */
  fdx = ccsys_dup(L, fd);

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
   @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
   @}

  cce_run_cleanup_handlers(L);
 @}
@end example

@c page
@node io dup two
@subsection Using @cfunc{ccsys_dup2}


As example of using @cfunc{ccsys_dup2} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    fdx.data = 123;
    fdx = ccsys_dup2(L, fd, fdx);
    assert(123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup three
@subsection Using @cfunc{ccsys_dup3}


As example of using @cfunc{ccsys_dup3} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    ccsys_open_flags_t        flags;

    flags.data        = CCSYS_O_CLOEXEC;
    fdx.data          = 123;
    fdx = ccsys_dup3(L, fd, fdx, flags);
    assert(123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    static size_t const len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io select
@section Waiting for input/output


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_select (cce_destination_t @var{L}, int @var{nfds}, ccsys_fd_set_t * @var{read_fds}, ccsys_fd_set_t * @var{write_fds}, ccsys_fd_set_t * @var{except_fds}, ccsys_timeval_t * @var{timeout})
Wrapper for @cfunc{select}; @manpage{select, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun int ccsys_pselect (cce_destination_t @var{L}, int @var{nfds}, ccsys_fd_set_t * @var{read_fds}, ccsys_fd_set_t * @var{write_fds}, ccsys_fd_set_t * @var{except_fds}, ccsys_timespec_t * @var{timeout}, ccsys_sigset_t const * @var{sigmask})
Wrapper for @cfunc{pselect}; @manpage{pselect, Synchronous input/output multiplexing}.
@end deftypefun


@anchor{ccsys_sigset_t}
@deftp {Struct Typedef} ccsys_sigset_t
Wrapper for @code{sigset_t}.
@end deftp


@deftypefun void ccsys_fd_clr (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_CLR}; @manpage{FD_CLR, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun bool ccsys_fd_isset (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_ISSET}; @manpage{FD_ISSET, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun void ccsys_fd_set (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_SET}; @manpage{FD_SET, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun void ccsys_fd_zero (ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_ZERO}; @manpage{FD_ZERO, Synchronous input/output multiplexing}.
@end deftypefun


@menu
* io select one::               Using @cfunc{ccsys_select}.
* io select two::               Using @cfunc{ccsys_pselect}.
@end menu

@c page
@node io select one
@subsection Using @cfunc{ccsys_select}


As example of using @cfunc{ccsys_select} see the following code which forks a child process and
communicates with it through pipes.

@smallexample
static void doit_parent (cce_destination_t upper_L,
                         ccsys_fd_t infd, ccsys_fd_t oufd);
static void doit_child  (ccsys_fd_t infd, ccsys_fd_t oufd);

void
doit (cce_destination_t upper_L)
@{
  ccsys_fd_t    parent_in_fd, parent_ou_fd;
  ccsys_fd_t     child_in_fd,  child_ou_fd;

  /* Allocate the pipes. */
  @{
    cce_location_t              L[1];
    ccsys_fd_t                  forwards[2];
    ccsys_fd_t                  backwards[2];
    cce_error_handler_t         forwards_H[1];
    cce_error_handler_t         backwards_H[1];

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      ccsys_pipe(L, forwards);
      ccsys_handler_pipedes_init(L, forwards_H, forwards);
      ccsys_pipe(L, backwards);
      ccsys_handler_pipedes_init(L, backwards_H, backwards);
      cce_run_cleanup_handlers(L);
    @}

    /* Here the pipes have been allocated.
       Now split them into their role. */
    parent_in_fd = forwards[0];
    parent_ou_fd = backwards[1];
    child_in_fd  = backwards[0];
    child_ou_fd  = forwards[1];
  @}

  /* Fork the process and call the appropriate functions. */
  @{
    cce_location_t      L[1];
    ccsys_pid_t         pid;

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      pid = ccsys_fork(L);
      if (ccsys_in_parent_after_fork(pid)) @{
        doit_parent(L, parent_in_fd, parent_ou_fd);

        /* Wait for the child process. */
        @{
          ccsys_waitpid_options_t       options;
          ccsys_waitpid_status_t        wstatus;

          options.data = 0;
          ccsys_waitpid(L, pid, &wstatus, options);
        @}
      @} else @{
        doit_child(child_in_fd, child_ou_fd);

        /* Terminate the child process. */
        @{
          ccsys_exit_status_t   status;
          status.data = CCSYS_EXIT_SUCCESS;
          ccsys_exit(status);
        @}
      @}
      cce_run_cleanup_handlers(L);
    @}
  @}
@}

void
doit_parent (cce_destination_t upper_L,
             ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, NULL, &write_fds, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello child";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      nfds                      = ccsys_fd_incr(infd);
      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, &read_fds, NULL, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello parent", N));
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
doit_child (ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      nfds                      = ccsys_fd_incr(infd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, &read_fds, NULL, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello child", N));
    @}

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, NULL, &write_fds, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello parent";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node io select two
@subsection Using @cfunc{ccsys_pselect}


As example of using @cfunc{ccsys_pselect} see the following code which forks a child process and
communicates with it through pipes.

@smallexample
static void doit_parent (cce_destination_t upper_L,
                         ccsys_fd_t infd, ccsys_fd_t oufd);
static void doit_child  (ccsys_fd_t infd, ccsys_fd_t oufd);

void
doit (cce_destination_t upper_L)
@{
  ccsys_fd_t    parent_in_fd, parent_ou_fd;
  ccsys_fd_t     child_in_fd,  child_ou_fd;

  /* Allocate the pipes. */
  @{
    cce_location_t              L[1];
    ccsys_fd_t                  forwards[2];
    ccsys_fd_t                  backwards[2];
    cce_error_handler_t         forwards_H[1];
    cce_error_handler_t         backwards_H[1];

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      ccsys_pipe(L, forwards);
      ccsys_handler_pipedes_init(L, forwards_H, forwards);
      ccsys_pipe(L, backwards);
      ccsys_handler_pipedes_init(L, backwards_H, backwards);
      cce_run_cleanup_handlers(L);
    @}

    /* Here the pipes have been allocated.
       Now split them into their role. */
    parent_in_fd = forwards[0];
    parent_ou_fd = backwards[1];
    child_in_fd  = backwards[0];
    child_ou_fd  = forwards[1];
  @}

  /* Fork the process and call the appropriate functions. */
  @{
    cce_location_t      L[1];
    ccsys_pid_t         pid;

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      pid = ccsys_fork(L);
      if (ccsys_in_parent_after_fork(pid)) @{
        doit_parent(L, parent_in_fd, parent_ou_fd);

        /* Wait for the child process. */
        @{
          ccsys_waitpid_options_t       options;
          ccsys_waitpid_status_t        wstatus;

          options.data = 0;
          ccsys_waitpid(L, pid, &wstatus, options);
        @}
      @} else @{
        doit_child(child_in_fd, child_ou_fd);

        /* Terminate the child process. */
        @{
          ccsys_exit_status_t   status;
          status.data = CCSYS_EXIT_SUCCESS;
          ccsys_exit(status);
        @}
      @}
      cce_run_cleanup_handlers(L);
    @}
  @}
@}

void
doit_parent (cce_destination_t upper_L,
             ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, NULL, &write_fds, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello child";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      nfds                      = ccsys_fd_incr(infd);
      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, &read_fds, NULL, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello parent", N));
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
doit_child (ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      nfds                      = ccsys_fd_incr(infd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, &read_fds, NULL, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello child", N));
    @}

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, NULL, &write_fds, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello parent";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node io sync
@section Committing file system caches to disk


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_sync (void)
Wrapper for @cfunc{sync}; @manpage{sync, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_syncfs (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{syncfs}; @manpage{syncfs, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_fsync (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{fsync}; @manpage{fsync, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_fdatasync (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{fdatasync}; @manpage{fdatasync, Committing file system caches to disk}.
@end deftypefun

@c page
@node io streams
@section Stream input/output


@menu
* io streams opening::          Opening streams.
* io streams closing::          Closing streams.
* io streams rw::               Reading from and writing to streams.
* io streams pos::              Repositioning a stream.
* io streams status::           Stream status.
@end menu

@c page
@node io streams opening
@subsection Opening streams


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Opaque Typedef} ccsys_file_t
A wrapper for @objtype{FILE *}.
@end deftp


@deftypefun ccsys_file_t ccsys_fopen (cce_destination_t @var{L}, char const * @var{pathname}, char const * @var{mode})
Wrapper for @cfunc{fopen}; @manpage{fopen, Stream open functions}.
@end deftypefun


@deftypefun ccsys_file_t ccsys_fdopen (cce_destination_t @var{L}, ccsys_fd_t @var{fd}, char const * @var{mode})
Wrapper for @cfunc{fdopen}; @manpage{fdopen, Stream open functions}.
@end deftypefun


@deftypefun ccsys_file_t ccsys_freopen (cce_destination_t @var{L}, char const * @var{pathname}, char const * @var{mode}, ccsys_file_t @var{stream})
Wrapper for @cfunc{freopen}; @manpage{freopen, Stream open functions}.
@end deftypefun

@c page
@node io streams closing
@subsection Closing streams


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_fclose (cce_destination_t @var{L}, ccsys_file_t @var{stream})
Wrapper for @cfunc{fclose}; @manpage{fclose, Close a stream}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Stream handlers


@deftypefun void ccsys_cleanup_handler_stream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_file_t @var{stream})
@deftypefunx void ccsys_error_handler_stream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_file_t @var{stream})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the stream @var{stream} using the standard function @cfunc{fclose}; errors in @cfunc{fclose}
are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_stream_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_file_t @var{stream})
@deftypefnx {Preprocessor Macro} void ccsys_handler_stream_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_file_t @var{stream})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_stream_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_stream_init}.
@end table
@end deftypefn

@c page
@node io streams rw
@subsection Reading from and writing to streams


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun size_t ccsys_fread (cce_destination_t @var{L}, void * @var{bufptr}, size_t @var{item_size}, size_t @var{item_num}, ccsys_file_t @var{stream})
Wrapper for @cfunc{fread}; @manpage{fread, Binary stream input/output}.
@end deftypefun


@deftypefun size_t ccsys_fwrite (cce_destination_t @var{L}, void * @var{bufptr}, size_t @var{item_size}, size_t @var{item_num}, ccsys_file_t @var{stream})
Wrapper for @cfunc{fwrite}; @manpage{fwrite, Binary stream input/output}.
@end deftypefun

@c page
@node io streams pos
@subsection Repositioning a stream


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Opaque Typedef} ccsys_fpos_t
A wrapper for @objtype{fpos_t}.
@end deftp


@deftypefun void ccsys_fseek (cce_destination_t @var{L}, ccsys_file_t @var{stream}, long @var{offset}, ccsys_whence_t @var{whence})
Wrapper for @cfunc{fseek}; @manpage{fseek, Reposition a stream}.
@end deftypefun


@deftypefun long ccsys_ftell (cce_destination_t @var{L}, ccsys_file_t @var{stream})
Wrapper for @cfunc{ftell}; @manpage{ftell, Reposition a stream}.
@end deftypefun


@deftypefun void ccsys_rewind (cce_destination_t @var{L}, ccsys_file_t @var{stream})
Wrapper for @cfunc{rewind}; @manpage{rewind, Reposition a stream}.
@end deftypefun


@deftypefun void ccsys_fgetpos (cce_destination_t @var{L}, ccsys_file_t @var{stream}, ccsys_fpos_t * @var{pos})
Wrapper for @cfunc{fgetpos}; @manpage{fgetpos, Reposition a stream}.
@end deftypefun


@deftypefun void ccsys_fsetpos (cce_destination_t @var{L}, ccsys_file_t @var{stream}, ccsys_fpos_t const * @var{pos})
Wrapper for @cfunc{fsetpos}; @manpage{fsetpos, Reposition a stream}.
@end deftypefun

@c page
@node io streams status
@subsection Stream status


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_clearerr (ccsys_file_t @var{stream})
Wrapper for @cfunc{clearerr}; @manpage{clearerr, Check and reset stream status}.
@end deftypefun


@deftypefun bool ccsys_feof (ccsys_file_t @var{stream})
Wrapper for @cfunc{feof}; @manpage{feof, Check and reset stream status}.
@end deftypefun


@deftypefun bool ccsys_ferror (ccsys_file_t @var{stream})
Wrapper for @cfunc{ferror}; @manpage{ferror, Check and reset stream status}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_fileno (ccsys_file_t @var{stream})
Wrapper for @cfunc{fileno}; @manpage{fileno, Check and reset stream status}.
@end deftypefun

@c page
@node fs
@chapter File system system calls


@menu
* fs touch::                    Creating files.
* fs dirs working::             The working directory.
* fs dirs reading::             Reading directory entries.
* fs dirs creating::            Creating and deleting directories.
* fs links::                    Operating on links.
* fs removing::                 Removing files.
* fs renaming::                 Renaming files and directories.
* fs stat::                     Reading file attributes.
* fs owner::                    Changing owner.
* fs access perms::             Changing access permissions.
* fs access tests::             Testing access permissions.
* fs trunc::                    Truncating files.
* fs times::                    File times.
* fs temp::                     Temporary files and directories.
@end menu

@c page
@node fs touch
@section Creating files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_touch (cce_destination_t @var{L}, const char * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Create a file by opening it and then closing it; the arguments are the same of @cfunc{ccsys_open};
@ref{io open, ccsys_open}.

Calling this function is equivalent to executing the code:

@example
ccsys_fd_t      fd;

fd = ccsys_open(L, filename, flags, mode);
ccsys_close(L, fd);
@end example
@end deftypefun


As usage example of @cfunc{ccsys_touch} see the following code:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_flags_t    flags;
  ccsys_open_mode_t     mode;

  flags.data = CCSYS_O_CREAT;
  mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  ccsys_touch(L, filename, flags, mode);

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs dirs working
@section The working directory


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_getcwd (cce_destination_t @var{L}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{getcwd}; @manpage{getcwd, Get the current working directory}.

If @var{buffer} is @cnull{}: an exception is raised with type @objtype{cce_condition_errno_t} and
code @code{EINVAL}.
@end deftypefun


@deftypefun void ccsys_custom_getcwd (cce_destination_t @var{L}, char * @var{buffer}, size_t @var{size})
Like @cfunc{ccsys_getcwd}, but:

@itemize
@item
If the function is successful: the return value is @true{}.

@item
If the function fails with @code{ERANGE}: no exception is raised and the return value is @false{}.
@end itemize
@end deftypefun


@deftypefun {char *} ccsys_get_current_dir_name (cce_destination_t @var{L})
Wrapper for @cfunc{get_current_dir_name}; @manpage{get_current_dir_name, Get the current working
directory}.

@quotation
@strong{NOTE} This function is a @gnu{} extension.
@end quotation
@end deftypefun


@deftypefun void ccsys_chdir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{chdir}; @manpage{chdir, Change the current working directory}.
@end deftypefun


@deftypefun void ccsys_fchdir (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fchdir}; @manpage{fchdir, Change the current working directory}.
@end deftypefun


@menu
* fs dirs working one::         Getting the working directory examples.
@end menu

@c page
@node fs dirs working one
@subsection Getting the working directory examples


As usage example for @cfunc{ccsys_getcwd} with a previously allocated stack buffer, see the
following code.

@example
size_t  len = CCSYS_PATH_MAX;
char    buf[len];

ccsys_getcwd(upper_L, buf, len);
@end example

As usage example for @cfunc{ccsys_getcwd} with a dynamically allocated stack buffer, see the
following code.

@example
cce_location_t        L[1];
volatile size_t       len = 1;

if (CCE_EXCEPT == cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  cce_location_t      inner_L[1];

  if (cce_location(inner_L)) @{
    if (cce_condition_is_errno(cce_condition(inner_L))) @{
      CCE_PC(cce_condition_errno_t, C, cce_condition(inner_L));
      if (CCSYS_ERANGE == C->errnum) @{
        len *= 2;
        cce_retry(L);
      @}
    @}
    cce_run_error_handlers_raise(inner_L, L);
  @} else @{
    char      buf[len];

    ccsys_getcwd(inner_L, buf, len);

    /* Do something with "buf" here; usually copy it into
       another buffer. */
    cce_run_cleanup_handlers(inner_L);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

As usage example for @cfunc{ccsys_custom_getcwd} see the following code.

@example
size_t        len = 1;

for (bool done = false; false == done; len *= 2) @{
  char        buf[len];

  /* Do something with "buf" here; usually copy it into
     another buffer. */
  done = ccsys_custom_getcwd(upper_L, buf, len);
@}
@end example

As usage example for @cfunc{ccsys_get_current_dir_name} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char *      buf;

  buf = ccsys_get_current_dir_name(L);
  ccsys_handler_malloc_init(L, H, buf);

  /* Do something with "buf" here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs dirs reading
@section Reading directory entries


@menu
* fs dirs reading types::       Directory stream and entry types.
* fs dirs reading api::         Actually reading directory entries.
* fs dirs reading handler::     Directory stream handler.
* fs dirs reading alternate::   An alternative way to open directories.
@end menu

@c page
@node fs dirs reading types
@subsection Directory stream and entry types


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Opaque Type} ccsys_dir_t
Opaque type for a directory stream; replaces @objtype{DIR}.
@end deftp


@deftp {Struct Typedef} ccsys_dirent_t
Type of directory entries; replaces @objtype{struct dirent}.
@end deftp


@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_DIRENT_D_NAME
Defined to @code{1} if @objtype{struct dirent} has the field @code{d_name}; otherwise it is defined
to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Structure field accessors


The following accessors are defined only if the corresponding structure field is defined.


@deftypefun {char const *} ccsys_ref_dirent_d_name (ccsys_dirent_t * @var{entry})
Return a pointer to the field @code{d_name} of a @objtype{struct dirent}.
@end deftypefun

@c page
@node fs dirs reading api
@subsection Actually reading directory entries


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {ccsys_dir_t *} ccsys_opendir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{opendir}; @manpage{opendir, Open a directory}.
@end deftypefun


@deftypefun {ccsys_dir_t *} ccsys_fdopendir (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fdopendir}; @manpage{fopendir, Open a directory}.
@end deftypefun


@deftypefun {ccsys_dirent_t *} ccsys_readdir (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{readdir}; @manpage{readdir, Read directory entries}.
@end deftypefun


@deftypefun void ccsys_closedir (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{closedir}; @manpage{opendir, Close a directory}.
@end deftypefun


@deftypefun ccsys_dirfd_t ccsys_dirfd (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{dirfd}; @manpage{dirfd, Get a directory stream file descriptor}.
@end deftypefun

@c page
@node fs dirs reading handler
@subsection Directory stream handler


We can read the contents of a directory opening a directory stream with @cfunc{ccsys_opendir} and
closing it with @cfunc{closedir}:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dirstream_H[1];
char const *            pathname = "./";

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_dir_t *         dirstream;
  ccsys_dirent_t *      direntry;

  dirstream = ccsys_opendir(L, pathname);
  ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
  for (direntry = ccsys_readdir(L, dirstream);
       direntry;
       direntry = ccsys_readdir(L, dirstream)) @{
    printf("%s\n", ccsys_ref_dirent_d_name(direntry));
    fflush(stdout);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{closedir}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_dirstream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefunx void ccsys_error_handler_dirstream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
finalise the directory stream using the standard function @cfunc{closedir}; errors in
@cfunc{closedir} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefnx {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_dirstream_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_dirstream_init}.
@end table
@end deftypefn

@c page
@node fs dirs reading alternate
@subsection An alternative way to open directories


We must remember that we can also open a directory with @cfunc{ccsys_open}, and similar functions,
using the @code{CCSYS_O_PATH} flag as follows:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        dirname = "name.d";
  ccsys_open_flags_t  flags;
  ccsys_open_mode_t   mode;
  ccsys_fd_t          fd;
  ccsys_dirfd_t       dirfd;

  flags.data = CCSYS_O_PATH;
  mode.data  = CCSYS_S_IRWXU;
  fd         = ccsys_open(L, dirname, flags, mode);
  dirfd      = ccsys_dirfd_from_fd(fd);

  /* Do something with "dirfd". */

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs dirs creating
@section Creating and deleting directories


@menu
* io dirs creating api::        Actually creating directories.
* io dirs creating handlers::   Handler for directories removal
* io dirs creating one::        Using @cfunc{ccsys_mkdirat}.
@end menu

@c page
@node io dirs creating api
@subsection Actually creating directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkdir (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkdir}; @manpage{mkdir, Create a directory}.
@end deftypefun


@deftypefun void ccsys_mkdirat (cce_destination_t @var{L}, ccsys_fd_t @var{fd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkdirat}; @manpage{mkdirat, Create a directory}.
@end deftypefun


@deftypefun void ccsys_rmdir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{rmdir}; @manpage{rmdir, Delete a directory}.
@end deftypefun

@c page
@node io dirs creating handlers
@subsection Handler for directories removal


We can remove @strong{empty} temporary directories with the standard function @cfunc{rmdir} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dirname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_mode_t     mode;

  mode.data = CCSYS_S_IRWXU;
  ccsys_mkdir(L, "name.d", mode);
  ccsys_handler_rmdir_init(L, dirname_H, "name.d");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{rmdir}, which is generally bad; we
can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the function @cfunc{mkdtemp}
implemented by the @gnu{} C Library.


@deftypefun void ccsys_cleanup_handler_rmdir_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_rmdir_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the directory whose pathname is @var{pathname} using the standard function @cfunc{rmdir};
errors in @cfunc{rmdir} are @strong{ignored}.  The directory is removed only if it is empty.

The string referenced by @var{pathname} must be an @asciiz{} representation of the directory
pathname; it is @strong{not} duplicated by this function and it must exist for the whole extent of
the usage of @var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_rmdir_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_rmdir_init}.
@end table
@end deftypefn

@c page
@node io dirs creating one
@subsection Using @cfunc{ccsys_mkdirat}


As usage example of @cfunc{ccsys_mkdirat}, see the following code.

@smallexample
cce_location_t        L[1];
cce_handler_t         dirname1_H[1];
cce_handler_t         dirstream1_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * dirname1 = "name.d";
  static char const * dirname2 = "subname.d";
  ccsys_dirfd_t       dirfd1;

  /* Create the parent directory. */
  @{
    ccsys_open_mode_t mode;
    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdir(L, dirname1, mode);
    ccsys_cleanup_handler_rmdir_init(L, dirname1_H, dirname1);
  @}

  /* Open the parent directory.  The descriptor in "dirfd1"
     is released automatically when "dirstream" is released. */
  @{
    ccsys_dir_t *     dir;

    dir = ccsys_opendir(L, dirname1);
    ccsys_cleanup_handler_dirstream_init(L, dir_H, dir);
    dirfd1 = ccsys_dirfd(L, dir);
  @}

  /* Create the subdirectory. */
  @{
    ccsys_open_mode_t mode;
    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdirat(L, dirfd1, dirname2, mode);
  @}

  /* Remove the subdirectory. */
  @{
    ccsys_unlinkat_flags_t      flags;
    flags.data = CCSYS_AT_REMOVEDIR;
    ccsys_unlinkat(L, dirfd1, dirname2, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links
@section Operating on links


@menu
* fs links creating::           Creating links and symbolic links.
* fs links reading::            Reading links and symbolic links.
* fs links removing::           Removing links.
@end menu

@c page
@node fs links creating
@subsection Creating links and symbolic links


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_link (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{link}.
@end deftypefun


@deftypefun void ccsys_linkat (cce_destination_t @var{L}, ccsys_dirfd_t @var{old_dirfd}, char const * @var{oldname}, ccsys_dirfd_t @var{new_dirfd}, char const * @var{newname}, ccsys_linkat_flags_t @var{flags})
Wrapper for @cfunc{linkat}.
@end deftypefun


@deftypefun void ccsys_symlink (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{symlink}.
@end deftypefun


@deftypefun void ccsys_symlinkat (cce_destination_t @var{L}, char const * @var{oldname}, ccsys_dirfd_t @var{newdirfd}, char const * @var{newname})
Wrapper for @cfunc{symlinkat}.
@end deftypefun

@menu
* fs links creating one::       Using @cfunc{ccsys_linkat}.
* fs links creating two::       Using @cfunc{ccsys_symlinkat}.
@end menu

@c page
@node fs links creating one
@subsubsection Using @cfunc{ccsys_linkat}


As usage example of @cfunc{ccsys_linkat} see the following code:

@smallexample
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t linkname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        linkname = "link.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, CCSYS_AT_FDCWD, filename, flags, mode);
    ccsys_close(L, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Create the link. */
  @{
    ccsys_linkat_flags_t      flags;

    flags.data = 0;
    ccsys_linkat(L, CCSYS_AT_FDCWD, filename, CCSYS_AT_FDCWD, linkname, flags);
    ccsys_handler_remove_init(L, linkname_H, linkname);
  @}

  /* Verify the link existence. */
  @{
    ccsys_stat_t      S[1];

    ccsys_stat(L, linkname, S);
    assert(ccsys_s_isreg(ccsys_ref_stat_st_mode(S)));
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links creating two
@subsubsection Using @cfunc{ccsys_symlinkat}


As usage example of @cfunc{ccsys_symlinkat} see the following code:

@smallexample
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t linkname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        linkname = "link.ext";

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, CCSYS_AT_FDCWD, filename, flags, mode);
    ccsys_close(L, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Create the link. */
  @{
    ccsys_symlinkat(L, filename, CCSYS_AT_FDCWD, linkname);
    ccsys_handler_remove_init(L, linkname_H, linkname);
  @}

  /* Verify the link existence. */
  @{
    ccsys_stat_t      S[1];

    ccsys_lstat(L, linkname, S);
    assert(ccsys_s_islnk(ccsys_ref_stat_st_mode(S)));
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links reading
@subsection Reading links and symbolic links


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun size_t ccsys_readlink (cce_destination_t @var{L}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlink}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun size_t ccsys_readlinkat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlinkat}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun {char *} ccsys_realpath (cce_destination_t @var{L}, char const * @var{pathname}, char * @var{resolved_path})
Wrapper for @cfunc{realpath}.  Notice that this function never returns @cnull{}.
@end deftypefun

@menu
* fs links reading one::        Using @cfunc{ccsys_readlink}.
* fs links reading two::        Using @cfunc{ccsys_readlinkat}.
* fs links reading three::      Using @cfunc{ccsys_realpath}.
@end menu

@c page
@node fs links reading one
@subsubsection Using @cfunc{ccsys_readlink}


As usage example of @cfunc{ccsys_readlink} see the following code.

@smallexample
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t linkname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        linkname = "link.ext";

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_close(L, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Create the link. */
  @{
    ccsys_symlink(L, filename, linkname);
    ccsys_handler_remove_init(L, linkname_H, linkname);
  @}

  /* Read the link. */
  @{
    size_t    len = 1 + CCSYS_PATH_MAX;
    char      realname[len];

    len = ccsys_readlink(L, linkname, realname, len);
    realname[len] = '\0';
    /* Do something with "realname". */
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links reading two
@subsubsection Using @cfunc{ccsys_readlinkat}


As usage example of @cfunc{ccsys_readlinkat} see the following code.

@smallexample
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t linkname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        linkname = "link.ext";

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_close(L, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Create the link. */
  @{
    ccsys_symlink(L, filename, linkname);
    ccsys_handler_remove_init(L, linkname_H, linkname);
  @}

  /* Read the link. */
  @{
    size_t    len = 1 + CCSYS_PATH_MAX;
    char      realname[len];

    len = ccsys_readlinkat(L, CCSYS_AT_FDCWD, linkname, realname, len);
    realname[len] = '\0';
    /* Do something with "realname". */
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links reading three
@subsubsection Using @cfunc{ccsys_realpath}


As usage example of @cfunc{ccsys_realpath} see the following code.

@smallexample
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_close(L, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Read the pathname. */
  @{
    size_t    len = 1 + CCSYS_PATH_MAX;
    char      realname[len];

    ccsys_realpath(L, filename, realname);
    /* Do something with "realname". */
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links removing
@subsection Removing links


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_unlink (cce_destination_t @var{L}, char const * @var{filename})
Wrapper for @cfunc{unlink}; @manpage{unlink, Delete a name and possibly the file it refers to}.
@end deftypefun


@deftypefun void ccsys_unlinkat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, ccsys_unlinkat_flags_t @var{flags})
Wrapper for @cfunc{unlinkat}; @manpage{unlinkat, Delete a name and possibly the file it refers to}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for at--links removal


We can remove temporary files with the standard function @cfunc{unlinkat} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   filename_H[1];
ccsys_at_link_t         lnk;

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_dirfd_t dirfd    = CCSYS_AT_FDCWD;
  char const *  filename = "name.ext";
  ccsys_fd_t    fd;

  @{
    ccsys_open_flags_t    flags;
    ccsys_open_mode_t     mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd         = ccsys_open(L, dirfd, "name.ext", flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
  @}

  @{
    lnk.dirfd      = dirfd;
    lnk.pathname   = filename;
    lnk.flags.data = 0;
    ccsys_handler_unlinkat_init(L, filename_H, &lnk);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{unlinkat}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.

The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_at_link_t
Type of structure used to hold data for an @cfunc{unlinkat} call.  It has the following public
fields:

@table @code
@item ccsys_dirfd_t dirfd
The file descriptor of the directory to which the pathname is relative.

@item char const * pathname
The pathname to unlink.  It must be an @asciiz{} representation of the pathname; it is @strong{not}
duplicated by this handler and it must exist for the whole usage extent of the handler.

@item ccsys_unlinkat_flags_t flags
Flags for the unlinking operation.  We can use these, for example, to unlink a directory rather than
a file.
@end table
@end deftp


@deftypefun void ccsys_cleanup_handler_unlinkat_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_at_link_t * @var{lnk})
@deftypefunx void ccsys_error_handler_unlinkat_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_at_link_t * @var{lnk})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
unlink at the file whose pathname is @code{@var{lnk}->@var{pathname}} using the standard function
@cfunc{unlinkat}; errors in @cfunc{unlinkat} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_unlinkat_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_at_link_t * @var{lnk})
@deftypefnx {Preprocessor Macro} void ccsys_handler_unlinkat_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_at_link_t * @var{lnk})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_unlinkat_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_unlinkat_init}.
@end table
@end deftypefn

@c page
@node fs removing
@section Removing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_remove (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{remove}; @manpage{remove, Remove a file or directory}.  This function removes
both files and empty directories.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for files removal


We can remove temporary files with the standard function @cfunc{remove} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   fd_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_flags_t    flags;
  ccsys_open_mode_t     mode;
  ccsys_fd_t            fd;

  flags.data    = CCSYS_O_CREAT;
  mode.data     = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd            = ccsys_open(L, "name.ext", flags, mode);
  ccsys_cleanup_handler_filedes_init(L, fd_H, fd);
  ccsys_cleanup_handler_remove_init(L, file_H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{remove}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the @posix{} standard function
@cfunc{mkstemp}.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_remove_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_remove_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the file whose pathname is @var{pathname} using the standard function @cfunc{remove}; errors
in @cfunc{remove} are @strong{ignored}.

The string referenced by @var{pathname} must be an @asciiz{} representation of the file pathname; it
is @strong{not} duplicated by this function and it must exist for the whole extent of the usage of
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_remove_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_remove_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_remove_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_remove_init}.
@end table
@end deftypefn

@c page
@node fs renaming
@section Renaming files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_rename (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{rename}; @manpage{rename, Change the name or location of a file}.
@end deftypefun


@deftypefun void ccsys_renameat (cce_destination_t @var{L}, ccsys_dirfd_t @var{old_dirfd}, char const * @var{oldname}, ccsys_dirfd_t @var{new_dirfd}, char const * @var{newname})
Wrapper for @cfunc{renameat}; @manpage{renameat, Change the name or location of a file}.
@end deftypefun


@deftypefun void ccsys_renameat2 (cce_destination_t @var{L}, ccsys_dirfd_t @var{old_dirfd}, char const * @var{oldname}, ccsys_dirfd_t @var{new_dirfd}, char const * @var{newname}, ccsys_renameat2_flags_t @var{flags})
Wrapper for @cfunc{renameat2}; @manpage{renameat2, Change the name or location of a file}.

@quotation
@strong{NOTE} This function is available only on Linux platforms.
@end quotation
@end deftypefun

@menu
* fs renaming one::             Using @cfunc{ccsys_rename}.
* fs renaming two::             Using @cfunc{ccsys_renameat}.
* fs renaming three::           Using @cfunc{ccsys_renameat2}.
@end menu

@c page
@node fs renaming one
@subsection Using @cfunc{ccsys_rename}


As usage example of @cfunc{ccsys_rename} see the following code.

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        newname  = "blue.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Rename the pathname. */
  @{
    ccsys_rename(L, filename, newname);
    assert(false == ccsys_pathname_isreg(L, filename));
    assert(true  == ccsys_pathname_isreg(L, newname));
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs renaming two
@subsection Using @cfunc{ccsys_renameat}


As usage example of @cfunc{ccsys_renameat} see the following code.

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        newname  = "blue.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Rename the pathname. */
  @{
    ccsys_renameat(L, CCSYS_AT_FDCWD, filename,
                      CCSYS_AT_FDCWD, newname);
    assert(false == ccsys_pathname_isreg(L, filename));
    assert(true  == ccsys_pathname_isreg(L, newname));
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs renaming three
@subsection Using @cfunc{ccsys_renameat2}


As usage example of @cfunc{ccsys_renameat2} see the following code.

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *        filename = "name.ext";
  char const *        newname  = "blue.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Rename the pathname. */
  @{
    ccsys_renameat2_flags_t   flags;

    flags.data = 0;
    ccsys_renameat2(L,
                    CCSYS_AT_FDCWD, filename,
                    CCSYS_AT_FDCWD, newname,
                    flags);
    assert(false == ccsys_pathname_isreg(L, filename));
    assert(true  == ccsys_pathname_isreg(L, newname));
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs stat
@section Reading file attributes


@menu
* fs stat funcs::               File attributes functions.
* fs stat macros::              Feature macros.
* fs stat setget::              Setters and getters for @objtype{ccsys_stat_t}.
* fs stat mode::                Inspecting the file mode.
* fs stat exists::              Pathname existence and type.
* fs stat one::                 Using @cfunc{ccsys_stat}.
* fs stat two::                 Using @cfunc{ccsys_fstatat}.
@end menu

@c page
@node fs stat funcs
@subsection File attributes functions


For all the functions: notice the return value of type @objtype{bool}:

@itemize
@item
If the system functions @cfunc{stat} and similar return @samp{0}: the return value of the wrapper
function is @true{}.  It means that the file system item exists.

@item
If the system functions @cfunc{stat} and similar return @samp{-1} and @code{errno} is set to
@code{ENOENT} or @code{ENOTDIR}: the return value of the wrapper function is @false{}.  It means
that the file system item does not exists.

@item
Otherwise the wrapper function raises an exception.
@end itemize

The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_stat_t
Wrapper type for @objtype{struct stat}.
@end deftp


@deftypefun bool ccsys_stat (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{stat}; @manpage{stat, Get file status}.
@end deftypefun


@deftypefun bool ccsys_fstat (cce_destination_t @var{L}, ccsys_fd_t @var{fd}, ccsys_stat_t * @var{S})
@deftypefunx bool ccsys_fstat (cce_destination_t @var{L}, ccsys_dirfd_t @var{fd}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{fstat}; @manpage{fstat, Get file status}.
@end deftypefun


@deftypefun bool ccsys_fstatat (cce_destination_t @var{L}, ccsys_dirfd_t @var{fd}, char const * @var{pathname}, ccsys_stat_t * @var{S}, ccsys_fstatat_flags_t @var{flags})
Wrapper for @cfunc{fstatat}; @manpage{fstatat, Get file status}.
@end deftypefun


@deftypefun bool ccsys_lstat (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{lstat}; @manpage{lstat, Get file status}.
@end deftypefun

@c page
@node fs stat macros
@subsection Feature macros


The following symbols are defined in the header file @file{ccsys.h}.


@defmac CCSYS_HAVE_STRUCT_STAT_ST_DEV
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_dev}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_INO
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ino}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MODE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mode}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_NLINK
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_nlink}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_UID
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_uid}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_GID
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_gida}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_RDEV
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_rdev}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_SIZE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_size}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_BLKSIZE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_blksize}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_BLOCKS
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_blocks}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_ATIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_atime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MTIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mtime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_CTIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ctime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_ATIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_atime_usec}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MTIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mtime_usec}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_CTIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ctime_usec}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_ATIM
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_atim}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MTIM
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mtim}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_CTIM
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ctim}; otherwise it is defined
to @code{0}.
@end defmac

@c page
@node fs stat setget
@subsection Setters and getters for @objtype{ccsys_stat_t}


The following field accessors are defined only if @objtype{struct stat} has the associated field;
otherwise they are not implemented.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_dev_t ccsys_ref_stat_st_dev (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_dev (ccsys_stat_t * @var{S}, ccsys_dev_t @var{F})
Getter and setter for the field @code{st_dev}.
@end deftypefun


@deftypefun ccsys_ino_t ccsys_ref_stat_st_ino (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_ino (ccsys_stat_t * @var{S}, ccsys_ino_t @var{F})
Getter and setter for the field @code{st_ino}.
@end deftypefun


@deftypefun ccsys_stat_mode_t ccsys_ref_stat_st_mode (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_mode (ccsys_stat_t * @var{S}, ccsys_stat_mode_t @var{F})
Getter and setter for the field @code{st_mode}.
@end deftypefun


@deftypefun ccsys_nlink_t ccsys_ref_stat_st_nlink (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_nlink (ccsys_stat_t * @var{S}, ccsys_nlink_t @var{F})
Getter and setter for the field @code{st_nlink}.
@end deftypefun


@deftypefun ccsys_uid_t ccsys_ref_stat_st_uid (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_uid (ccsys_stat_t * @var{S}, ccsys_uid_t @var{F})
Getter and setter for the field @code{st_uid}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_ref_stat_st_gid (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_gid (ccsys_stat_t * @var{S}, ccsys_gid_t @var{F})
Getter and setter for the field @code{st_gid}.
@end deftypefun


@deftypefun ccsys_dev_t ccsys_ref_stat_st_rdev (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_rdev (ccsys_stat_t * @var{S}, ccsys_dev_t @var{F})
Getter and setter for the field @code{st_rdev}.
@end deftypefun


@deftypefun ccsys_off_t ccsys_ref_stat_st_size (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_size (ccsys_stat_t * @var{S}, ccsys_off_t @var{F})
Getter and setter for the field @code{st_size}.
@end deftypefun


@deftypefun ccsys_blksize_t ccsys_ref_stat_st_blksize (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_blksize (ccsys_stat_t * @var{S}, ccsys_blksize_t @var{F})
Getter and setter for the field @code{st_blksize}.
@end deftypefun


@deftypefun ccsys_blkcnt_t ccsys_ref_stat_st_blocks (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_blocks (ccsys_stat_t * @var{S}, ccsys_blkcnt_t @var{F})
Getter and setter for the field @code{st_blocks}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_atime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_atime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_atime} and @code{st_atime_usec}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_mtime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_mtime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_mtime} and @code{st_mtime_usec}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_ctime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_ctime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_ctime} and @code{st_ctime_usec}.
@end deftypefun


@deftypefun ccsys_timespec_t ccsys_ref_stat_st_atim (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_atim (ccsys_stat_t * @var{S}, ccsys_timespec_t @var{F})
Getter and setter for the field @code{st_atim}.
@end deftypefun


@deftypefun ccsys_timespec_t ccsys_ref_stat_st_mtim (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_mtim (ccsys_stat_t * @var{S}, ccsys_timespec_t @var{F})
Getter and setter for the field @code{st_mtim}.
@end deftypefun


@deftypefun ccsys_timespec_t ccsys_ref_stat_st_ctim (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_ctim (ccsys_stat_t * @var{S}, ccsys_timespec_t @var{F})
Getter and setter for the field @code{st_ctim}.
@end deftypefun

@c page
@node fs stat mode
@subsection Inspecting the file mode


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun bool ccsys_s_isreg (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a regular file.
@end deftypefun


@deftypefun bool ccsys_s_isdir (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a directory.
@end deftypefun


@deftypefun bool ccsys_s_ischr (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a character device.
@end deftypefun


@deftypefun bool ccsys_s_isblk (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a block device.
@end deftypefun


@deftypefun bool ccsys_s_isfifo (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a @fifo{}.
@end deftypefun


@deftypefun bool ccsys_s_islnk (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a symbolic link.
@end deftypefun


@deftypefun bool ccsys_s_issock (ccsys_stat_mode_t @var{F})
Return @true{} if @var{F} describes a socket.
@end deftypefun

@c page
@node fs stat exists
@subsection Pathname existence and type


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun bool ccsys_pathname_exists (cce_destination_t @var{L}, char const * @var{pathname})
Return @true{} if @var{pathname} exists; otherwise return @false{}.
@end deftypefun


@deftypefun bool ccsys_pathname_isreg (cce_destination_t @var{L}, char const * @var{pathname})
Return @true{} if @var{pathname} exists and it represents a regular file; otherwise return @false{}.
@end deftypefun


@deftypefun bool ccsys_pathname_isdir (cce_destination_t @var{L}, char const * @var{pathname})
Return @true{} if @var{pathname} exists and it represents a directory; otherwise return @false{}.
@end deftypefun


@deftypefun bool ccsys_pathname_uid_gid (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_uid_t * @var{uidp}, ccsys_gid_t * @var{gidp})
Return @true{} if @var{pathname} exists; otherwise return @false{}.  If the pathname exists: the
variable referenced by @var{uidp} is set to the @uid{} of the pathname; the variable referenced by
@var{gidp} is set to the @gid{} of the pathname.
@end deftypefun

@c page
@node fs stat one
@subsection Using @cfunc{ccsys_stat}


As usage example of @cfunc{ccsys_stat} see the following code.

@smallexample
cce_location_t          L[1];
cce_cleanup_handler_t   filename_H[1];
cce_cleanup_handler_t   filedes_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    ccsys_fd_t                fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Inspect the file by pathname. */
  @{
    ccsys_stat_t      S;

    ccsys_stat(L, filename, &S);
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_DEV)
    printf("st_dev=%lu\n", ccsys_lref(ccsys_ref_stat_st_dev(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_INO)
    printf("st_ino=%lu\n", ccsys_lref(ccsys_ref_stat_st_ino(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_MODE)
    printf("st_mode=%lu\n", ccsys_lref(ccsys_ref_stat_st_mode(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_NLINK)
    printf("st_nlink=%lu\n", ccsys_lref(ccsys_ref_stat_st_nlink(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_UID)
    printf("st_uid=%lu\n", ccsys_lref(ccsys_ref_stat_st_uid(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_GID)
    printf("st_gid=%lu\n", ccsys_lref(ccsys_ref_stat_st_gid(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_RDEV)
    printf("st_rdev=%lu\n", ccsys_lref(ccsys_ref_stat_st_rdev(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_SIZE)
    printf("st_size=%lu\n", ccsys_lref(ccsys_ref_stat_st_size(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_BLKSIZE)
    printf("st_blksize=%lu\n", ccsys_lref(ccsys_ref_stat_st_blksize(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_BLOCKS)
    printf("st_blocks=%lu\n", ccsys_lref(ccsys_ref_stat_st_blocks(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_ATIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_atime(&S);
      printf("st_atime=%ld\n", T.seconds.data);
      printf("st_atime_usec=%ld\n", T.microseconds.data);
    @}
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_MTIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_mtime(&S);
      printf("st_mtime=%ld\n", T.seconds.data);
      printf("st_mtime_usec=%ld\n", T.microseconds.data);
    @}
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_CTIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_ctime(&S);
      printf("st_ctime=%ld\n", T.seconds.data);
      printf("st_ctime_usec=%ld\n", T.microseconds.data);
    @}
#endif
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs stat two
@subsection Using @cfunc{ccsys_fstatat}


As usage example of @cfunc{ccsys_fstatat} see the following code.

@smallexample
cce_location_t        L[1];
cce_handler_t         dirname_H[1];
cce_handler_t         dir_H[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t filedes_H[1];
ccsys_at_link_t       lnk;

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * dirname= "name.d";
  ccsys_dirfd_t       dirfd;
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create the parent directory. */
  @{
    ccsys_open_mode_t mode  = @{ .data = CCSYS_S_IRWXU @};
    ccsys_mkdir(L, dirname, mode);
    ccsys_cleanup_handler_rmdir_init(L, dirname_H, dirname);
  @}

  /* Open the parent directory. */
  @{
    ccsys_dir_t *     dir;

    dir = ccsys_opendir(L, dirname);
    ccsys_cleanup_handler_dirstream_init(L, dir_H, dir);
    dirfd = ccsys_dirfd(L, dir);
  @}

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, dirfd, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    lnk.dirfd         = dirfd;
    lnk.pathname      = filename;
    ccsys_handler_unlinkat_init(L, filename_H, &lnk);
  @}

  /* Inspect the file by pathname. */
  @{
    ccsys_stat_t              S;
    ccsys_fstatat_flags_t     flags;

    flags.data = 0;
    ccsys_fstatat(L, dirfd, filename, &S, flags);

#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_DEV)
    printf("st_dev=%lu\n", ccsys_lref(ccsys_ref_stat_st_dev(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_INO)
    printf("st_ino=%lu\n", ccsys_lref(ccsys_ref_stat_st_ino(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_MODE)
    printf("st_mode=%lu\n", ccsys_lref(ccsys_ref_stat_st_mode(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_NLINK)
    printf("st_nlink=%lu\n", ccsys_lref(ccsys_ref_stat_st_nlink(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_UID)
    printf("st_uid=%lu\n", ccsys_lref(ccsys_ref_stat_st_uid(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_GID)
    printf("st_gid=%lu\n", ccsys_lref(ccsys_ref_stat_st_gid(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_RDEV)
    printf("st_rdev=%lu\n", ccsys_lref(ccsys_ref_stat_st_rdev(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_SIZE)
    printf("st_size=%lu\n", ccsys_lref(ccsys_ref_stat_st_size(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_BLKSIZE)
    printf("st_blksize=%lu\n", ccsys_lref(ccsys_ref_stat_st_blksize(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_BLOCKS)
    printf("st_blocks=%lu\n", ccsys_lref(ccsys_ref_stat_st_blocks(&S)));
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_ATIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_atime(&S);
      printf("st_atime=%ld\n", T.seconds.data);
      printf("st_atime_usec=%ld\n", T.microseconds.data);
      @}
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_MTIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_mtime(&S);
      printf("st_mtime=%ld\n", T.seconds.data);
      printf("st_mtime_usec=%ld\n", T.microseconds.data);
    @}
#endif
#if (1 == CCSYS_HAVE_STRUCT_STAT_ST_CTIME)
    @{
      ccsys_timeval_t T = ccsys_ref_stat_st_ctime(&S);
      printf("st_ctime=%ld\n", T.seconds.data);
      printf("st_ctime_usec=%ld\n", T.microseconds.data);
    @}
#endif
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs owner
@section Changing owner


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chown (cce_destination_t @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{chown}; @manpage{chown, Change ownership of a file}.
@end deftypefun


@deftypefun void ccsys_fchown (cce_destination_t @var{L}, int @var{filedes}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{fchown}; @manpage{chown, Change ownership of a file}.
@end deftypefun


@deftypefun void ccsys_lchown (cce_destination_t @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{lchown}; @manpage{chown, Change ownership of a file}.
@end deftypefun


@deftypefun void ccsys_fchownat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group}, ccsys_fchownat_flags_t @var{flags})
Wrapper for @cfunc{fchownat}; @manpage{chown, Change ownership of a file}.
@end deftypefun


@menu
* fs owner one::                Using @cfunc{ccsys_chown}.
* fs owner two::                Using @cfunc{ccsys_fchown}.
* fs owner three::              Using @cfunc{ccsys_lchown}.
* fs owner four::               Using @cfunc{ccsys_fchownat}.
@end menu

@c page
@node fs owner one
@subsection Using @cfunc{ccsys_chown}


As usage example for @cfunc{ccsys_chown} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Change ownership. */
  @{
    ccsys_uid_t       uid = ccsys_getuid();
    ccsys_gid_t       gid = ccsys_getgid();

    ccsys_chown(L, filename, uid, gid);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs owner two
@subsection Using @cfunc{ccsys_fchown}


As usage example for @cfunc{ccsys_fchown} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filedes_H[1];

if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
  @}

  /* Change ownership. */
  @{
    ccsys_uid_t       uid = ccsys_getuid();
    ccsys_gid_t       gid = ccsys_getgid();

    ccsys_fchown(L, fd, uid, gid);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs owner three
@subsection Using @cfunc{ccsys_lchown}


As usage example for @cfunc{ccsys_lchown} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";
  char const *        linkname = "link.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Create the link. */
  @{
    ccsys_symlink(L, filename, linkname);
  @}

  /* Change ownership. */
  @{
    ccsys_uid_t       uid = ccsys_getuid();
    ccsys_gid_t       gid = ccsys_getgid();

    ccsys_lchown(L, linkname, uid, gid);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs owner four
@subsection Using @cfunc{ccsys_fchownat}


As usage example for @cfunc{ccsys_fchownat} see the following code.

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_touch(L, filename, flags, mode);
  @}

  /* Change ownership. */
  @{
    ccsys_uid_t               uid = ccsys_getuid();
    ccsys_gid_t               gid = ccsys_getgid();
    ccsys_fchownat_flags_t    flags;

    flags.data = 0;
    ccsys_fchownat(L, CCSYS_AT_FDCWD, filename, uid, gid, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs access perms
@section Changing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chmod (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{chmod}; @manpage{chmod, Change permissions of a file}.
@end deftypefun


@deftypefun void ccsys_fchmod (cce_destination_t @var{L}, int @var{filedes}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{fchmod}; @manpage{fchmod, Change permissions of a file}.
@end deftypefun


@deftypefun void ccsys_fchmodat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode}, ccsys_fchmodat_flags_t @var{flags})
Wrapper for @cfunc{fchmodat}; @manpage{fchmodat, Change permissions of a file}.
@end deftypefun

@menu
* fs access perms one::         Using @cfunc{ccsys_chmod}.
* fs access perms two::         Using @cfunc{ccsys_fchmod}.
* fs access perms three::       Using @cfunc{ccsys_fchmodat}.
@end menu

@c page
@node fs access perms one
@subsection Using @cfunc{ccsys_chmod}


As usage example of @cfunc{ccsys_chmod} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_open_flags_t        flags;

    flags.data = CCSYS_O_CREAT;
    mode.data  = 0;
    ccsys_touch(L, filename, flags, mode);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Change mode. */
  @{
    ccsys_open_mode_t         mode;

    mode.data  = CCSYS_S_IRWXU;
    ccsys_chmod(L, filename, mode);
  @}

  /* Validate mode. */
  @{
    ccsys_stat_t      S;
    ccsys_stat_mode_t mode;

    assert(true == ccsys_stat(L, filename, &S));
    mode = ccsys_ref_stat_st_mode(&S);
    assert(CCSYS_S_IRWXU == (CCSYS_S_IRWXU & mode.data));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs access perms two
@subsection Using @cfunc{ccsys_fchmod}


As usage example of @cfunc{ccsys_fchmod} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];
cce_cleanup_handler_t filedes_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create the file. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_open_flags_t        flags;

    flags.data = CCSYS_O_CREAT;
    mode.data  = 0;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Change mode. */
  @{
    ccsys_open_mode_t         mode;

    mode.data  = CCSYS_S_IRWXU;
    ccsys_fchmod(L, fd, mode);
  @}

  /* Validate mode. */
  @{
    ccsys_stat_t      S;
    ccsys_stat_mode_t mode;

    assert(true == ccsys_stat(L, filename, &S));
    mode = ccsys_ref_stat_st_mode(&S);
    assert(CCSYS_S_IRWXU == (CCSYS_S_IRWXU & mode.data));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs access perms three
@subsection Using @cfunc{ccsys_fchmodat}


As usage example of @cfunc{ccsys_fchmodat} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];

if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_open_flags_t        flags;

    flags.data = CCSYS_O_CREAT;
    mode.data  = 0;
    ccsys_touch(L, filename, flags, mode);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Change mode. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_fchmodat_flags_t    flags;

    mode.data  = CCSYS_S_IRWXU;
    flags.data = 0;
    ccsys_fchmodat(L, CCSYS_AT_FDCWD, filename, mode, flags);
  @}

  /* Validate mode. */
  @{
    ccsys_stat_t      S;
    ccsys_stat_mode_t mode;

    assert(true == ccsys_stat(L, filename, &S));
    mode = ccsys_ref_stat_st_mode(&S);
    assert(CCSYS_S_IRWXU == (CCSYS_S_IRWXU & mode.data));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs access tests
@section Testing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun bool ccsys_access (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_access_mode_t @var{how})
Wrapper for @cfunc{access}; @manpage{access, Check user's permissions for a file}.  If access is
granted: return @true{}; otherwise return @false{}.
@end deftypefun


@deftypefun bool ccsys_faccessat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_access_mode_t @var{how}, ccsys_faccessat_flags_t @var{flags})
Wrapper for @cfunc{faccessat}; @manpage{faccessat, Check user's permissions for a file}.  If access
is granted: return @true{}; otherwise return @false{}.
@end deftypefun

@menu
* fs access tests one::         Using @cfunc{ccsys_access}.
* fs access tests two::         Using @cfunc{ccsys_faccessat}.
@end menu

@c page
@node fs access tests one
@subsection Using @cfunc{ccsys_access}


As usage example of @cfunc{ccsys_access} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_open_flags_t        flags;

    flags.data = CCSYS_O_CREAT;
    mode.data  = 0;
    ccsys_touch(L, filename, flags, mode);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Testing permissions. */
  @{
    ccsys_access_mode_t       mode;

    mode.data = CCSYS_R_OK;
    assert(false == ccsys_access(L, filename, mode));
  @}

  /* Change mode. */
  @{
    ccsys_open_mode_t         mode;

    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_chmod(L, filename, mode);
  @}

  /* Testing read/write permissions. */
  @{
    ccsys_access_mode_t       mode;

    mode.data = CCSYS_R_OK & CCSYS_W_OK;
    assert(true == ccsys_access(L, filename, mode));
  @}

  /* Testing execute permissions. */
  @{
    ccsys_access_mode_t       mode;

    mode.data = CCSYS_X_OK;
    assert(false == ccsys_access(L, filename, mode));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs access tests two
@subsection Using @cfunc{ccsys_faccessat}


As usage example of @cfunc{ccsys_faccessat} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t filename_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *        filename = "name.ext";

  /* Create the file. */
  @{
    ccsys_open_mode_t         mode;
    ccsys_open_flags_t        flags;

    flags.data = CCSYS_O_CREAT;
    mode.data  = 0;
    ccsys_touch(L, filename, flags, mode);
    ccsys_handler_remove_init(L, filename_H, filename);
  @}

  /* Testing permissions. */
  @{
    ccsys_access_mode_t       mode  = @{ .data = CCSYS_R_OK @};
    ccsys_faccessat_flags_t   flags = @{ .data = 0 @};

    assert(false ==
      ccsys_faccessat(L, CCSYS_AT_FDCWD, filename, mode, flags));
  @}

  /* Change mode. */
  @{
    ccsys_open_mode_t         mode;

    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    ccsys_chmod(L, filename, mode);
  @}

  /* Testing read/write permissions. */
  @{
    ccsys_access_mode_t       mode;
    ccsys_faccessat_flags_t   flags = @{ .data = 0 @};

    mode.data = CCSYS_R_OK & CCSYS_W_OK;
    assert(true ==
      ccsys_faccessat(L, CCSYS_AT_FDCWD, filename, mode, flags));
  @}

  /* Testing execute permissions. */
  @{
    ccsys_access_mode_t       mode;
    ccsys_faccessat_flags_t   flags = @{ .data = 0 @};

    mode.data = CCSYS_X_OK;
    assert(false ==
      ccsys_faccessat(L, CCSYS_AT_FDCWD, filename, mode, flags));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs trunc
@section Truncating files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_truncate (cce_destination_t @var{L}, char const * @var{pathname}, off_t @var{length})
Wrapper for @cfunc{truncate}.
@end deftypefun


@deftypefun void ccsys_ftruncate (cce_destination_t @var{L}, int @var{filedes}, off_t @var{length})
Wrapper for @cfunc{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File times


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_utime (cce_destination_t @var{L}, char const * @var{pathname}, const struct utimbuf * @var{times})
Wrapper for @cfunc{utime}.
@end deftypefun


@deftypefun void ccsys_utimes (cce_destination_t @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{utimes}.
@end deftypefun


@deftypefun void ccsys_lutimes (cce_destination_t @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{lutimes}.
@end deftypefun


@deftypefun void ccsys_futimes (cce_destination_t @var{L}, int @var{filedes}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{futimes}.
@end deftypefun

@c page
@node fs temp
@section Temporary files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_mkstemp (cce_destination_t @var{L}, char * @var{template})
Wrapper for @cfunc{mkstemp}.  Remember that this call will mutate @var{template}.
@end deftypefun


@deftypefun {char *} ccsys_mkdtemp (cce_destination_t @var{L}, char * @var{template})
Wrapper for @cfunc{mkdtemp}.  This function never returns @cnull{}.  Remember that this call will
mutate @var{template}.

@quotation
@strong{NOTE} This function is implemented by the @gnu{} C Library.  The feature is available only
if the package is configured with @option{--enable-glibc}; otherwise the function will raise an
exception with condition object of type @objtype{ccsys_unimplemented_C_t}.
@end quotation
@end deftypefun

@c page
@node sockets
@chapter Socket system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_bind (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{bind}.
@end deftypefun


@deftypefun void ccsys_getsockname (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{getsockname}.
@end deftypefun


@deftypefun void ccsys_inet_aton (cce_destination_t @var{L}, char const * @var{name}, struct in_addr * @var{addr})
Wrapper for @cfunc{inet_aton}.
@end deftypefun


@deftypefun in_addr_t ccsys_inet_network (cce_destination_t @var{L}, char const * @var{name})
Wrapper for @cfunc{inet_network}.
@end deftypefun


@deftypefun int ccsys_socket (cce_destination_t @var{L}, int @var{namespace}, int @var{style}, int @var{protocol})
Wrapper for @cfunc{socket}.
@end deftypefun


@deftypefun void ccsys_shutdown (cce_destination_t @var{L}, int @var{socket}, int @var{how})
Wrapper for @cfunc{shutdown}.
@end deftypefun


@deftypefun void ccsys_socketpair (cce_destination_t @var{L}, int @var{namespace}, int @var{style}, int @var{protocol}, int @var{filedes}[2])
Wrapper for @cfunc{socketpair}.
@end deftypefun


@deftypefun void ccsys_connect (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{connect}.
@end deftypefun


@deftypefun void ccsys_listen (cce_destination_t @var{L}, int @var{socket}, int @var{N})
Wrapper for @cfunc{listen}.
@end deftypefun


@deftypefun int ccsys_accept (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{accept}.
@end deftypefun


@deftypefun void ccsys_getpeername (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length}_ptr)
Wrapper for @cfunc{getpeername}.
@end deftypefun


@deftypefun size_t ccsys_send (cce_destination_t @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{send}.
@end deftypefun


@deftypefun size_t ccsys_recv (cce_destination_t @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{recv}.
@end deftypefun


@deftypefun size_t ccsys_sendto (cce_destination_t @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{sendto}.
@end deftypefun


@deftypefun size_t ccsys_recvfrom (cce_destination_t @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{recvfrom}.
@end deftypefun


@deftypefun void ccsys_getsockopt (cce_destination_t @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void * @var{optval}, socklen_t * @var{optlen_ptr})
Wrapper for @cfunc{getsockopt}.
@end deftypefun


@deftypefun void ccsys_setsockopt (cce_destination_t @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void const * @var{optval}, socklen_t @var{optlen})
Wrapper for @cfunc{setsockopt}.
@end deftypefun

@c page
@node process
@chapter Process system calls


@menu
* process exiting::             Exiting the current process.
* process system::              Executing subprocesses through the shell.
* process forking::             Forking the current process.
* process executing::           Executing a subprocess.
* process waiting::             Waiting for a subprocess.
@end menu

@c page
@node process exiting
@section Exiting the current process


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_exit (ccsys_exit_status_t @var{status})
Wrapper for @cfunc{exit}; @manpage{exit, Cause normal process termination}.
@end deftypefun


@deftypefun void ccsys__exit (ccsys_exit_status_t @var{status})
Wrapper for @cfunc{_exit}; @manpage{_exit, Terminate the calling process}.
@end deftypefun

@c page
@node process system
@section Executing subprocesses through the shell


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_system (cce_destination_t @var{L}, char const * @var{command})
Wrapper for @cfunc{system}.
@end deftypefun

@c page
@node process forking
@section Forking the current process


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_pid_t ccsys_fork (cce_location_t * @var{L})
Wrapper for @cfunc{fork}.
@end deftypefun


@deftypefun bool ccsys_in_parent_after_fork (ccsys_pid_t @var{pid})
The argument @var{pid} must be the return value of a call to @cfunc{ccsys_fork}.  Return @true{} if
the current process is the @strong{parent} after the call to @cfunc{ccsys_fork}; otherwise return
@false{}.
@end deftypefun


@deftypefun bool ccsys_in_child_after_fork (ccsys_pid_t @var{pid})
The argument @var{pid} must be the return value of a call to @cfunc{ccsys_fork}.  Return @true{} if
the current process is the @strong{child} after the call to @cfunc{ccsys_fork}; otherwise return
@false{}.
@end deftypefun

@c page
@node process executing
@section Executing a subprocess


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_execv (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execv}.
@end deftypefun


@deftypefun void ccsys_execve (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [], char * const @var{env} [])
Wrapper for @cfunc{execve}.
@end deftypefun


@deftypefun void ccsys_execvp (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execvp}.
@end deftypefun

@c page
@node process waiting
@section Waiting for a subprocess


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_waitpid (cce_destination_t @var{L}, pid_t @var{pid}, ccsys_waitpid_status_t * @var{wstatus}, ccsys_waitpid_options_t @var{options})
Wrapper for @cfunc{waitpid}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for exit status


@deftypefun bool ccsys_wifexited (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFEXITED}.
@end deftypefun


@deftypefun uint8_t ccsys_wexitstatus (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WEXITSTATUS}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for signals


@deftypefun bool ccsys_wifsignaled (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFSIGNALED}.
@end deftypefun


@deftypefun ccsys_signum_t ccsys_wtermsig (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WTERMSIG}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing core dumps


@deftypefun bool ccsys_wcoredump (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WCOREDUMP}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for stops


@deftypefun bool ccsys_wifstopped (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFSTOPPED}.
@end deftypefun


@deftypefun ccsys_signum_t ccsys_wstopsig (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WSTOPSIG}.
@end deftypefun

@c page
@node time
@chapter Time handling


@menu
* time units::                  Units of time.
* time structs::                Time structures.
@end menu

@c page
@node time units
@section Units of time


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Integer Typedef} ccsys_time_unit_t
The type of time units in the semantic types:

@example
ccsys_seconds_t
ccsys_milliseconds_t
ccsys_microseconds_t
ccsys_nanoseconds_t
@end example

@noindent
it is defined as @code{long int}.
@end deftp


@deftp {Semantic Type} ccsys_seconds_t
A signed exact integer representing a number of seconds.
@end deftp


@deftp {Semantic Type} ccsys_milliseconds_t
A signed exact integer representing a number of milliseconds.
@end deftp


@deftp {Semantic Type} ccsys_microseconds_t
A signed exact integer representing a number of microseconds.
@end deftp


@deftp {Semantic Type} ccsys_nanoseconds_t
A signed exact integer representing a number of nanoseconds.
@end deftp


@deftypefn {Preprocessor Macro} void ccsys_set_seconds (ccsys_seconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of seconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_milliseconds (ccsys_milliseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of milliseconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_microseconds (ccsys_microseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of microseconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_nanoseconds (ccsys_nanoseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of nanoseconds in @var{S} to @var{N}.
@end deftypefn

@c page
@node time structs
@section Time structures


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_timeval_t
Replacement of @code{struct timeval}.  It has the following fields:

@table @code
@item ccsys_seconds_t seconds
The number of seconds.

@item ccsys_microseconds_t microseconds
The number of microseconds.
@end table
@end deftp


@deftp {Struct Typedef} ccsys_timespec_t
Replacement of @code{struct timespec}.  It has the following fields:

@table @code
@item ccsys_seconds_t seconds
The number of seconds.

@item ccsys_nanoseconds_t nanoseconds
The number of nanoseconds.
@end table
@end deftp

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

