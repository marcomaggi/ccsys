\input texinfo.tex
@c %**start of header
@setfilename ccsys.info
@settitle CCSys
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSys

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSys

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsys

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a standard C11 language library;
it implements adapters for @posix{} system functions to convert the error reporting mechanism to the
use of the library CCExceptions.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsys: (ccsys).               System functions wrappers for CCExceptions.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* types::                       Semantic type definitions.
* enums::                       Enumerated constants.
* memory::                      Memory allocation, locking, mapping.
* io::                          Input/output system calls.
* fs::                          File system system calls.
* sockets::                     Socket system calls.
* process::                     Process system calls.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements adapters for @posix{} functions to convert the error reporting mechanism to the use of
the library CCExceptions.  The library supports some @gnu{} C Library functions and some Linux
functions.

@value{PACKAGE} installs a single header file @file{ccsys.h}.  All the function names in the @api{}
are prefixed with @code{ccsys_}; all the preprocessor symbol names are prefixed with @code{CCSYS_};
all the type names are prefixed with @code{ccsys_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
* overview api::                Programming interface.
* overview constants::          How system constants are handled.
* overview arguments::          How system call arguments and return
                                values are handled.
* overview structures::         How system structures are handled.
@end menu

@c page
@node overview linking
@section Linking code with the library


@subsubheading Using the @gnu{} Autotools

This package installs a data file for @command{pkg-config}; when searching for the installed library
with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSYS],[ccsys >= 0.1])
@end example

@noindent
which will set the variables @code{CCSYS_LIBS} and @code{CCSYS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccsys],[ccsys_version_string],,
  [AC_MSG_FAILURE([test for CCSys library failed])])
AC_CHECK_HEADERS([ccsys.h],,
  [AC_MSG_FAILURE([test for CCSys header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language.

@c ------------------------------------------------------------------------

@subsubheading One--shot compilation, Unix command line

For the one--shot compilation of a file named @file{demo.c}, we can do:

@example
gcc -std=c11 -Wall \
   `pkg-config ccsys --cflags` \
   `pkg-config ccsys --libs` \
   -o demo demo.c
@end example

@c page
@node overview api
@section Programming interface


@value{PACKAGE} defines function wrappers for the most common @posix{}, @gnu{} C Library and Linux
system calls.  Each wrapper accepts a pointer to @objtype{cce_location_t} as argument and, in case
of error, it will perform a non--local exit by jumping to the selected location.

Each wrapper function accepts the same arguments of the system call and returns the same return
value of the system call (if it completes successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

The library assumes to run on a @posix{} system, so the @posix{} system calls are available by
default.  The @gnu{} C Library and Linux calls are available only if the package was configured
with, respectively, @option{--enable-glibc} and @option{--enable-linux}.  If a system call is not
available: the associated wrapper will raise an exception of type
@objtype{cce_condition_unimplemented_t}.

@c page
@node overview constants
@section How system constants are handled


On a @posix{} platform, the system header files define a number of preprocessor symbols that expand
into constants; such constants are used to configure the behaviour of specific system function
calls.  @value{PACKAGE} is written in such a way that no system header file is included in the
package's header @file{ccsys.h}, so every constant definition is duplicated in the package's header.

All the constants are redefined as enumerated values, with the same system name prefixed with
@code{CCSYS_}.  For example, the file mode constants @code{O_RDONLY}, @code{O_WRONLY}, @code{O_RDWR}
are redefined with the following enumeration:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_WRONLY=1,
  CCSYS_O_RDWR=2,
  ...
@};

typedef enum ccsys_open_flags_enum_t ccsys_open_flags_enum_t;
@end example

@noindent
in which the constant values @samp{0}, @samp{1}, @samp{2} are the result of system inspection at
package configuration time.

If a symbol is not defined by the underlying platform, @value{PACKAGE} omits its redefinition.  For
example, in the unlikely case that the underlying platform does not define @code{O_WRONLY}, the
above redefinition would be:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_RDWR=2,
  ...
@};
@end example

@noindent
with @code{CCSYS_O_WRONLY} missing.

@c page
@node overview arguments
@section How system call arguments and return values are handled


@value{PACKAGE} attempts to implement strong typing for system call arguments with a specific
meaning.  For example, arguments like @var{flags} and @var{mode} in @cfunc{open} are both defined as
@code{int} by @posix{} but @value{PACKAGE} considers them as having semantic value, so they have
their type definition; the original system call has the prototype:

@example
int open(const char *pathname, int flags, mode_t mode);
@end example

@noindent
while the @value{PACKAGE} wrapper has the prototype:

@example
ccsys_fd_t ccsys_open (cce_location_t * L, char const * filename,
   ccsys_open_flags_t flags, ccsys_open_mode_t mode);
@end example

@noindent
both arguments and return values have a @dfn{semantic type}.

The argument and return value semantic types defined by @value{PACKAGE}, are @code{struct} type
definitions with a single field named @samp{data}; for example, here are possible definitions for
@cfunc{ccsys_open}:

@example
typedef struct ccsys_fd_t               ccsys_fd_t;
typedef struct ccsys_open_flags_t       ccsys_open_flags_t;
typedef struct ccsys_open_mode_t        ccsys_open_mode_t;

struct ccsys_fd_t               @{ int data; @};
struct ccsys_open_flags_t       @{ int data; @};
struct ccsys_open_mode_t        @{ int32_t data; @};
@end example

@noindent
when appropriate, the type of the field @samp{data} is determined at package configuration time.

@c page
@node overview structures
@section How system structures are handled


On a @posix{} platform, the system header files define a number of data structures used to exchange
values with the system itself.  @value{PACKAGE} is written in such a way that no system header file
is included in the package's header @file{ccsys.h}, so every data structure definition is duplicated
in the package's header.

Every duplicated data structure is defined as an opaque type in @file{ccsys.h}.  For example, here
is a possible redefinition for @code{struct stat}:

@example
typedef struct ccsys_stat_t     ccsys_stat_t;

struct ccsys_stat_t @{ uint8_t data[144]; @};
@end example

@noindent
for each public field in the structure, there is an accessor in the form of an @code{inline}
function, for example for the @code{st_dev} field:

@example
ccsys_dev_t ccsys_stat_st_dev (ccsys_stat_t const * S)
@end example


@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsys_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccsys_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsys_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccsys_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node types
@chapter Semantic type definitions


@anchor{ccsys_fd_t}
@deftp {Semantic Type} ccsys_fd_t
Type of file descriptors.  It is a singed integer.
@end deftp


@anchor{ccsys_dirfd_t}
@deftp {Semantic Type} ccsys_dirfd_t
Type of file descriptors for directories.  It is a singed integer.
@end deftp


@anchor{ccsys_off_t}
@deftp {Semantic Type} ccsys_off_t
Type of offsets.  It is a signed integer.
@end deftp


@anchor{ccsys_fd_flags_t}
@deftp {Semantic Type} ccsys_fd_flags_t
Type of arguments for some file descriptor functions.  It is a signed integer.  It is meant to be a
bitwise combination of the enumerated constants of type @objtype{ccsys_fd_flags_enum_t};
@ref{ccsys_fd_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_whence_t}
@deftp {Semantic Type} ccsys_whence_t
Type of @var{whence} arguments for file seek functions.  It is a signed integer.  It is meant to be
one of the enumerated constants of type @objtype{ccsys_whence_enum_t}; @ref{ccsys_whence_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_scatter_gather_flags_t}
@deftp {Semantic Type} ccsys_scatter_gather_flags_t
Type of @var{flags} arguments for some scatter/gather file input/output functions.  It is a signed
integer.  It is meant to be a bitwise combination of the enumerated constants of type
@objtype{ccsys_scatter_gather_flags_enum_t}; @ref{ccsys_scatter_gather_flags_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_open_flags_t}
@deftp {Semantic Type} ccsys_open_flags_t
Exact signed integer representing file open flags.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_flags_enum_t}; @ref{ccsys_open_flags_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_open_mode_t}
@deftp {Semantic Type} ccsys_open_mode_t
Exact signed integer representing file open modes.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_mode_enum_t}; @ref{ccsys_open_mode_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_unlinkat_flags_t}
@deftp {Semantic Type} ccsys_unlinkat_flags_t
Exact signed integer representing an @code{at()} function flag.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_unlinkat_flags_enum_t}.
@ref{ccsys_unlinkat_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_namespace_t}
@deftp {Semantic Type} ccsys_socket_namespace_t
Exact signed integer representing a socket namespace (or domain).  It is the of the argument
@var{namespace} or @var{domain} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_namespace_enum_t}; @ref{ccsys_socket_namespace_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_style_t}
@deftp {Semantic Type} ccsys_socket_style_t
Exact signed integer representing a socket style (or type).  It is the of the argument @var{style}
or @var{type} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_style_enum_t}; @ref{ccsys_socket_style_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_protocol_t}
@deftp {Semantic Type} ccsys_socket_protocol_t
Exact signed integer representing a socket protocol.  It is the of the argument @var{protocol} of
@cfunc{ccsys_socket}: one of the constants of type @objtype{ccsys_socket_protocol_enum_t};
@ref{ccsys_socket_protocol_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mlockall_flags_t}
@deftp {Semantic Type} ccsys_mlockall_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mlockall}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_locking_enum_t}; @ref{ccsys_memory_locking_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_prot_t}
@deftp {Semantic Type} ccsys_mmap_prot_t
Type of the argument @var{prot} in @cfunc{ccsys_mmap} and in @cfunc{ccsys_mprotect}.  It is meant to
be a bitwise combination of the constants of type @objtype{ccsys_memory_protection_enum_t};
@ref{ccsys_memory_protection_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_flags_t}
@deftp {Semantic Type} ccsys_mmap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mmap}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_mapping_enum_t}; @ref{ccsys_memory_mapping_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_msync_flags_t}
@deftp {Semantic Type} ccsys_msync_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_msync}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_sync_enum_t}; @ref{ccsys_memory_sync_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_mremap_flags_t}
@deftp {Semantic Type} ccsys_mremap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mremap}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_remap_enum_t}; @ref{ccsys_memory_remap_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_madvise_advice_t}
@deftp {Semantic Type} ccsys_madvise_advice_t
Type of the argument @var{advice} in @cfunc{ccsys_advise}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_advice_enum_t}; @ref{ccsys_memory_advice_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_exit_status_t}
@deftp {Semantic Type} ccsys_exit_status_t
Type of the argument @var{status} in @cfunc{ccsys_exit}.  It is meant to be one of the constants of
type @objtype{ccsys_exit_status_enum_t}; @ref{ccsys_exit_status_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_waitpid_status_t}
@deftp {Semantic Type} ccsys_waitpid_status_t
Type of the argument @var{wstatus} in @cfunc{ccsys_waitpid}.
@end deftp


@anchor{ccsys_waitpid_options_t}
@deftp {Semantic Type} ccsys_waitpid_options_t
Type of the argument @var{options} in @cfunc{ccsys_waitpid}.  It is meant to be a bitwise
combination of the constants of type @objtype{ccsys_waitpid_options_enum_t};
@ref{ccsys_waitpid_options_enum_t, Enumerated constants}.
@end deftp

@c page
@node enums
@chapter Enumerated constants


The following symbols are defined in the header file @file{ccsys.h}.


@EnumeratedConstant{CCSYS_EXIT_SUCCESS}
@EnumeratedConstant{CCSYS_EXIT_FAILURE}
@anchor{ccsys_exit_status_enum_t}
@deftp {Enum Typedef} ccsys_exit_status_enum_t
Exit statuses for @cfunc{ccsys_exit}.  It defines the following constants:

@example
CCSYS_EXIT_SUCCESS
CCSYS_EXIT_FAILURE
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_exit_status_t};
@ref{ccsys_exit_status_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_O_RDONLY}
@EnumeratedConstant{CCSYS_O_WRONLY}
@EnumeratedConstant{CCSYS_O_RDWR}
@EnumeratedConstant{CCSYS_O_APPEND}
@EnumeratedConstant{CCSYS_O_ASYNC}
@EnumeratedConstant{CCSYS_O_CLOEXEC}
@EnumeratedConstant{CCSYS_O_CREAT}
@EnumeratedConstant{CCSYS_O_DIRECT}
@EnumeratedConstant{CCSYS_O_DIRECTORY}
@EnumeratedConstant{CCSYS_O_DSYNC}
@EnumeratedConstant{CCSYS_O_EXCL}
@EnumeratedConstant{CCSYS_O_LARGEFILE}
@EnumeratedConstant{CCSYS_O_NDELAY}
@EnumeratedConstant{CCSYS_O_NOATIME}
@EnumeratedConstant{CCSYS_O_NOCTTY}
@EnumeratedConstant{CCSYS_O_NOFOLLOW}
@EnumeratedConstant{CCSYS_O_NONBLOCK}
@EnumeratedConstant{CCSYS_O_PATH}
@EnumeratedConstant{CCSYS_O_SYNC}
@EnumeratedConstant{CCSYS_O_TMPFILE}
@EnumeratedConstant{CCSYS_O_TRUNC}
@anchor{ccsys_open_flags_enum_t}
@deftp {Enum Typedef} ccsys_open_flags_enum_t
Type of file open flag constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{flags} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_O_RDONLY    CCSYS_O_WRONLY    CCSYS_O_RDWR

CCSYS_O_APPEND    CCSYS_O_ASYNC     CCSYS_O_CLOEXEC
CCSYS_O_CREAT     CCSYS_O_DIRECT    CCSYS_O_DIRECTORY
CCSYS_O_DSYNC     CCSYS_O_EXCL      CCSYS_O_LARGEFILE
CCSYS_O_NDELAY    CCSYS_O_NOATIME   CCSYS_O_NOCTTY
CCSYS_O_NOFOLLOW  CCSYS_O_NONBLOCK  CCSYS_O_PATH
CCSYS_O_SYNC      CCSYS_O_TMPFILE   CCSYS_O_TRUNC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_flags_t}; @ref{ccsys_open_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_S_IRUSR}
@EnumeratedConstant{CCSYS_S_IWUSR}
@EnumeratedConstant{CCSYS_S_IXUSR}
@EnumeratedConstant{CCSYS_S_IRGRP}
@EnumeratedConstant{CCSYS_S_IWGRP}
@EnumeratedConstant{CCSYS_S_IXGRP}
@EnumeratedConstant{CCSYS_S_IROTH}
@EnumeratedConstant{CCSYS_S_IWOTH}
@EnumeratedConstant{CCSYS_S_IXOTH}
@EnumeratedConstant{CCSYS_S_IRWXU}
@EnumeratedConstant{CCSYS_S_IRWXG}
@EnumeratedConstant{CCSYS_S_IRWXO}
@EnumeratedConstant{CCSYS_S_ISUID}
@EnumeratedConstant{CCSYS_S_ISGID}
@EnumeratedConstant{CCSYS_S_ISVTX}
@anchor{ccsys_open_mode_enum_t}
@deftp {Enum Typedef} ccsys_open_mode_enum_t
Type of file open mode constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{mode} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_S_IRUSR   CCSYS_S_IWUSR   CCSYS_S_IXUSR
CCSYS_S_IRGRP   CCSYS_S_IWGRP   CCSYS_S_IXGRP
CCSYS_S_IROTH   CCSYS_S_IWOTH   CCSYS_S_IXOTH
CCSYS_S_IRWXU   CCSYS_S_IRWXG   CCSYS_S_IRWXO
CCSYS_S_ISUID   CCSYS_S_ISGID   CCSYS_S_ISVTX
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_mode_t}; @ref{ccsys_open_mode_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_FD_CLOEXEC}
@anchor{ccsys_fd_flags_enum_t}
@deftp {Enum Typedef} ccsys_fd_flags_enum_t
Type of file descriptor flags constants.  It defines the following constants:

@example
CCSYS_FD_CLOEXEC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_fd_flags_t}; @ref{ccsys_fd_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SEEK_SET}
@EnumeratedConstant{CCSYS_SEEK_CUR}
@EnumeratedConstant{CCSYS_SEEK_END}
@anchor{ccsys_whence_enum_t}
@deftp {Enum Typedef} ccsys_whence_enum_t
Type of @var{whence} arguments to file seek functions.  It defines the following constants:

@example
CCSYS_SEEK_SET
CCSYS_SEEK_CUR
CCSYS_SEEK_END
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_whence_t};
@ref{ccsys_whence_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_RWF_HIPRI}
@EnumeratedConstant{CCSYS_RWF_NOWAIT}
@anchor{ccsys_scatter_gather_flags_enum_t}
@deftp {Enum Typedef} ccsys_scatter_gather_flags_enum_t
Type of @var{flags} arguments to some scatter/gather file input/output functions.  It defines the
following constants:

@example
CCSYS_RWF_HIPRI
CCSYS_RWF_NOWAIT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_scatter_gather_flags_t}; @ref{ccsys_scatter_gather_flags_t, Semantic type
definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AT_REMOVEDIR}
@anchor{ccsys_unlinkat_flags_enum_t}
@deftp {Enum Typedef} ccsys_unlinkat_flags_enum_t
Type of flags for @code{at()} functions.  These constants are meant to be used, for example, as
value for the argument @var{flags} of @cfunc{ccsys_unlinkat}.  It defines the following constants:

@example
CCSYS_AT_REMOVEDIR
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_unlinkat_flags_t}; @ref{ccsys_unlinkat_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SOCK_STREAM}
@EnumeratedConstant{CCSYS_SOCK_DGRAM}
@EnumeratedConstant{CCSYS_SOCK_SEQPACKET}
@EnumeratedConstant{CCSYS_SOCK_RAW}
@EnumeratedConstant{CCSYS_SOCK_RDM}
@EnumeratedConstant{CCSYS_SOCK_PACKET}
@anchor{ccsys_socket_namespace_enum_t}
@deftp {Enum Typedef} ccsys_socket_namespace_enum_t
Type of socket namespace selection constants.  These constants are meant to be used, for example, as
value for the argument @var{domain} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_DGRAM
CCSYS_SOCK_PACKET
CCSYS_SOCK_RAW
CCSYS_SOCK_RDM
CCSYS_SOCK_SEQPACKET
CCSYS_SOCK_STREAM
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_namespce_t}; @ref{ccsys_socket_namespace_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AF_UNIX}
@EnumeratedConstant{CCSYS_AF_LOCAL}
@EnumeratedConstant{CCSYS_AF_INET}
@EnumeratedConstant{CCSYS_AF_INET6}
@EnumeratedConstant{CCSYS_AF_IPX}
@EnumeratedConstant{CCSYS_AF_NETLINK}
@EnumeratedConstant{CCSYS_AF_X25}
@EnumeratedConstant{CCSYS_AF_AX25}
@EnumeratedConstant{CCSYS_AF_ATMPVC}
@EnumeratedConstant{CCSYS_AF_APPLETALK}
@EnumeratedConstant{CCSYS_AF_PACKET}
@EnumeratedConstant{CCSYS_AF_ALG}
@anchor{ccsys_socket_style_enum_t}
@deftp {Enum Typedef} ccsys_socket_style_enum_t
Type of socket style selection constants.  These constants are meant to be used, for example, as
value for the argument @var{type} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_AF_UNIX       CCSYS_AF_LOCAL   CCSYS_AF_INET
CCSYS_AF_INET6      CCSYS_AF_IPX     CCSYS_AF_NETLINK
CCSYS_AF_X25        CCSYS_AF_AX25    CCSYS_AF_ATMPVC
CCSYS_AF_APPLETALK  CCSYS_AF_PACKET  CCSYS_AF_ALG
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_style_t}; @ref{ccsys_socket_style_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SOCK_PROTOCOL_IP}
@anchor{ccsys_socket_protocol_enum_t}
@deftp {Enum Typedef} ccsys_socket_protocol_enum_t
Type of socket protocol selection constants.  These constants are meant to be used, for example, as
value for the argument @var{protocol} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_PROTOCOL_IP
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_protocol_t}; @ref{ccsys_socket_protocol_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MCL_CURRENT}
@EnumeratedConstant{CCSYS_MCL_FUTURE}
@EnumeratedConstant{CCSYS_MCL_ONFAULT}
@anchor{ccsys_memory_locking_enum_t}
@deftp {Enum Typedef} ccsys_memory_locking_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mlockall}.  It defines the
following constants:

@example
CCSYS_MCL_CURRENT
CCSYS_MCL_FUTURE
CCSYS_MCL_ONFAULT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mlockall_flags_t}; @ref{ccsys_mlockall_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_PROT_EXEC}
@EnumeratedConstant{CCSYS_PROT_READ}
@EnumeratedConstant{CCSYS_PROT_WRITE}
@EnumeratedConstant{CCSYS_PROT_NONE}
@anchor{ccsys_memory_protection_enum_t}
@deftp {Enum Typedef} ccsys_memory_protection_enum_t
Enumeration of constants for the argument @var{prot} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_PROT_EXEC
CCSYS_PROT_READ
CCSYS_PROT_WRITE
CCSYS_PROT_NONE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_prot_t}; @ref{ccsys_mmap_prot_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MAP_SHARED}
@EnumeratedConstant{CCSYS_MAP_PRIVATE}
@EnumeratedConstant{CCSYS_MAP_32BIT}
@EnumeratedConstant{CCSYS_MAP_ANON}
@EnumeratedConstant{CCSYS_MAP_ANONYMOUS}
@EnumeratedConstant{CCSYS_MAP_DENYWRITE}
@EnumeratedConstant{CCSYS_MAP_EXECUTABLE}
@EnumeratedConstant{CCSYS_MAP_FILE}
@EnumeratedConstant{CCSYS_MAP_FIXED}
@EnumeratedConstant{CCSYS_MAP_GROWSDOWN}
@EnumeratedConstant{CCSYS_MAP_HUGETLB}
@EnumeratedConstant{CCSYS_MAP_HUGE_2MB}
@EnumeratedConstant{CCSYS_MAP_HUGE_1GB}
@EnumeratedConstant{CCSYS_MAP_LOCKED}
@EnumeratedConstant{CCSYS_MAP_NONBLOCK}
@EnumeratedConstant{CCSYS_MAP_NORESERVE}
@EnumeratedConstant{CCSYS_MAP_POPULATE}
@EnumeratedConstant{CCSYS_MAP_STACK}
@EnumeratedConstant{CCSYS_MAP_UNINITIALIZED}
@EnumeratedConstant{CCSYS_MAP_AUTOGROW}
@EnumeratedConstant{CCSYS_MAP_AUTORESRV}
@EnumeratedConstant{CCSYS_MAP_COPY}
@EnumeratedConstant{CCSYS_MAP_LOCAL}
@anchor{ccsys_memory_mapping_enum_t}
@deftp {Enum Typedef} ccsys_memory_mapping_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_MAP_SHARED        CCSYS_MAP_PRIVATE     CCSYS_MAP_32BIT
CCSYS_MAP_ANON          CCSYS_MAP_ANONYMOUS   CCSYS_MAP_DENYWRITE
CCSYS_MAP_EXECUTABLE    CCSYS_MAP_FILE        CCSYS_MAP_FIXED
CCSYS_MAP_GROWSDOWN     CCSYS_MAP_HUGETLB     CCSYS_MAP_HUGE_2MB
CCSYS_MAP_HUGE_1GB      CCSYS_MAP_LOCKED      CCSYS_MAP_NONBLOCK
CCSYS_MAP_NORESERVE     CCSYS_MAP_POPULATE    CCSYS_MAP_STACK
CCSYS_MAP_UNINITIALIZED CCSYS_MAP_AUTOGROW    CCSYS_MAP_AUTORESRV
CCSYS_MAP_COPY          CCSYS_MAP_LOCAL
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_flags_t}; @ref{ccsys_mmap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MS_ASYNC}
@EnumeratedConstant{CCSYS_MS_SYNC}
@EnumeratedConstant{CCSYS_MS_INVALIDATE}
@anchor{ccsys_memory_sync_enum_t}
@deftp {Enum Typedef} ccsys_memory_sync_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_msync}.  It defines the
following constants:

@example
CCSYS_MS_ASYNC
CCSYS_MS_SYNC
CCSYS_MS_INVALIDATE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_msync_flags_t}; @ref{ccsys_msync_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MREMAP_MAYMOVE}
@EnumeratedConstant{CCSYS_MREMAP_FIXED}
@anchor{ccsys_memory_remap_enum_t}
@deftp {Enum Typedef} ccsys_memory_remap_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mremap}.  It defines the
following constants:

@example
CCSYS_MREMAP_MAYMOVE
CCSYS_MREMAP_FIXED
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mremap_flags_t}; @ref{ccsys_mremap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MADV_NORMAL}
@EnumeratedConstant{CCSYS_MADV_RANDOM}
@EnumeratedConstant{CCSYS_MADV_SEQUENTIAL}
@EnumeratedConstant{CCSYS_MADV_WILLNEED}
@EnumeratedConstant{CCSYS_MADV_DONTNEED}
@EnumeratedConstant{CCSYS_MADV_REMOVE}
@EnumeratedConstant{CCSYS_MADV_DONTFORK}
@EnumeratedConstant{CCSYS_MADV_DOFORK}
@EnumeratedConstant{CCSYS_MADV_HWPOISON}
@EnumeratedConstant{CCSYS_MADV_MERGEABLE}
@EnumeratedConstant{CCSYS_MADV_UNMERGEABLE}
@EnumeratedConstant{CCSYS_MADV_SOFT_OFFLINE}
@EnumeratedConstant{CCSYS_MADV_HUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_NOHUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_DONTDUMP}
@EnumeratedConstant{CCSYS_MADV_DODUMP}
@EnumeratedConstant{CCSYS_MADV_FREE}
@anchor{ccsys_memory_advice_enum_t}
@deftp {Enum Typedef} ccsys_memory_advice_enum_t
Enumeration of constants for the argument @var{advice} in @cfunc{ccsys_madvise}.  It defines the
following constants:

@example
CCSYS_MADV_NORMAL       CCSYS_MADV_RANDOM       CCSYS_MADV_SEQUENTIAL
CCSYS_MADV_WILLNEED     CCSYS_MADV_DONTNEED     CCSYS_MADV_REMOVE
CCSYS_MADV_DONTFORK     CCSYS_MADV_DOFORK       CCSYS_MADV_HWPOISON
CCSYS_MADV_MERGEABLE    CCSYS_MADV_UNMERGEABLE  CCSYS_MADV_SOFT_OFFLINE
CCSYS_MADV_HUGEPAGE     CCSYS_MADV_NOHUGEPAGE   CCSYS_MADV_DONTDUMP
CCSYS_MADV_DODUMP       CCSYS_MADV_FREE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_madvise_advice_t}; @ref{ccsys_madvise_advice_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_WNOHANG}
@EnumeratedConstant{CCSYS_WUNTRACED}
@EnumeratedConstant{CCSYS_WCONTINUED}
@anchor{ccsys_waitpid_options_enum_t}
@deftp {Enum Typedef} ccsys_waitpid_options_enum_t
Enumeration of constants representing process wait options.

@example
CCSYS_WNOHANG
CCSYS_WUNTRACED
CCSYS_WCONTINUED
@end example
@end deftp

@c page
@node memory
@chapter Memory allocation, locking, mapping

@menu
* memory basic::                Basic memory allocation.
* memory handler::              Basic memory handling.
* memory gmalloc::              Guarded allocation: @cfunc{malloc}.
* memory gcalloc::              Guarded allocation: @cfunc{calloc}.
* memory grealloc::             Guarded allocation: @cfunc{realloc}.
* memory locking::              Locking memory pages.
* memory mapping::              Memory mapping system calls.
@end menu

@c page
@node memory basic
@section Basic memory allocation


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc (cce_location_t * @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_realloc (cce_location_t * @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_calloc (cce_location_t * @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun void ccsys_free (cce_location_t * @var{L}, void * @var{ptr})
This is a plain wrapper for @cfunc{free}.  At present the argument @var{L} is unused.  This function
exists so that we can access this function by only including the header file @file{ccsys.h} and not
including the system header @file{stdlib.h}.
@end deftypefun

@c page
@node memory handler
@section Basic memory handling


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *        P = ccsys_malloc(L, 4096);
  ccsys_cleanup_handler_malloc_init(L, P_H, P);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_malloc_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void ccsys_error_handler_malloc_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun

@c page
@node memory gmalloc
@section Guarded allocation: @cfunc{malloc}


To allocate memory using a cleanup handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc_guarded_cleanup (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_malloc_guarded_error (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
@deftypefnx {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory gcalloc
@section Guarded allocation: @cfunc{calloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_calloc_guarded_cleanup (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_calloc_guarded_error (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory grealloc
@section Guarded allocation: @cfunc{realloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_realloc_guarded_cleanup (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefun {void *} ccsys_realloc_guarded_error (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_location_t * @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory locking
@section Locking memory pages


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mlock (cce_location_t * @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{mlock}.
@end deftypefun


@deftypefun void ccsys_munlock (cce_location_t * @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{munlock}.
@end deftypefun


@deftypefun void ccsys_mlockall (cce_location_t * @var{L}, ccsys_mlockall_flags_t @var{flags})
Wrapper for @cfunc{mlockall}.  The argument @var{flags} is meant to be a bitwise combination of the
constants of type @objtype{ccsys_memory_locking_enum_t}.
@end deftypefun


@deftypefun void ccsys_munlockall (cce_location_t * @var{L})
Wrapper for @cfunc{munlockall}.
@end deftypefun

@c page
@node memory mapping
@section Memory mapping system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_mmap (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, ccsys_mmap_prot_t @var{prot}, ccsys_mmap_flags_t @var{flags}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset})
Wrapper for @cfunc{mmap}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_mapping_enum_t}.
@end deftypefun


@deftypefun int ccsys_munmap (cce_location_t * @var{L}, void * @var{addr}, size_t @var{length})
Wrapper for @cfunc{munmap}.
@end deftypefun


@deftypefun int ccsys_msync (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, ccsys_msync_flags_t @var{flags})
Wrapper for @cfunc{msync}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_sync_enum_t}.
@end deftypefun


@deftypefun int ccsys_mprotect (cce_location_t * @var{L}, void * @var{addr}, size_t @var{len}, ccsys_mmap_prot_t @var{prot})
Wrapper for @cfunc{mprotect}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.
@end deftypefun


@deftypefun {void *} ccsys_mremap (cce_location_t * @var{L}, void * @var{old_address}, size_t @var{length}, size_t @var{new_length}, ccsys_mremap_flags_t @var{flags}, void * @var{new_address})
Wrapper for @cfunc{mremap}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_remap_enum_t}.

@quotation
@strong{NOTE}  This function is specific to Linux platforms.
@end quotation
@end deftypefun


@deftypefun void ccsys_madvise (cce_location_t * @var{L}, void * @var{address}, size_t @var{length}, ccsys_madvise_advice_t @var{advice})
Wrapper for @cfunc{madvise}.

The argument @var{advice} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_advice_enum_t}.

@quotation
@strong{NOTE}  This function is implemented by the @gnu{} C Library.
@end quotation
@end deftypefun

@c page
@node io
@chapter Input/output system calls


@menu
* io constants::                Global constants.
* io open::                     Opening files.
* io pipes::                    Creating pipes.
* io fifos::                    Creating FIFOs.
* io close::                    Closing file descriptors.
* io read write::               Reading and writing files.
* io scatter gather::           Scatter-gather input/output.
* io dup::                      Duplicating file descriptors.
* io waiting::                  Waiting for input/output.
@end menu

@c page
@node io constants
@section Global constants


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDIN
Constant representing the standard input file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDOUT
Constant representing the standard output file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDERR
Constant representing the standard error file descriptor.
@end deftypevr

@c page
@node io open
@section Opening files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_open (cce_location_t * @var{L}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{open}.  @manpage{open, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_openat (cce_location_t * @var{L}, ccsys_dirfd_t @var{filedes}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{openat}.  @manpage{openat, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


We can use  @cfunc{ccsys_openat} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dir_H[1];
cce_cleanup_handler_t   dirstream_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  static char const * dirname  = "dir.d";
  static char const * filename = "name.ext";
  ccsys_dirfd_t       dirfd;

  /* Create the directory. */
  @{
    ccsys_open_mode_t   mode;

    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdir(L, dirname, mode);
    ccsys_handler_rmdir_init(L, dir_H, dirname);
  @}

  /* Open the directory.  The descriptor in "dirfd" is released
     automatically when "dirstream" is released. */
  @{
    ccsys_dir_t *     dirstream;

    dirstream = ccsys_opendir(L, dirname);
    ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
    dirfd = ccsys_dirfd(L, dirstream);
  @}

  /* Open the file. */
  @{
    ccsys_open_flags_t    flags;
    ccsys_open_mode_t     mode;
    ccsys_fd_t            fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, dirfd, filename, flags, mode);
    ccsys_handler_filedes_init(L, file_H, fd);

    /* Do something with "fd" here. */
  @}

  /* Remove the file. */
  @{
    ccsys_unlinkat_flags_t flags;

    flags.data = 0;
    ccsys_unlinkat(L, dirfd, filename, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io pipes
@section Creating pipes


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_pipe (cce_location_t * @var{L}, ccsys_fd_t @var{pipefd}[2])
Wrapper for @cfunc{pipe}.  @manpage{pipe, Create pipes}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Pipe handlers

We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_fd_t    pipefd[2];
  ccsys_pipe(L, pipefd);
  ccsys_handler_pipedes_init(L, H, pipefd);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
@deftypefunx void ccsys_error_handler_pipedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptors in @var{pipedes} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefnx {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_location_t * @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{fd})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_pipedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_pipedes_init}.
@end table
@end deftypefn

@c page
@node io fifos
@section Creating FIFOs


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkfifo (cce_location_t * @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifo}.  @manpage{mkfifo, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun void ccsys_mkfifoat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifoat}.  @manpage{mkfifoat, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@menu
* io fifos mkfifo::             Usage example for @cfunc{ccsys_mkfifo}.
* io fifos mkfifoat::           Usage example for @cfunc{ccsys_mkfifoat}.
@end menu

@c page
@node io fifos mkfifo
@subsection Usage example for @cfunc{ccsys_mkfifo}


As example of @cfunc{ccsys_mkfifo} usage consider the following, which:

@enumerate
@item
Creates a named @fifo{}.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{remove};
waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    char const * fifoname);
void sample_child  (char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t fifo_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * fifoname = "fifo.ext";
    ccsys_pid_t         pid;

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t         mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifo(L, fifoname, mode);
      ccsys_handler_remove_init(L, fifo_H, fifoname);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;
        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child  (char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io fifos mkfifoat
@subsection Usage example for @cfunc{ccsys_mkfifoat}


As example of @cfunc{ccsys_mkfifoat} usage consider the following, which:

@enumerate
@item
Creates a directory.

@item
Creates a named @fifo{} in the directory.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{unlinkat};
removes the directory; waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    ccsys_dirfd_t dirfd, char const * fifoname);
void sample_child  (ccsys_dirfd_t dirfd, char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t dir_H[1];
  cce_cleanup_handler_t dirstream_H[1];
  cce_cleanup_handler_t fifo_H[1];
  ccsys_at_link_t       fifo_unlink_data;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * dirname  = "name.d";
    static char const * fifoname = "fifo.ext";
    ccsys_dirfd_t       dirfd;
    ccsys_pid_t         pid;

    /* Create the directory. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRWXU;
      ccsys_mkdir(L, dirname, mode);
      ccsys_handler_rmdir_init(L, dir_H, dirname);
    @}

    /* Open the directory. */
    @{
      ccsys_dir_t *     dirstream;
      dirstream = ccsys_opendir(L, dirname);
      ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
      dirfd = ccsys_dirfd(L, dirstream);
    @}

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifoat(L, dirfd, fifoname, mode);
      fifo_unlink_data.dirfd    = dirfd;
      fifo_unlink_data.pathname = fifoname;
      ccsys_handler_unlinkat_init(L, fifo_H, &fifo_unlink_data);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, dirfd, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;

        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(dirfd, fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L,
               ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child (ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io close
@section Closing file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_close (cce_location_t * @var{L}, ccsys_fd_t @var{filedes})
Wrapper for @cfunc{close}.  @manpage{close, Close a file descriptor}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading File descriptor handlers

We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_open_flags_t  flags;
  ccsys_open_mode_t   mode;
  ccsys_fd_t          fd;

  flags.data = CCSYS_O_CREAT;
  mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd = ccsys_open(L, filename, flags, mode);
  ccsys_handler_filedes_init(L, H, fd);

  /* Do something with "fd" here. */
  cce_run_cleanup_handlers(L);
@}
@end example


@deftypefun void ccsys_cleanup_handler_filedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefunx void ccsys_error_handler_filedes_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptor @var{fd} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_filedes_init (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefnx {Preprocessor Macro} void ccsys_handler_filedes_init (cce_location_t * @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{fd})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_filedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_filedes_init}.
@end table
@end deftypefn

@c page
@node io read write
@section Reading and writing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun size_t ccsys_read (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{read}; @manpage{read, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{read} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pread (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pread}; @manpage{pread, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{pread} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_write (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{write}; @manpage{read, Write to a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{write} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pwrite (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwrite}; @manpage{pwrite, Writing to a file descriptor}.  Notice the return value
of type @objtype{size_t}: the negative values returned by @cfunc{pwrite} are consumed by this
function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun ccsys_off_t ccsys_lseek (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset}, ccsys_whence_t @var{whence})
Wrapper for @cfunc{lseek}; @manpage{lseek, Reposition a read/write file offset}.
@end deftypefun

@menu
* io read write one::           @cfunc{ccsys_read} and @cfunc{ccsys_write}.
* io read write two::           @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}.
@end menu

@c page
@node io read write one
@subsection @cfunc{ccsys_read} and @cfunc{ccsys_write}


As example of using @cfunc{ccsys_read} and @cfunc{ccsys_write} see the following code which opens a
file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    N = ccsys_write(L, fd, buf, len);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    N = ccsys_read(L, fd, buf, len);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io read write two
@subsection @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}


As example of using @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    offset.data = 0;
    N = ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Reading. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    N = ccsys_pread(L, fd, buf, len, offset);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather
@section Scatter--gather input/output


For all the functions: notice the return value of type @objtype{size_t}: the negative values
returned by the system function is consumed by the wrapper function, so either the return value is
an unsigned integer or an exception is raised.

The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_iovec_t
Wrapper type for @objtype{struct iovec}.
@end deftp


@deftypefun {void **} ccsys_iovec_iov_base (ccsys_iovect_t const * @var{S})
Return a pointer to the field @code{iov_base} in the structure referenced by @var{S}.
@end deftypefun


@deftypefun {size_t *} ccsys_iovec_iov_len (ccsys_iovect_t const * @var{S})
Return a pointer to the field @code{iov_len} in the structure referenced by @var{S}.
@end deftypefun


@deftypefun size_t ccsys_readv (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{readv}; @manpage{readv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_writev (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{writev}; @manpage{writev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{preadv}; @manpage{preadv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwritev}; @manpage{pwritev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv2 (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{preadv2}; @manpage{preadv2, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev2 (cce_location_t * @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{pwritev2}; @manpage{pwritev2, Write to a file descriptor using multiple buffers}.
@end deftypefun

@menu
* io scatter gather one::       Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}.
* io scatter gather two::       Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}.
@end menu

@c page
@node io scatter gather one
@subsection Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}


As example of using @cfunc{ccsys_readv} and @cfunc{ccsys_writev} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_writev(L, fd, vec, buf_count);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_readv(L, fd, vec, buf_count);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather two
@subsection Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}


As example of using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev} see the following code which
opens a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_pwritev(L, fd, vec, buf_count, offset);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_preadv(L, fd, vec, buf_count, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup
@section Duplicating file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_dup (cce_location_t * @var{L}, ccsys_fd_t @var{old})
Wrapper for @cfunc{dup}; @manpage{dup, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_location_t * @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new})
Wrapper for @cfunc{dup2}; @manpage{dup2, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_location_t * @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new}, ccsys_open_flags_t @var{flags})
Wrapper for @cfunc{dup3}; @manpage{dup3, Duplicate a file descriptor}.
@end deftypefun


@menu
* io dup one::                  Using @cfunc{ccsys_dup}.
* io dup two::                  Using @cfunc{ccsys_dup2}.
* io dup three::                Using @cfunc{ccsys_dup3}.
@end menu

@c page
@node io dup one
@subsection Using @cfunc{ccsys_dup}


As example of using @cfunc{ccsys_dup} see the following code which opens a file, duplicates the file
descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
 @} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
   @}

  /* Duplicate the file descriptor. */
  fdx = ccsys_dup(L, fd);

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
   @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
   @}

  cce_run_cleanup_handlers(L);
 @}
@end example

@c page
@node io dup two
@subsection Using @cfunc{ccsys_dup2}


As example of using @cfunc{ccsys_dup2} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    fdx.data = 123;
    fdx = ccsys_dup2(L, fd, fdx);
    assert(123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup three
@subsection Using @cfunc{ccsys_dup3}


As example of using @cfunc{ccsys_dup3} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    ccsys_open_flags_t        flags;

    flags.data        = CCSYS_O_CLOEXEC;
    fdx.data          = 123;
    fdx = ccsys_dup3(L, fd, fdx, flags);
    assert(L, 123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    static size_t const len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io waiting
@section Waiting for input/output


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_select (cce_location_t * @var{L}, int @var{nfds}, ccsys_fd_set_t * @var{read_fds}, ccsys_fd_set_t * @var{write_fds}, ccsys_fd_set_t * @var{except_fds}, ccsys_timeval_t * @var{timeout})
Wrapper for @cfunc{select}.
@end deftypefun

@c page
@node fs
@chapter File system system calls


@menu
* fs dirs working::             The working directory.
* fs dirs reading::             Reading directory entries.
* fs dirs creating::            Creating and deleting directories.
* fs links::                    Operating on links.
* fs removing::                 Removing files.
* fs renaming::                 Renaming files and directories.
* fs attributes::               Reading file attributes.
* fs owner::                    Changing owner.
* fs access perms::             Changing access permissions.
* fs access tests::             Testing access permissions.
* fs trunc::                    Truncating files.
* fs times::                    File times.
* fs temp::                     Temporary files and directories.
@end menu

@c page
@node fs dirs working
@section The working directory


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_getcwd (cce_location_t * @var{L}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{getcwd}.
@end deftypefun


@deftypefun void ccsys_chdir (cce_location_t * @var{L}, char const * @var{pathname})
Wrapper for @cfunc{chdir}.
@end deftypefun


@deftypefun void ccsys_fchdir (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fchdir}.
@end deftypefun

@c page
@node fs dirs reading
@section Reading directory entries


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {ccsys_dir_t *} ccsys_opendir (cce_location_t * @var{L}, char const * @var{pathname})
Wrapper for @cfunc{opendir}.
@end deftypefun


@deftypefun {ccsys_dir_t *} ccsys_fdopendir (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fdopendir}.
@end deftypefun


@deftypefun {ccsys_dirent_t *} ccsys_readdir (cce_location_t * @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{readdir}.
@end deftypefun


@deftypefun void ccsys_closedir (cce_location_t * @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{closedir}.
@end deftypefun


@deftypefun ccsys_dirfd_t ccsys_dirfd (cce_location_t * @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{dirfd}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for directory streams


We can read the contents of a directory opening a directory stream with @cfunc{ccsys_opendir} and
closing it with @cfunc{closedir}:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dirstream_H[1];
char const *            pathname = "./";

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_dir_t *         dirstream;
  ccsys_dirent_t *      direntry;

  dirstream = ccsys_opendir(L, pathname);
  ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
  for (direntry = ccsys_readdir(L, dirstream);
       direntry;
       direntry = ccsys_readdir(L, dirstream)) @{
    printf("%s\n", direntry->d_name);
    fflush(stdout);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{closedir}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_dirstream_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefunx void ccsys_error_handler_dirstream_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
finalise the directory stream using the standard function @cfunc{closedir}; errors in
@cfunc{closedir} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefnx {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_location_t * @var{L}, cce_error_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_dirstream_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_dirstream_init}.
@end table
@end deftypefn

@c page
@node fs dirs creating
@section Creating and deleting directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkdir (cce_location_t * @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkdir}.
@end deftypefun


@deftypefun void ccsys_rmdir (cce_location_t * @var{L}, char const * @var{pathname})
Wrapper for @cfunc{rmdir}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for directories removal


We can remove @strong{empty} temporary directories with the standard function @cfunc{rmdir} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dir_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_mode_t     mode;

  mode.data = CCSYS_S_IRWXU;
  ccsys_mkdir(L, "name.d", mode);
  ccsys_handler_rmdir_init(L, dir_H, "name.d");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{rmdir}, which is generally bad; we
can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the function @cfunc{mkdtemp}
implemented by the @gnu{} C Library.


@deftypefun void ccsys_cleanup_handler_rmdir_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_rmdir_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the directory whose pathname is @var{pathname} using the standard function @cfunc{rmdir};
errors in @cfunc{rmdir} are @strong{ignored}.  The directory is removed only if it is empty.

The string referenced by @var{pathname} is duplicated and stored in the structure referenced by
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_location_t * @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_rmdir_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_rmdir_init}.
@end table
@end deftypefn

@c page
@node fs links
@section Operating on links


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_link (cce_location_t * @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{link}.
@end deftypefun


@deftypefun void ccsys_linkat (cce_location_t * @var{L}, int @var{olddirfd}, char const * @var{oldname}, int @var{newdirfd}, char const * @var{newname}, int @var{flags})
Wrapper for @cfunc{linkat}.
@end deftypefun


@deftypefun void ccsys_symlink (cce_location_t * @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{symlink}.
@end deftypefun


@deftypefun void ccsys_symlinkat (cce_location_t * @var{L}, char const * @var{oldname}, int @var{newdirfd}, char const * @var{newname})
Wrapper for @cfunc{symlinkat}.
@end deftypefun


@deftypefun size_t ccsys_readlink (cce_location_t * @var{L}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlink}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun size_t ccsys_readlinkat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlinkat}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun {char *} ccsys_realpath (cce_location_t * @var{L}, char const * @var{pathname}, char * @var{resolved_path})
Wrapper for @cfunc{realpath}.  Notice that this function never returns @cnull{}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun void ccsys_unlink (cce_location_t * @var{L}, char const * @var{filename})
Wrapper for @cfunc{unlink}.
@end deftypefun


@deftypefun void ccsys_unlinkat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, ccsys_unlinkat_flags_t @var{flags})
Wrapper for @cfunc{unlinkat}.
@end deftypefun

@c page
@node fs removing
@section Removing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_remove (cce_location_t * @var{L}, char const * @var{pathname})
Wrapper for @cfunc{remove}.  This function removes both files and empty directories.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for files removal


We can remove temporary files with the standard function @cfunc{remove} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   fd_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_flags_t    flags;
  ccsys_open_mode_t     mode;
  ccsys_fd_t            fd;

  flags.data    = CCSYS_O_CREAT;
  mode.data     = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd            = ccsys_open(L, "name.ext", flags, mode);
  ccsys_cleanup_handler_filedes_init(L, fd_H, fd);
  ccsys_cleanup_handler_remove_init(L, file_H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{remove}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the @posix{} standard function
@cfunc{mkstemp}.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_remove_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_remove_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the file whose pathname is @var{pathname} using the standard function @cfunc{remove}; errors
in @cfunc{remove} are @strong{ignored}.

The string referenced by @var{pathname} is duplicated and stored in the structure referenced by
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_remove_init (cce_location_t * @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_remove_init (cce_location_t * @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_remove_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_remove_init}.
@end table
@end deftypefn

@c page
@node fs renaming
@section Renaming files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_rename (cce_location_t * @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{rename}.
@end deftypefun

@c page
@node fs attributes
@section Reading file attributes


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_stat (cce_location_t * @var{L}, char const * @var{pathname}, struct stat * @var{buf})
Wrapper for @cfunc{stat}.
@end deftypefun


@deftypefun void ccsys_fstat (cce_location_t * @var{L}, int @var{fd}, struct stat * @var{buf})
Wrapper for @cfunc{fstat}.
@end deftypefun


@deftypefun void ccsys_lstat (cce_location_t * @var{L}, char const * @var{pathname}, struct stat * @var{buf})
Wrapper for @cfunc{lstat}.
@end deftypefun

@c page
@node fs owner
@section Changing owner


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chown (cce_location_t * @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{chown}.
@end deftypefun


@deftypefun void ccsys_fchown (cce_location_t * @var{L}, int @var{filedes}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{fchown}.
@end deftypefun


@deftypefun void ccsys_lchown (cce_location_t * @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{lchown}.
@end deftypefun


@deftypefun void ccsys_fchownat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group}, int @var{flags})
Wrapper for @cfunc{fchownat}.
@end deftypefun

@c page
@node fs access perms
@section Changing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chmod (cce_location_t * @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{chmod}.
@end deftypefun


@deftypefun void ccsys_fchmod (cce_location_t * @var{L}, int @var{filedes}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{fchmod}.
@end deftypefun


@deftypefun void ccsys_fchmodat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode}, int @var{flags})
Wrapper for @cfunc{fchmodat}.
@end deftypefun

@c page
@node fs access tests
@section Testing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_access (cce_location_t * @var{L}, char const * @var{pathname}, int @var{how})
Wrapper for @cfunc{access}.  The return value is @samp{0} if access is denied; the return value is
@samp{-1} if access is granted.
@end deftypefun


@deftypefun int ccsys_faccessat (cce_location_t * @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, int @var{how}, int @var{flags})
Wrapper for @cfunc{faccessat}.
@end deftypefun

@c page
@node fs trunc
@section Truncating files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_truncate (cce_location_t * @var{L}, char const * @var{pathname}, off_t @var{length})
Wrapper for @cfunc{truncate}.
@end deftypefun


@deftypefun void ccsys_ftruncate (cce_location_t * @var{L}, int @var{filedes}, off_t @var{length})
Wrapper for @cfunc{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File times


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_utime (cce_location_t * @var{L}, char const * @var{pathname}, const struct utimbuf * @var{times})
Wrapper for @cfunc{utime}.
@end deftypefun


@deftypefun void ccsys_utimes (cce_location_t * @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{utimes}.
@end deftypefun


@deftypefun void ccsys_lutimes (cce_location_t * @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{lutimes}.
@end deftypefun


@deftypefun void ccsys_futimes (cce_location_t * @var{L}, int @var{filedes}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{futimes}.
@end deftypefun

@c page
@node fs temp
@section Temporary files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_mkstemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkstemp}.  Remember that this call will mutate @var{template}.
@end deftypefun


@deftypefun {char *} ccsys_mkdtemp (cce_location_t * @var{L}, char * @var{template})
Wrapper for @cfunc{mkdtemp}.  This function never returns @cnull{}.  Remember that this call will
mutate @var{template}.

@quotation
@strong{NOTE} This function is implemented by the @gnu{} C Library.  The feature is available only
if the package is configured with @option{--enable-glibc}; otherwise the function will raise an
exception with condition object of type @objtype{ccsys_unimplemented_C_t}.
@end quotation
@end deftypefun

@c page
@node sockets
@chapter Socket system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_bind (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{bind}.
@end deftypefun


@deftypefun void ccsys_getsockname (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{getsockname}.
@end deftypefun


@deftypefun void ccsys_inet_aton (cce_location_t * @var{L}, char const * @var{name}, struct in_addr * @var{addr})
Wrapper for @cfunc{inet_aton}.
@end deftypefun


@deftypefun in_addr_t ccsys_inet_network (cce_location_t * @var{L}, char const * @var{name})
Wrapper for @cfunc{inet_network}.
@end deftypefun


@deftypefun int ccsys_socket (cce_location_t * @var{L}, int @var{namespace}, int @var{style}, int @var{protocol})
Wrapper for @cfunc{socket}.
@end deftypefun


@deftypefun void ccsys_shutdown (cce_location_t * @var{L}, int @var{socket}, int @var{how})
Wrapper for @cfunc{shutdown}.
@end deftypefun


@deftypefun void ccsys_socketpair (cce_location_t * @var{L}, int @var{namespace}, int @var{style}, int @var{protocol}, int @var{filedes}[2])
Wrapper for @cfunc{socketpair}.
@end deftypefun


@deftypefun void ccsys_connect (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{connect}.
@end deftypefun


@deftypefun void ccsys_listen (cce_location_t * @var{L}, int @var{socket}, int @var{N})
Wrapper for @cfunc{listen}.
@end deftypefun


@deftypefun int ccsys_accept (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{accept}.
@end deftypefun


@deftypefun void ccsys_getpeername (cce_location_t * @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length}_ptr)
Wrapper for @cfunc{getpeername}.
@end deftypefun


@deftypefun size_t ccsys_send (cce_location_t * @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{send}.
@end deftypefun


@deftypefun size_t ccsys_recv (cce_location_t * @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{recv}.
@end deftypefun


@deftypefun size_t ccsys_sendto (cce_location_t * @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{sendto}.
@end deftypefun


@deftypefun size_t ccsys_recvfrom (cce_location_t * @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{recvfrom}.
@end deftypefun


@deftypefun void ccsys_getsockopt (cce_location_t * @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void * @var{optval}, socklen_t * @var{optlen_ptr})
Wrapper for @cfunc{getsockopt}.
@end deftypefun


@deftypefun void ccsys_setsockopt (cce_location_t * @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void const * @var{optval}, socklen_t @var{optlen})
Wrapper for @cfunc{setsockopt}.
@end deftypefun

@c page
@node process
@chapter Process system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_system (cce_location_t * @var{L}, char const * @var{command})
Wrapper for @cfunc{system}.
@end deftypefun


@deftypefun void ccsys_exit (ccsys_exit_status_t @var{status})
Wrapper for @cfunc{exit}.
@end deftypefun


@deftypefun pid_t ccsys_fork (cce_location_t * @var{L})
Wrapper for @cfunc{fork}.
@end deftypefun


@deftypefun void ccsys_execv (cce_location_t * @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execv}.
@end deftypefun


@deftypefun void ccsys_execve (cce_location_t * @var{L}, char const * @var{filename}, char * const @var{argv} [], char * const @var{env} [])
Wrapper for @cfunc{execve}.
@end deftypefun


@deftypefun void ccsys_execvp (cce_location_t * @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execvp}.
@end deftypefun


@deftypefun void ccsys_waitpid (cce_location_t * @var{L}, pid_t @var{pid}, ccsys_waitpid_status_t * @var{wstatus}, ccsys_waitpid_options_t @var{options})
Wrapper for @cfunc{waitpid}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

