\input texinfo.tex
@c %**start of header
@setfilename ccsys.info
@settitle CCSys
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSys

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSys

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsys

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a standard C11 language library;
it implements adapters for @posix{} system functions to convert the error reporting mechanism to the
use of the library CCExceptions.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsys: (ccsys).               System functions wrappers for CCExceptions.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* semantic::                    Semantic types.
* enums::                       Enumerated constants.
* memory::                      Memory allocation, locking, mapping.
* io::                          Input/output system calls.
* fs::                          File system system calls.
* sockets::                     Socket system calls.
* process::                     Process system calls.
* time::                        Time handling.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library; it
implements adapters for @posix{} functions to convert the error reporting mechanism to the use of
the library CCExceptions.  The library supports some @gnu{} C Library functions and some Linux
functions.

@value{PACKAGE} installs a single header file @file{ccsys.h}.  All the function names in the @api{}
are prefixed with @code{ccsys_}; all the preprocessor symbol names are prefixed with @code{CCSYS_};
all the type names are prefixed with @code{ccsys_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
* overview api::                Programming interface.
* overview constants::          How system constants are handled.
* overview arguments::          How system call arguments and return
                                values are handled.
* overview structures::         How system structures are handled.
@end menu

@c page
@node overview linking
@section Linking code with the library


@subsubheading Using the @gnu{} Autotools

This package installs a data file for @command{pkg-config}; when searching for the installed library
with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSYS],[ccsys >= 0.1])
@end example

@noindent
which will set the variables @code{CCSYS_LIBS} and @code{CCSYS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccsys],[ccsys_version_string],,
  [AC_MSG_FAILURE([test for CCSys library failed])])
AC_CHECK_HEADERS([ccsys.h],,
  [AC_MSG_FAILURE([test for CCSys header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language.

@c ------------------------------------------------------------------------

@subsubheading One--shot compilation, Unix command line

For the one--shot compilation of a file named @file{demo.c}, we can do:

@example
gcc -std=c11 -Wall \
   `pkg-config ccsys --cflags` \
   `pkg-config ccsys --libs` \
   -o demo demo.c
@end example

@c page
@node overview api
@section Programming interface


@value{PACKAGE} defines function wrappers for the most common @posix{}, @gnu{} C Library and Linux
system calls.  Each wrapper accepts a pointer to @objtype{cce_location_t} as argument and, in case
of error, it will perform a non--local exit by jumping to the selected location.

Each wrapper function accepts the same arguments of the system call and returns the same return
value of the system call (if it completes successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

The library assumes to run on a @posix{} system, so the @posix{} system calls are available by
default.  The @gnu{} C Library and Linux calls are available only if the package was configured
with, respectively, @option{--enable-glibc} and @option{--enable-linux}.  If a system call is not
available: the associated wrapper will raise an exception of type
@objtype{cce_condition_unimplemented_t}.

@c page
@node overview constants
@section How system constants are handled


On a @posix{} platform, the system header files define a number of preprocessor symbols that expand
into constants; such constants are used to configure the behaviour of specific system function
calls.  @value{PACKAGE} is written in such a way that no system header file is included in the
package's header @file{ccsys.h}, so every constant definition is duplicated in the package's header.

All the constants are redefined as enumerated values, with the same system name prefixed with
@code{CCSYS_}.  For example, the file mode constants @code{O_RDONLY}, @code{O_WRONLY}, @code{O_RDWR}
are redefined with the following enumeration:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_WRONLY=1,
  CCSYS_O_RDWR=2,
  ...
@};

typedef enum ccsys_open_flags_enum_t ccsys_open_flags_enum_t;
@end example

@noindent
in which the constant values @samp{0}, @samp{1}, @samp{2} are the result of system inspection at
package configuration time.

If a symbol is not defined by the underlying platform, @value{PACKAGE} omits its redefinition.  For
example, in the unlikely case that the underlying platform does not define @code{O_WRONLY}, the
above redefinition would be:

@example
enum ccsys_open_flags_enum_t @{
  CCSYS_O_RDONLY=0,
  CCSYS_O_RDWR=2,
  ...
@};
@end example

@noindent
with @code{CCSYS_O_WRONLY} missing.

@c page
@node overview arguments
@section How system call arguments and return values are handled


@value{PACKAGE} attempts to implement strong typing for system call arguments with a specific
meaning.  For example, arguments like @var{flags} and @var{mode} in @cfunc{open} are both defined as
@code{int} by @posix{} but @value{PACKAGE} considers them as having semantic value, so they have
their type definition; the original system call has the prototype:

@example
int open(const char *pathname, int flags, mode_t mode);
@end example

@noindent
while the @value{PACKAGE} wrapper has the prototype:

@example
ccsys_fd_t ccsys_open (cce_location_t * L, char const * filename,
   ccsys_open_flags_t flags, ccsys_open_mode_t mode);
@end example

@noindent
both arguments and return values have a @dfn{semantic type}.

The argument and return value semantic types defined by @value{PACKAGE}, are @code{struct} type
definitions with a single field named @samp{data}; for example, here are possible definitions for
@cfunc{ccsys_open}:

@example
typedef struct ccsys_fd_t               ccsys_fd_t;
typedef struct ccsys_open_flags_t       ccsys_open_flags_t;
typedef struct ccsys_open_mode_t        ccsys_open_mode_t;

struct ccsys_fd_t               @{ int data; @};
struct ccsys_open_flags_t       @{ int data; @};
struct ccsys_open_mode_t        @{ int32_t data; @};
@end example

@noindent
when appropriate, the type of the field @samp{data} is determined at package configuration time.

@c page
@node overview structures
@section How system structures are handled


On a @posix{} platform, the system header files define a number of data structures used to exchange
values with the system itself.  @value{PACKAGE} is written in such a way that no system header file
is included in the package's header @file{ccsys.h}, so every data structure definition is duplicated
in the package's header.

Every duplicated data structure is defined as an opaque type in @file{ccsys.h}.  For example, here
is a possible redefinition for @code{struct stat}:

@example
typedef struct ccsys_stat_t     ccsys_stat_t;

struct ccsys_stat_t @{ uint8_t data[144]; @};
@end example

@noindent
for each public field in the structure, there may be a getter and a setter functions, for example
for the @code{st_dev} field:

@example
ccsys_dev_t ccsys_ref_stat_st_dev (ccsys_stat_t const * S)
void ccsys_set_stat_st_dev (ccsys_stat_t const * S, ccsys_dev_t F)
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsys_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccsys_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsys_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccsys_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node semantic
@chapter Semantic types


Semantic types are data structure type definitions; the @code{struct} has a single field named
@code{data}.  They are used by @value{PACKAGE} to enforce strong typing on function arguments and
return values.

@menu
* semantic typedefs::           Semantic type definitions.
* semantic macros::             Semantic type macros.
@end menu

@c page
@node semantic typedefs
@section Semantic type definitions


@anchor{ccsys_fd_t}
@deftp {Semantic Type} ccsys_fd_t
Type of file descriptors.  It is a singed integer.
@end deftp


@anchor{ccsys_dirfd_t}
@deftp {Semantic Type} ccsys_dirfd_t
Type of file descriptors for directories.  It is a singed integer.
@end deftp


@anchor{ccsys_off_t}
@deftp {Semantic Type} ccsys_off_t
Type of offsets.  It is a signed integer.
@end deftp


@anchor{ccsys_fd_flags_t}
@deftp {Semantic Type} ccsys_fd_flags_t
Type of arguments for some file descriptor functions.  It is a signed integer.  It is meant to be a
bitwise combination of the enumerated constants of type @objtype{ccsys_fd_flags_enum_t};
@ref{ccsys_fd_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_whence_t}
@deftp {Semantic Type} ccsys_whence_t
Type of @var{whence} arguments for file seek functions.  It is a signed integer.  It is meant to be
one of the enumerated constants of type @objtype{ccsys_whence_enum_t}; @ref{ccsys_whence_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_scatter_gather_flags_t}
@deftp {Semantic Type} ccsys_scatter_gather_flags_t
Type of @var{flags} arguments for some scatter/gather file input/output functions.  It is a signed
integer.  It is meant to be a bitwise combination of the enumerated constants of type
@objtype{ccsys_scatter_gather_flags_enum_t}; @ref{ccsys_scatter_gather_flags_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_open_flags_t}
@deftp {Semantic Type} ccsys_open_flags_t
Exact signed integer representing file open flags.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_flags_enum_t}; @ref{ccsys_open_flags_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_open_mode_t}
@deftp {Semantic Type} ccsys_open_mode_t
Exact signed integer representing file open modes.  It is meant to be a bitwise combination of the
enumerated constants of type @objtype{ccsys_open_mode_enum_t}; @ref{ccsys_open_mode_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_unlinkat_flags_t}
@deftp {Semantic Type} ccsys_unlinkat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_unlinkat}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_unlinkat_flags_enum_t}.
@ref{ccsys_unlinkat_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_fstatat_flags_t}
@deftp {Semantic Type} ccsys_fstatat_flags_t
Exact signed integer representing the flags for @cfunc{ccsys_fstatat}.  It is meant to be a bitwise
combination of the enumerated constants of type @objtype{ccsys_fstatat_flags_enum_t}.
@ref{ccsys_fstatat_flags_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_namespace_t}
@deftp {Semantic Type} ccsys_socket_namespace_t
Exact signed integer representing a socket namespace (or domain).  It is the of the argument
@var{namespace} or @var{domain} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_namespace_enum_t}; @ref{ccsys_socket_namespace_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_style_t}
@deftp {Semantic Type} ccsys_socket_style_t
Exact signed integer representing a socket style (or type).  It is the of the argument @var{style}
or @var{type} of @cfunc{ccsys_socket}: one of the constants of type
@objtype{ccsys_socket_style_enum_t}; @ref{ccsys_socket_style_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_socket_protocol_t}
@deftp {Semantic Type} ccsys_socket_protocol_t
Exact signed integer representing a socket protocol.  It is the of the argument @var{protocol} of
@cfunc{ccsys_socket}: one of the constants of type @objtype{ccsys_socket_protocol_enum_t};
@ref{ccsys_socket_protocol_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mlockall_flags_t}
@deftp {Semantic Type} ccsys_mlockall_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mlockall}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_locking_enum_t}; @ref{ccsys_memory_locking_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_prot_t}
@deftp {Semantic Type} ccsys_mmap_prot_t
Type of the argument @var{prot} in @cfunc{ccsys_mmap} and in @cfunc{ccsys_mprotect}.  It is meant to
be a bitwise combination of the constants of type @objtype{ccsys_memory_protection_enum_t};
@ref{ccsys_memory_protection_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_mmap_flags_t}
@deftp {Semantic Type} ccsys_mmap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mmap}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_mapping_enum_t}; @ref{ccsys_memory_mapping_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_msync_flags_t}
@deftp {Semantic Type} ccsys_msync_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_msync}.  It is meant to be a bitwise combination of
the constants of type @objtype{ccsys_memory_sync_enum_t}; @ref{ccsys_memory_sync_enum_t, Enumerated
constants}.
@end deftp


@anchor{ccsys_mremap_flags_t}
@deftp {Semantic Type} ccsys_mremap_flags_t
Type of the argument @var{flags} in @cfunc{ccsys_mremap}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_remap_enum_t}; @ref{ccsys_memory_remap_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_madvise_advice_t}
@deftp {Semantic Type} ccsys_madvise_advice_t
Type of the argument @var{advice} in @cfunc{ccsys_advise}.  It is meant to be a bitwise combination
of the constants of type @objtype{ccsys_memory_advice_enum_t}; @ref{ccsys_memory_advice_enum_t,
Enumerated constants}.
@end deftp


@anchor{ccsys_exit_status_t}
@deftp {Semantic Type} ccsys_exit_status_t
Type of the argument @var{status} in @cfunc{ccsys_exit}.  It is meant to be one of the constants of
type @objtype{ccsys_exit_status_enum_t}; @ref{ccsys_exit_status_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_waitpid_status_t}
@deftp {Semantic Type} ccsys_waitpid_status_t
Type of the argument @var{wstatus} in @cfunc{ccsys_waitpid}.
@end deftp


@anchor{ccsys_waitpid_options_t}
@deftp {Semantic Type} ccsys_waitpid_options_t
Type of the argument @var{options} in @cfunc{ccsys_waitpid}.  It is meant to be a bitwise
combination of the constants of type @objtype{ccsys_waitpid_options_enum_t};
@ref{ccsys_waitpid_options_enum_t, Enumerated constants}.
@end deftp


@anchor{ccsys_sygnum_t}
@deftp {Semantic Type} ccsys_signum_t
Type of exact integers representing interprocess signal numbers.  It is meant to be one of the
constants of type @objtype{ccsys_signum_enum_t}; @ref{ccsys_signum_enum_t, Enumerated constants}.
@end deftp

@c page
@node semantic macros
@section Semantic type macros


@deftypefn {Preprocessor Macro} {int} ccsys_dref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{int}.  Expand into:

@example
((int)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {unsigned int} ccsys_udref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{unsigned int}.
Expand into:

@example
((unsigned int)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {long} ccsys_dref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{long}.  Expand into:

@example
((long)((@var{D}).data))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {unsigned long} ccsys_udref (struct @var{D})
Helper macro that extracts a value from a semantic type and casts it to an @code{unsigned long}.
Expand into:

@example
((unsigned long) ((@var{D}).data))
@end example
@end deftypefn

@c page
@node enums
@chapter Enumerated constants


The following symbols are defined in the header file @file{ccsys.h}.


@EnumeratedConstant{CCSYS_PATH_MAX}
@anchor{ccsys_limits_enum_t}
@deftp {Enum Typedef} ccsys_limits_enum_t
Platform limits constants.  It defines the following constants:

@example
CCSYS_PATH_MAX
@end example
@end deftp


@EnumeratedConstant{CCSYS_EXIT_SUCCESS}
@EnumeratedConstant{CCSYS_EXIT_FAILURE}
@anchor{ccsys_exit_status_enum_t}
@deftp {Enum Typedef} ccsys_exit_status_enum_t
Exit statuses for @cfunc{ccsys_exit}.  It defines the following constants:

@example
CCSYS_EXIT_SUCCESS
CCSYS_EXIT_FAILURE
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_exit_status_t};
@ref{ccsys_exit_status_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_O_RDONLY}
@EnumeratedConstant{CCSYS_O_WRONLY}
@EnumeratedConstant{CCSYS_O_RDWR}
@EnumeratedConstant{CCSYS_O_APPEND}
@EnumeratedConstant{CCSYS_O_ASYNC}
@EnumeratedConstant{CCSYS_O_CLOEXEC}
@EnumeratedConstant{CCSYS_O_CREAT}
@EnumeratedConstant{CCSYS_O_DIRECT}
@EnumeratedConstant{CCSYS_O_DIRECTORY}
@EnumeratedConstant{CCSYS_O_DSYNC}
@EnumeratedConstant{CCSYS_O_EXCL}
@EnumeratedConstant{CCSYS_O_LARGEFILE}
@EnumeratedConstant{CCSYS_O_NDELAY}
@EnumeratedConstant{CCSYS_O_NOATIME}
@EnumeratedConstant{CCSYS_O_NOCTTY}
@EnumeratedConstant{CCSYS_O_NOFOLLOW}
@EnumeratedConstant{CCSYS_O_NONBLOCK}
@EnumeratedConstant{CCSYS_O_PATH}
@EnumeratedConstant{CCSYS_O_SYNC}
@EnumeratedConstant{CCSYS_O_TMPFILE}
@EnumeratedConstant{CCSYS_O_TRUNC}
@anchor{ccsys_open_flags_enum_t}
@deftp {Enum Typedef} ccsys_open_flags_enum_t
Type of file open flag constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{flags} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_O_RDONLY    CCSYS_O_WRONLY    CCSYS_O_RDWR

CCSYS_O_APPEND    CCSYS_O_ASYNC     CCSYS_O_CLOEXEC
CCSYS_O_CREAT     CCSYS_O_DIRECT    CCSYS_O_DIRECTORY
CCSYS_O_DSYNC     CCSYS_O_EXCL      CCSYS_O_LARGEFILE
CCSYS_O_NDELAY    CCSYS_O_NOATIME   CCSYS_O_NOCTTY
CCSYS_O_NOFOLLOW  CCSYS_O_NONBLOCK  CCSYS_O_PATH
CCSYS_O_SYNC      CCSYS_O_TMPFILE   CCSYS_O_TRUNC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_flags_t}; @ref{ccsys_open_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_S_IRUSR}
@EnumeratedConstant{CCSYS_S_IWUSR}
@EnumeratedConstant{CCSYS_S_IXUSR}
@EnumeratedConstant{CCSYS_S_IRGRP}
@EnumeratedConstant{CCSYS_S_IWGRP}
@EnumeratedConstant{CCSYS_S_IXGRP}
@EnumeratedConstant{CCSYS_S_IROTH}
@EnumeratedConstant{CCSYS_S_IWOTH}
@EnumeratedConstant{CCSYS_S_IXOTH}
@EnumeratedConstant{CCSYS_S_IRWXU}
@EnumeratedConstant{CCSYS_S_IRWXG}
@EnumeratedConstant{CCSYS_S_IRWXO}
@EnumeratedConstant{CCSYS_S_ISUID}
@EnumeratedConstant{CCSYS_S_ISGID}
@EnumeratedConstant{CCSYS_S_ISVTX}
@anchor{ccsys_open_mode_enum_t}
@deftp {Enum Typedef} ccsys_open_mode_enum_t
Type of file open mode constants.  These constants are meant to be combined bitwise, for example to
produce a value for the argument @var{mode} for @cfunc{ccsys_open}.  It defines the following
constants:

@example
CCSYS_S_IRUSR   CCSYS_S_IWUSR   CCSYS_S_IXUSR
CCSYS_S_IRGRP   CCSYS_S_IWGRP   CCSYS_S_IXGRP
CCSYS_S_IROTH   CCSYS_S_IWOTH   CCSYS_S_IXOTH
CCSYS_S_IRWXU   CCSYS_S_IRWXG   CCSYS_S_IRWXO
CCSYS_S_ISUID   CCSYS_S_ISGID   CCSYS_S_ISVTX
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_open_mode_t}; @ref{ccsys_open_mode_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_FD_CLOEXEC}
@anchor{ccsys_fd_flags_enum_t}
@deftp {Enum Typedef} ccsys_fd_flags_enum_t
Type of file descriptor flags constants.  It defines the following constants:

@example
CCSYS_FD_CLOEXEC
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_fd_flags_t}; @ref{ccsys_fd_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SEEK_SET}
@EnumeratedConstant{CCSYS_SEEK_CUR}
@EnumeratedConstant{CCSYS_SEEK_END}
@anchor{ccsys_whence_enum_t}
@deftp {Enum Typedef} ccsys_whence_enum_t
Type of @var{whence} arguments to file seek functions.  It defines the following constants:

@example
CCSYS_SEEK_SET
CCSYS_SEEK_CUR
CCSYS_SEEK_END
@end example

These constants are meant to be used as value for arguments of type @objtype{ccsys_whence_t};
@ref{ccsys_whence_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_RWF_HIPRI}
@EnumeratedConstant{CCSYS_RWF_NOWAIT}
@anchor{ccsys_scatter_gather_flags_enum_t}
@deftp {Enum Typedef} ccsys_scatter_gather_flags_enum_t
Type of @var{flags} arguments to some scatter/gather file input/output functions.  It defines the
following constants:

@example
CCSYS_RWF_HIPRI
CCSYS_RWF_NOWAIT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_scatter_gather_flags_t}; @ref{ccsys_scatter_gather_flags_t, Semantic type
definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AT_REMOVEDIR}
@anchor{ccsys_unlinkat_flags_enum_t}
@deftp {Enum Typedef} ccsys_unlinkat_flags_enum_t
Type of flags for @code{at()} functions.  These constants are meant to be used, for example, as
value for the argument @var{flags} of @cfunc{ccsys_unlinkat}.  It defines the following constants:

@example
CCSYS_AT_REMOVEDIR
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_unlinkat_flags_t}; @ref{ccsys_unlinkat_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AT_EMPTY_PATH}
@EnumeratedConstant{CCSYS_AT_NO_AUTOMOUNT}
@EnumeratedConstant{CCSYS_AT_SYMLINK_NOFOLLOW}
@anchor{ccsys_fstatat_flags_enum_t}
@deftp {Enum Typedef} ccsys_fstatat_flags_enum_t
Type of flags for @code{at()} functions.  These constants are meant to be used, for example, as
value for the argument @var{flags} of @cfunc{ccsys_fstatat}.  It defines the following constants:

@example
CCSYS_AT_EMPTY_PATH
CCSYS_AT_NO_AUTOMOUNT
CCSYS_AT_SYMLINK_NOFOLLOW
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_fstatat_flags_t}; @ref{ccsys_fstatat_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SOCK_STREAM}
@EnumeratedConstant{CCSYS_SOCK_DGRAM}
@EnumeratedConstant{CCSYS_SOCK_SEQPACKET}
@EnumeratedConstant{CCSYS_SOCK_RAW}
@EnumeratedConstant{CCSYS_SOCK_RDM}
@EnumeratedConstant{CCSYS_SOCK_PACKET}
@anchor{ccsys_socket_namespace_enum_t}
@deftp {Enum Typedef} ccsys_socket_namespace_enum_t
Type of socket namespace selection constants.  These constants are meant to be used, for example, as
value for the argument @var{domain} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_DGRAM
CCSYS_SOCK_PACKET
CCSYS_SOCK_RAW
CCSYS_SOCK_RDM
CCSYS_SOCK_SEQPACKET
CCSYS_SOCK_STREAM
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_namespce_t}; @ref{ccsys_socket_namespace_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_AF_UNIX}
@EnumeratedConstant{CCSYS_AF_LOCAL}
@EnumeratedConstant{CCSYS_AF_INET}
@EnumeratedConstant{CCSYS_AF_INET6}
@EnumeratedConstant{CCSYS_AF_IPX}
@EnumeratedConstant{CCSYS_AF_NETLINK}
@EnumeratedConstant{CCSYS_AF_X25}
@EnumeratedConstant{CCSYS_AF_AX25}
@EnumeratedConstant{CCSYS_AF_ATMPVC}
@EnumeratedConstant{CCSYS_AF_APPLETALK}
@EnumeratedConstant{CCSYS_AF_PACKET}
@EnumeratedConstant{CCSYS_AF_ALG}
@anchor{ccsys_socket_style_enum_t}
@deftp {Enum Typedef} ccsys_socket_style_enum_t
Type of socket style selection constants.  These constants are meant to be used, for example, as
value for the argument @var{type} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_AF_UNIX       CCSYS_AF_LOCAL   CCSYS_AF_INET
CCSYS_AF_INET6      CCSYS_AF_IPX     CCSYS_AF_NETLINK
CCSYS_AF_X25        CCSYS_AF_AX25    CCSYS_AF_ATMPVC
CCSYS_AF_APPLETALK  CCSYS_AF_PACKET  CCSYS_AF_ALG
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_style_t}; @ref{ccsys_socket_style_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_SOCK_PROTOCOL_IP}
@anchor{ccsys_socket_protocol_enum_t}
@deftp {Enum Typedef} ccsys_socket_protocol_enum_t
Type of socket protocol selection constants.  These constants are meant to be used, for example, as
value for the argument @var{protocol} of @cfunc{ccsys_socket}.  It defines the following constants:

@example
CCSYS_SOCK_PROTOCOL_IP
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_socket_protocol_t}; @ref{ccsys_socket_protocol_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MCL_CURRENT}
@EnumeratedConstant{CCSYS_MCL_FUTURE}
@EnumeratedConstant{CCSYS_MCL_ONFAULT}
@anchor{ccsys_memory_locking_enum_t}
@deftp {Enum Typedef} ccsys_memory_locking_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mlockall}.  It defines the
following constants:

@example
CCSYS_MCL_CURRENT
CCSYS_MCL_FUTURE
CCSYS_MCL_ONFAULT
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mlockall_flags_t}; @ref{ccsys_mlockall_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_PROT_EXEC}
@EnumeratedConstant{CCSYS_PROT_READ}
@EnumeratedConstant{CCSYS_PROT_WRITE}
@EnumeratedConstant{CCSYS_PROT_NONE}
@anchor{ccsys_memory_protection_enum_t}
@deftp {Enum Typedef} ccsys_memory_protection_enum_t
Enumeration of constants for the argument @var{prot} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_PROT_EXEC
CCSYS_PROT_READ
CCSYS_PROT_WRITE
CCSYS_PROT_NONE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_prot_t}; @ref{ccsys_mmap_prot_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MAP_SHARED}
@EnumeratedConstant{CCSYS_MAP_PRIVATE}
@EnumeratedConstant{CCSYS_MAP_32BIT}
@EnumeratedConstant{CCSYS_MAP_ANON}
@EnumeratedConstant{CCSYS_MAP_ANONYMOUS}
@EnumeratedConstant{CCSYS_MAP_DENYWRITE}
@EnumeratedConstant{CCSYS_MAP_EXECUTABLE}
@EnumeratedConstant{CCSYS_MAP_FILE}
@EnumeratedConstant{CCSYS_MAP_FIXED}
@EnumeratedConstant{CCSYS_MAP_GROWSDOWN}
@EnumeratedConstant{CCSYS_MAP_HUGETLB}
@EnumeratedConstant{CCSYS_MAP_HUGE_2MB}
@EnumeratedConstant{CCSYS_MAP_HUGE_1GB}
@EnumeratedConstant{CCSYS_MAP_LOCKED}
@EnumeratedConstant{CCSYS_MAP_NONBLOCK}
@EnumeratedConstant{CCSYS_MAP_NORESERVE}
@EnumeratedConstant{CCSYS_MAP_POPULATE}
@EnumeratedConstant{CCSYS_MAP_STACK}
@EnumeratedConstant{CCSYS_MAP_UNINITIALIZED}
@EnumeratedConstant{CCSYS_MAP_AUTOGROW}
@EnumeratedConstant{CCSYS_MAP_AUTORESRV}
@EnumeratedConstant{CCSYS_MAP_COPY}
@EnumeratedConstant{CCSYS_MAP_LOCAL}
@anchor{ccsys_memory_mapping_enum_t}
@deftp {Enum Typedef} ccsys_memory_mapping_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mmap}.  It defines the
following constants:

@example
CCSYS_MAP_SHARED        CCSYS_MAP_PRIVATE     CCSYS_MAP_32BIT
CCSYS_MAP_ANON          CCSYS_MAP_ANONYMOUS   CCSYS_MAP_DENYWRITE
CCSYS_MAP_EXECUTABLE    CCSYS_MAP_FILE        CCSYS_MAP_FIXED
CCSYS_MAP_GROWSDOWN     CCSYS_MAP_HUGETLB     CCSYS_MAP_HUGE_2MB
CCSYS_MAP_HUGE_1GB      CCSYS_MAP_LOCKED      CCSYS_MAP_NONBLOCK
CCSYS_MAP_NORESERVE     CCSYS_MAP_POPULATE    CCSYS_MAP_STACK
CCSYS_MAP_UNINITIALIZED CCSYS_MAP_AUTOGROW    CCSYS_MAP_AUTORESRV
CCSYS_MAP_COPY          CCSYS_MAP_LOCAL
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mmap_flags_t}; @ref{ccsys_mmap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MS_ASYNC}
@EnumeratedConstant{CCSYS_MS_SYNC}
@EnumeratedConstant{CCSYS_MS_INVALIDATE}
@anchor{ccsys_memory_sync_enum_t}
@deftp {Enum Typedef} ccsys_memory_sync_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_msync}.  It defines the
following constants:

@example
CCSYS_MS_ASYNC
CCSYS_MS_SYNC
CCSYS_MS_INVALIDATE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_msync_flags_t}; @ref{ccsys_msync_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MREMAP_MAYMOVE}
@EnumeratedConstant{CCSYS_MREMAP_FIXED}
@anchor{ccsys_memory_remap_enum_t}
@deftp {Enum Typedef} ccsys_memory_remap_enum_t
Enumeration of constants for the argument @var{flags} in @cfunc{ccsys_mremap}.  It defines the
following constants:

@example
CCSYS_MREMAP_MAYMOVE
CCSYS_MREMAP_FIXED
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_mremap_flags_t}; @ref{ccsys_mremap_flags_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_MADV_NORMAL}
@EnumeratedConstant{CCSYS_MADV_RANDOM}
@EnumeratedConstant{CCSYS_MADV_SEQUENTIAL}
@EnumeratedConstant{CCSYS_MADV_WILLNEED}
@EnumeratedConstant{CCSYS_MADV_DONTNEED}
@EnumeratedConstant{CCSYS_MADV_REMOVE}
@EnumeratedConstant{CCSYS_MADV_DONTFORK}
@EnumeratedConstant{CCSYS_MADV_DOFORK}
@EnumeratedConstant{CCSYS_MADV_HWPOISON}
@EnumeratedConstant{CCSYS_MADV_MERGEABLE}
@EnumeratedConstant{CCSYS_MADV_UNMERGEABLE}
@EnumeratedConstant{CCSYS_MADV_SOFT_OFFLINE}
@EnumeratedConstant{CCSYS_MADV_HUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_NOHUGEPAGE}
@EnumeratedConstant{CCSYS_MADV_DONTDUMP}
@EnumeratedConstant{CCSYS_MADV_DODUMP}
@EnumeratedConstant{CCSYS_MADV_FREE}
@anchor{ccsys_memory_advice_enum_t}
@deftp {Enum Typedef} ccsys_memory_advice_enum_t
Enumeration of constants for the argument @var{advice} in @cfunc{ccsys_madvise}.  It defines the
following constants:

@example
CCSYS_MADV_NORMAL       CCSYS_MADV_RANDOM       CCSYS_MADV_SEQUENTIAL
CCSYS_MADV_WILLNEED     CCSYS_MADV_DONTNEED     CCSYS_MADV_REMOVE
CCSYS_MADV_DONTFORK     CCSYS_MADV_DOFORK       CCSYS_MADV_HWPOISON
CCSYS_MADV_MERGEABLE    CCSYS_MADV_UNMERGEABLE  CCSYS_MADV_SOFT_OFFLINE
CCSYS_MADV_HUGEPAGE     CCSYS_MADV_NOHUGEPAGE   CCSYS_MADV_DONTDUMP
CCSYS_MADV_DODUMP       CCSYS_MADV_FREE
@end example

A bitwise combination of these constants is meant to be used as value for arguments of type
@objtype{ccsys_madvise_advice_t}; @ref{ccsys_madvise_advice_t, Semantic type definitions}.
@end deftp


@EnumeratedConstant{CCSYS_WNOHANG}
@EnumeratedConstant{CCSYS_WUNTRACED}
@EnumeratedConstant{CCSYS_WCONTINUED}
@anchor{ccsys_waitpid_options_enum_t}
@deftp {Enum Typedef} ccsys_waitpid_options_enum_t
Enumeration of constants representing process wait options.  It defines the following constants:

@example
CCSYS_WNOHANG
CCSYS_WUNTRACED
CCSYS_WCONTINUED
@end example
@end deftp


@EnumeratedConstant{CCSYS_EPERM}
@EnumeratedConstant{CCSYS_ENOENT}
@EnumeratedConstant{CCSYS_ESRCH}
@EnumeratedConstant{CCSYS_EINTR}
@EnumeratedConstant{CCSYS_EIO}
@EnumeratedConstant{CCSYS_ENXIO}
@EnumeratedConstant{CCSYS_E2BIG}
@EnumeratedConstant{CCSYS_ENOEXEC}
@EnumeratedConstant{CCSYS_EBADF}
@EnumeratedConstant{CCSYS_ECHILD}
@EnumeratedConstant{CCSYS_EPROCLIM}
@EnumeratedConstant{CCSYS_EAGAIN}
@EnumeratedConstant{CCSYS_ENOMEM}
@EnumeratedConstant{CCSYS_EACCES}
@EnumeratedConstant{CCSYS_EFAULT}
@EnumeratedConstant{CCSYS_ENOTBLK}
@EnumeratedConstant{CCSYS_EBUSY}
@EnumeratedConstant{CCSYS_EEXIST}
@EnumeratedConstant{CCSYS_EXDEV}
@EnumeratedConstant{CCSYS_ENODEV}
@EnumeratedConstant{CCSYS_ENOTDIR}
@EnumeratedConstant{CCSYS_EISDIR}
@EnumeratedConstant{CCSYS_EINVAL}
@EnumeratedConstant{CCSYS_ENFILE}
@EnumeratedConstant{CCSYS_EMFILE}
@EnumeratedConstant{CCSYS_ENOTTY}
@EnumeratedConstant{CCSYS_ETXTBSY}
@EnumeratedConstant{CCSYS_EFBIG}
@EnumeratedConstant{CCSYS_ENOSPC}
@EnumeratedConstant{CCSYS_ESPIPE}
@EnumeratedConstant{CCSYS_EROFS}
@EnumeratedConstant{CCSYS_EMLINK}
@EnumeratedConstant{CCSYS_EPIPE}
@EnumeratedConstant{CCSYS_EDOM}
@EnumeratedConstant{CCSYS_ERANGE}
@EnumeratedConstant{CCSYS_EDEADLK}
@EnumeratedConstant{CCSYS_ENAMETOOLONG}
@EnumeratedConstant{CCSYS_ENOLCK}
@EnumeratedConstant{CCSYS_ENOSYS}
@EnumeratedConstant{CCSYS_ENOTEMPTY}
@EnumeratedConstant{CCSYS_ELOOP}
@EnumeratedConstant{CCSYS_EWOULDBLOCK}
@EnumeratedConstant{CCSYS_ENOMSG}
@EnumeratedConstant{CCSYS_EIDRM}
@EnumeratedConstant{CCSYS_ECHRNG}
@EnumeratedConstant{CCSYS_EL2NSYNC}
@EnumeratedConstant{CCSYS_EL3HLT}
@EnumeratedConstant{CCSYS_EL3RST}
@EnumeratedConstant{CCSYS_ELNRNG}
@EnumeratedConstant{CCSYS_EUNATCH}
@EnumeratedConstant{CCSYS_ENOCSI}
@EnumeratedConstant{CCSYS_EL2HLT}
@EnumeratedConstant{CCSYS_EBADE}
@EnumeratedConstant{CCSYS_EBADR}
@EnumeratedConstant{CCSYS_EXFULL}
@EnumeratedConstant{CCSYS_ENOANO}
@EnumeratedConstant{CCSYS_EBADRQC}
@EnumeratedConstant{CCSYS_EBADSLT}
@EnumeratedConstant{CCSYS_EDEADLOCK}
@EnumeratedConstant{CCSYS_EBFONT}
@EnumeratedConstant{CCSYS_ENOSTR}
@EnumeratedConstant{CCSYS_ENODATA}
@EnumeratedConstant{CCSYS_ETIME}
@EnumeratedConstant{CCSYS_ENOSR}
@EnumeratedConstant{CCSYS_ENONET}
@EnumeratedConstant{CCSYS_ENOPKG}
@EnumeratedConstant{CCSYS_EREMOTE}
@EnumeratedConstant{CCSYS_ENOLINK}
@EnumeratedConstant{CCSYS_EADV}
@EnumeratedConstant{CCSYS_ESRMNT}
@EnumeratedConstant{CCSYS_ECOMM}
@EnumeratedConstant{CCSYS_EPROTO}
@EnumeratedConstant{CCSYS_EMULTIHOP}
@EnumeratedConstant{CCSYS_EDOTDOT}
@EnumeratedConstant{CCSYS_EBADMSG}
@EnumeratedConstant{CCSYS_EOVERFLOW}
@EnumeratedConstant{CCSYS_ENOTUNIQ}
@EnumeratedConstant{CCSYS_EBADFD}
@EnumeratedConstant{CCSYS_EREMCHG}
@EnumeratedConstant{CCSYS_ELIBACC}
@EnumeratedConstant{CCSYS_ELIBBAD}
@EnumeratedConstant{CCSYS_ELIBSCN}
@EnumeratedConstant{CCSYS_ELIBMAX}
@EnumeratedConstant{CCSYS_ELIBEXEC}
@EnumeratedConstant{CCSYS_EILSEQ}
@EnumeratedConstant{CCSYS_ERESTART}
@EnumeratedConstant{CCSYS_ESTRPIPE}
@EnumeratedConstant{CCSYS_EUSERS}
@EnumeratedConstant{CCSYS_ENOTSOCK}
@EnumeratedConstant{CCSYS_EDESTADDRREQ}
@EnumeratedConstant{CCSYS_EMSGSIZE}
@EnumeratedConstant{CCSYS_EPROTOTYPE}
@EnumeratedConstant{CCSYS_ENOPROTOOPT}
@EnumeratedConstant{CCSYS_EPROTONOSUPPORT}
@EnumeratedConstant{CCSYS_ESOCKTNOSUPPORT}
@EnumeratedConstant{CCSYS_EOPNOTSUPP}
@EnumeratedConstant{CCSYS_EPFNOSUPPORT}
@EnumeratedConstant{CCSYS_EAFNOSUPPORT}
@EnumeratedConstant{CCSYS_EADDRINUSE}
@EnumeratedConstant{CCSYS_EADDRNOTAVAIL}
@EnumeratedConstant{CCSYS_ENETDOWN}
@EnumeratedConstant{CCSYS_ENETUNREACH}
@EnumeratedConstant{CCSYS_ENETRESET}
@EnumeratedConstant{CCSYS_ECONNABORTED}
@EnumeratedConstant{CCSYS_ECONNRESET}
@EnumeratedConstant{CCSYS_ENOBUFS}
@EnumeratedConstant{CCSYS_EISCONN}
@EnumeratedConstant{CCSYS_ENOTCONN}
@EnumeratedConstant{CCSYS_ESHUTDOWN}
@EnumeratedConstant{CCSYS_ETOOMANYREFS}
@EnumeratedConstant{CCSYS_ETIMEDOUT}
@EnumeratedConstant{CCSYS_ECONNREFUSED}
@EnumeratedConstant{CCSYS_EHOSTDOWN}
@EnumeratedConstant{CCSYS_EHOSTUNREACH}
@EnumeratedConstant{CCSYS_EALREADY}
@EnumeratedConstant{CCSYS_EINPROGRESS}
@EnumeratedConstant{CCSYS_ESTALE}
@EnumeratedConstant{CCSYS_EUCLEAN}
@EnumeratedConstant{CCSYS_ENOTNAM}
@EnumeratedConstant{CCSYS_ENAVAIL}
@EnumeratedConstant{CCSYS_EISNAM}
@EnumeratedConstant{CCSYS_EREMOTEIO}
@EnumeratedConstant{CCSYS_EDQUOT}
@EnumeratedConstant{CCSYS_ENOMEDIUM}
@EnumeratedConstant{CCSYS_EMEDIUMTYPE}
@EnumeratedConstant{CCSYS_ECANCELED}
@EnumeratedConstant{CCSYS_ENOKEY}
@EnumeratedConstant{CCSYS_EKEYEXPIRED}
@EnumeratedConstant{CCSYS_EKEYREVOKED}
@EnumeratedConstant{CCSYS_EKEYREJECTED}
@EnumeratedConstant{CCSYS_EOWNERDEAD}
@EnumeratedConstant{CCSYS_ENOTRECOVERABLE}
@EnumeratedConstant{CCSYS_EBADRPC}
@EnumeratedConstant{CCSYS_ERPCMISMATCH}
@EnumeratedConstant{CCSYS_EPROGUNAVAIL}
@EnumeratedConstant{CCSYS_EPROGMISMATCH}
@EnumeratedConstant{CCSYS_EPROCUNAVAIL}
@EnumeratedConstant{CCSYS_EFTYPE}
@EnumeratedConstant{CCSYS_EAUTH}
@EnumeratedConstant{CCSYS_ENEEDAUTH}
@EnumeratedConstant{CCSYS_ENOTSUP}
@EnumeratedConstant{CCSYS_EBACKGROUND}
@EnumeratedConstant{CCSYS_EDIED}
@EnumeratedConstant{CCSYS_ERFKILL}
@EnumeratedConstant{CCSYS_EHWPOISON}
@anchor{ccsys_errno_enum_t}
@deftp {Enum Typedef} ccsys_errno_enum_t
Enumeration constants representing @code{errno} codes.  It defines the following constants:

@example
CCSYS_EPERM             CCSYS_ENOENT            CCSYS_ESRCH
CCSYS_EINTR             CCSYS_EIO               CCSYS_ENXIO
CCSYS_E2BIG             CCSYS_ENOEXEC           CCSYS_EBADF
CCSYS_ECHILD            CCSYS_EPROCLIM          CCSYS_EAGAIN
CCSYS_ENOMEM            CCSYS_EACCES            CCSYS_EFAULT
CCSYS_ENOTBLK           CCSYS_EBUSY             CCSYS_EEXIST
CCSYS_EXDEV             CCSYS_ENODEV            CCSYS_ENOTDIR
CCSYS_EISDIR            CCSYS_EINVAL            CCSYS_ENFILE
CCSYS_EMFILE            CCSYS_ENOTTY            CCSYS_ETXTBSY
CCSYS_EFBIG             CCSYS_ENOSPC            CCSYS_ESPIPE
CCSYS_EROFS             CCSYS_EMLINK            CCSYS_EPIPE
CCSYS_EDOM              CCSYS_ERANGE            CCSYS_EDEADLK
CCSYS_ENAMETOOLONG      CCSYS_ENOLCK            CCSYS_ENOSYS
CCSYS_ENOTEMPTY         CCSYS_ELOOP             CCSYS_EWOULDBLOCK
CCSYS_ENOMSG            CCSYS_EIDRM             CCSYS_ECHRNG
CCSYS_EL2NSYNC          CCSYS_EL3HLT            CCSYS_EL3RST
CCSYS_ELNRNG            CCSYS_EUNATCH           CCSYS_ENOCSI
CCSYS_EL2HLT            CCSYS_EBADE             CCSYS_EBADR
CCSYS_EXFULL            CCSYS_ENOANO            CCSYS_EBADRQC
CCSYS_EBADSLT           CCSYS_EDEADLOCK         CCSYS_EBFONT
CCSYS_ENOSTR            CCSYS_ENODATA           CCSYS_ETIME
CCSYS_ENOSR             CCSYS_ENONET            CCSYS_ENOPKG
CCSYS_EREMOTE           CCSYS_ENOLINK           CCSYS_EADV
CCSYS_ESRMNT            CCSYS_ECOMM             CCSYS_EPROTO
CCSYS_EMULTIHOP         CCSYS_EDOTDOT           CCSYS_EBADMSG
CCSYS_EOVERFLOW         CCSYS_ENOTUNIQ          CCSYS_EBADFD
CCSYS_EREMCHG           CCSYS_ELIBACC           CCSYS_ELIBBAD
CCSYS_ELIBSCN           CCSYS_ELIBMAX           CCSYS_ELIBEXEC
CCSYS_EILSEQ            CCSYS_ERESTART          CCSYS_ESTRPIPE
CCSYS_EUSERS            CCSYS_ENOTSOCK          CCSYS_EDESTADDRREQ
CCSYS_EMSGSIZE          CCSYS_EPROTOTYPE        CCSYS_ENOPROTOOPT
CCSYS_EPROTONOSUPPORT   CCSYS_ESOCKTNOSUPPORT   CCSYS_EOPNOTSUPP
CCSYS_EPFNOSUPPORT      CCSYS_EAFNOSUPPORT      CCSYS_EADDRINUSE
CCSYS_EADDRNOTAVAIL     CCSYS_ENETDOWN          CCSYS_ENETUNREACH
CCSYS_ENETRESET         CCSYS_ECONNABORTED      CCSYS_ECONNRESET
CCSYS_ENOBUFS           CCSYS_EISCONN           CCSYS_ENOTCONN
CCSYS_ESHUTDOWN         CCSYS_ETOOMANYREFS      CCSYS_ETIMEDOUT
CCSYS_ECONNREFUSED      CCSYS_EHOSTDOWN         CCSYS_EHOSTUNREACH
CCSYS_EALREADY          CCSYS_EINPROGRESS       CCSYS_ESTALE
CCSYS_EUCLEAN           CCSYS_ENOTNAM           CCSYS_ENAVAIL
CCSYS_EISNAM            CCSYS_EREMOTEIO         CCSYS_EDQUOT
CCSYS_ENOMEDIUM         CCSYS_EMEDIUMTYPE       CCSYS_ECANCELED
CCSYS_ENOKEY            CCSYS_EKEYEXPIRED       CCSYS_EKEYREVOKED
CCSYS_EKEYREJECTED      CCSYS_EOWNERDEAD        CCSYS_ENOTRECOVERABLE
CCSYS_EBADRPC           CCSYS_ERPCMISMATCH      CCSYS_EPROGUNAVAIL
CCSYS_EPROGMISMATCH     CCSYS_EPROCUNAVAIL      CCSYS_EFTYPE
CCSYS_EAUTH             CCSYS_ENEEDAUTH         CCSYS_ENOTSUP
CCSYS_EBACKGROUND       CCSYS_EDIED             CCSYS_ERFKILL
CCSYS_EHWPOISON
@end example
@end deftp


@EnumeratedConstant{CCSYS_SIGABRT}
@EnumeratedConstant{CCSYS_SIGALRM}
@EnumeratedConstant{CCSYS_SIGBUS}
@EnumeratedConstant{CCSYS_SIGCHLD}
@EnumeratedConstant{CCSYS_SIGCLD}
@EnumeratedConstant{CCSYS_SIGCONT}
@EnumeratedConstant{CCSYS_SIGEMT}
@EnumeratedConstant{CCSYS_SIGFPE}
@EnumeratedConstant{CCSYS_SIGHUP}
@EnumeratedConstant{CCSYS_SIGILL}
@EnumeratedConstant{CCSYS_SIGINFO}
@EnumeratedConstant{CCSYS_SIGINT}
@EnumeratedConstant{CCSYS_SIGIO}
@EnumeratedConstant{CCSYS_SIGIOT}
@EnumeratedConstant{CCSYS_SIGKILL}
@EnumeratedConstant{CCSYS_SIGLOST}
@EnumeratedConstant{CCSYS_SIGPIPE}
@EnumeratedConstant{CCSYS_SIGPOLL}
@EnumeratedConstant{CCSYS_SIGPROF}
@EnumeratedConstant{CCSYS_SIGQUIT}
@EnumeratedConstant{CCSYS_SIGSEGV}
@EnumeratedConstant{CCSYS_SIGSTOP}
@EnumeratedConstant{CCSYS_SIGSYS}
@EnumeratedConstant{CCSYS_SIGTERM}
@EnumeratedConstant{CCSYS_SIGTRAP}
@EnumeratedConstant{CCSYS_SIGTSTP}
@EnumeratedConstant{CCSYS_SIGTTIN}
@EnumeratedConstant{CCSYS_SIGTTOU}
@EnumeratedConstant{CCSYS_SIGURG}
@EnumeratedConstant{CCSYS_SIGUSR1}
@EnumeratedConstant{CCSYS_SIGUSR2}
@EnumeratedConstant{CCSYS_SIGVRALRM}
@EnumeratedConstant{CCSYS_SIGWINCH}
@EnumeratedConstant{CCSYS_SIGXCPU}
@EnumeratedConstant{CCSYS_SIGXSFZ}
@EnumeratedConstant{CCSYS_NSIG}
@anchor{ccsys_signum_enum_t}
@deftp {Enum Typedef} ccsys_signum_enum_t
Interprocess signal numbers.  It defines the following constants:

@example
CCSYS_SIGABRT           CCSYS_SIGALRM           CCSYS_SIGBUS
CCSYS_SIGCHLD           CCSYS_SIGCLD            CCSYS_SIGCONT
CCSYS_SIGEMT            CCSYS_SIGFPE            CCSYS_SIGHUP
CCSYS_SIGILL            CCSYS_SIGINFO           CCSYS_SIGINT
CCSYS_SIGIO             CCSYS_SIGIOT            CCSYS_SIGKILL
CCSYS_SIGLOST           CCSYS_SIGPIPE           CCSYS_SIGPOLL
CCSYS_SIGPROF           CCSYS_SIGQUIT           CCSYS_SIGSEGV
CCSYS_SIGSTOP           CCSYS_SIGSYS            CCSYS_SIGTERM
CCSYS_SIGTRAP           CCSYS_SIGTSTP           CCSYS_SIGTTIN
CCSYS_SIGTTOU           CCSYS_SIGURG            CCSYS_SIGUSR1
CCSYS_SIGUSR2           CCSYS_SIGVRALRM         CCSYS_SIGWINCH
CCSYS_SIGXCPU           CCSYS_SIGXSFZ
CCSYS_NSIG
@end example
@end deftp

@c page
@node memory
@chapter Memory allocation, locking, mapping

@menu
* memory basic::                Basic memory allocation.
* memory handler::              Basic memory handling.
* memory gmalloc::              Guarded allocation: @cfunc{malloc}.
* memory gcalloc::              Guarded allocation: @cfunc{calloc}.
* memory grealloc::             Guarded allocation: @cfunc{realloc}.
* memory locking::              Locking memory pages.
* memory mapping::              Memory mapping system calls.
@end menu

@c page
@node memory basic
@section Basic memory allocation


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc (cce_destination_t @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_realloc (cce_destination_t @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccsys_calloc (cce_destination_t @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun void ccsys_free (cce_destination_t @var{L}, void * @var{ptr})
This is a plain wrapper for @cfunc{free}.  At present the argument @var{L} is unused.  This function
exists so that we can access this function by only including the header file @file{ccsys.h} and not
including the system header @file{stdlib.h}.
@end deftypefun

@c page
@node memory handler
@section Basic memory handling


We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *        P = ccsys_malloc(L, 4096);
  ccsys_cleanup_handler_malloc_init(L, P_H, P);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void ccsys_error_handler_malloc_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_malloc_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{P})
@deftypefnx {Preprocessor Macro} void ccsys_handler_malloc_init (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_malloc_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_malloc_init}.
@end table
@end deftypefn

@c page
@node memory gmalloc
@section Guarded allocation: @cfunc{malloc}


To allocate memory using a cleanup handler with a guarded function, we can do:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
while to use an error handler we can do:

@example
cce_location_t          L[1];
cce_error_handler_t     P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  void *  P = ccsys_malloc_guarded(L, P_H, 1024);

  /* Do something with P. */
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_malloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_malloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
Like @cfunc{ccsys_malloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{size})
@deftypefnx {Preprocessor Macro} {void *} ccsys_malloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{size})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory gcalloc
@section Guarded allocation: @cfunc{calloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_calloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefun {void *} ccsys_calloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Like @cfunc{ccsys_calloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_calloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory grealloc
@section Guarded allocation: @cfunc{realloc}


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_realloc_guarded_cleanup (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefun {void *} ccsys_realloc_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
Like @cfunc{ccsys_realloc}, but register the resulting pointer in the handler referenced by
@var{P_H}.  The handler is updated to reference the new memory pointer.  If, upon entering this
function, the handler @var{P_H} does not reference the pointer @var{old_P}: raise an exception by
performing a non--local exit to @var{L}, with condition object of type
@objtype{cce_condition_invalid_argument_t}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
@deftypefnx {Preprocessor Macro} {void *} ccsys_realloc_guarded (cce_destination_t @var{L}, cce_error_handler_t * @var{P_H}, void * @var{old_P}, size_t @var{newsize})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{P_H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_cleanup}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node memory locking
@section Locking memory pages


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mlock (cce_destination_t @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{mlock}.
@end deftypefun


@deftypefun void ccsys_munlock (cce_destination_t @var{L}, void const * @var{addr}, size_t @var{len})
Wrapper for @cfunc{munlock}.
@end deftypefun


@deftypefun void ccsys_mlockall (cce_destination_t @var{L}, ccsys_mlockall_flags_t @var{flags})
Wrapper for @cfunc{mlockall}.  The argument @var{flags} is meant to be a bitwise combination of the
constants of type @objtype{ccsys_memory_locking_enum_t}.
@end deftypefun


@deftypefun void ccsys_munlockall (cce_location_t * @var{L})
Wrapper for @cfunc{munlockall}.
@end deftypefun

@c page
@node memory mapping
@section Memory mapping system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {void *} ccsys_mmap (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_mmap_prot_t @var{prot}, ccsys_mmap_flags_t @var{flags}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset})
Wrapper for @cfunc{mmap}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_mapping_enum_t}.
@end deftypefun


@deftypefun int ccsys_munmap (cce_destination_t @var{L}, void * @var{addr}, size_t @var{length})
Wrapper for @cfunc{munmap}.
@end deftypefun


@deftypefun int ccsys_msync (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_msync_flags_t @var{flags})
Wrapper for @cfunc{msync}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_sync_enum_t}.
@end deftypefun


@deftypefun int ccsys_mprotect (cce_destination_t @var{L}, void * @var{addr}, size_t @var{len}, ccsys_mmap_prot_t @var{prot})
Wrapper for @cfunc{mprotect}.

The argument @var{prot} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_protection_enum_t}.
@end deftypefun


@deftypefun {void *} ccsys_mremap (cce_destination_t @var{L}, void * @var{old_address}, size_t @var{length}, size_t @var{new_length}, ccsys_mremap_flags_t @var{flags}, void * @var{new_address})
Wrapper for @cfunc{mremap}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_remap_enum_t}.

@quotation
@strong{NOTE}  This function is specific to Linux platforms.
@end quotation
@end deftypefun


@deftypefun void ccsys_madvise (cce_destination_t @var{L}, void * @var{address}, size_t @var{length}, ccsys_madvise_advice_t @var{advice})
Wrapper for @cfunc{madvise}.

The argument @var{advice} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_memory_advice_enum_t}.

@quotation
@strong{NOTE}  This function is implemented by the @gnu{} C Library.
@end quotation
@end deftypefun

@c page
@node io
@chapter Input/output system calls


@menu
* io constants::                Global constants.
* io fds::                      File descriptor helpers.
* io open::                     Opening files.
* io pipes::                    Creating pipes.
* io fifos::                    Creating FIFOs.
* io close::                    Closing file descriptors.
* io read write::               Reading and writing files.
* io scatter gather::           Scatter-gather input/output.
* io dup::                      Duplicating file descriptors.
* io select::                   Waiting for input/output.
* io sync::                     Committing file system caches to disk.
@end menu

@c page
@node io constants
@section Global constants


@cindex Standard file descriptors
@cindex File descriptors, standard


The following symbols are defined in the header file @file{ccsys.h}.


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDIN
Constant representing the standard input file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDOUT
Constant representing the standard output file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_STDERR
Constant representing the standard error file descriptor.
@end deftypevr


@deftypevr Constant {ccsys_fd_t const} CCSYS_FD_SETSIZE
Constant representing the maximum value for the argument @var{nfds} to @cfunc{ccsys_select}.
@end deftypevr

@c page
@node io fds
@section File descriptor helpers


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun bool ccsys_fd_equal (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return @true{} if the arguments are equal, otherwise return @false{}.  We can also perform this
operation using the @code{=} operator.
@end deftypefun


@deftypefun bool ccsys_fd_less_than (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_less_than_or_equal_to (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_greater_than (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx bool ccsys_fd_greater_than_or_equal_to (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return @true{} if the @vari{fd} with respect to @varii{fd} is: less than, less than or equal to,
greater than, greater than or equal to; otherwise return @false{}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_fd_min (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
@deftypefunx ccsys_fd_t ccsys_fd_max (ccsys_fd_t @vari{fd}, ccsys_fd_t @varii{fd})
Return the minimum or maximum between the arguments.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_fd_incr (ccsys_fd_t @var{fd})
Increment the file descriptor in @var{fd} and return the result.  This function is useful to
generate the first argument to @cfunc{ccsys_select}; @ref{io select, ccsys_select} for details.
@end deftypefun


@c page
@node io open
@section Opening files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_open (cce_destination_t @var{L}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{open}.  @manpage{open, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_openat (cce_destination_t @var{L}, ccsys_dirfd_t @var{filedes}, char const * @var{filename}, ccsys_open_flags_t @var{flags}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{openat}.  @manpage{openat, Open and possibly create a file}.

The argument @var{flags} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_flags_enum_t}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


We can use  @cfunc{ccsys_openat} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dir_H[1];
cce_cleanup_handler_t   dirstream_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  static char const * dirname  = "dir.d";
  static char const * filename = "name.ext";
  ccsys_dirfd_t       dirfd;

  /* Create the directory. */
  @{
    ccsys_open_mode_t   mode;

    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdir(L, dirname, mode);
    ccsys_handler_rmdir_init(L, dir_H, dirname);
  @}

  /* Open the directory.  The descriptor in "dirfd" is released
     automatically when "dirstream" is released. */
  @{
    ccsys_dir_t *     dirstream;

    dirstream = ccsys_opendir(L, dirname);
    ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
    dirfd = ccsys_dirfd(L, dirstream);
  @}

  /* Open the file. */
  @{
    ccsys_open_flags_t    flags;
    ccsys_open_mode_t     mode;
    ccsys_fd_t            fd;

    flags.data = CCSYS_O_CREAT;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_openat(L, dirfd, filename, flags, mode);
    ccsys_handler_filedes_init(L, file_H, fd);

    /* Do something with "fd" here. */
  @}

  /* Remove the file. */
  @{
    ccsys_unlinkat_flags_t flags;

    flags.data = 0;
    ccsys_unlinkat(L, dirfd, filename, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io pipes
@section Creating pipes


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_pipe (cce_destination_t @var{L}, ccsys_fd_t @var{pipefd}[2])
Wrapper for @cfunc{pipe}.  @manpage{pipe, Create pipes}.
@end deftypefun


@deftypefun void ccsys_pipe2 (cce_destination_t @var{L}, ccsys_fd_t @var{pipefd}[2], ccsys_open_flags_t @var{flags})
Wrapper for @cfunc{pipe2}.  @manpage{pipe2, Create pipes}.
@end deftypefun

@menu
* io pipes handlers::           Pipes cleanup and error handlers.
* io pipes one::                Using @cfunc{ccsys_pipe}.
* io pipes two::                Using @cfunc{ccsys_pipe2}.
@end menu

@c page
@node io pipes handlers
@subsection Pipes cleanup and error handlers


We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_fd_t    pipefd[2];
  ccsys_pipe(L, pipefd);
  ccsys_handler_pipedes_init(L, H, pipefd);
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_pipedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
@deftypefunx void ccsys_error_handler_pipedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptors in @var{pipedes} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
@deftypefnx {Preprocessor Macro} void ccsys_handler_pipedes_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{pipedes}[2])
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_pipedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_pipedes_init}.
@end table
@end deftypefn

@c page
@node io pipes one
@subsection Using @cfunc{ccsys_pipe}


As usage example of @cfunc{ccsys_pipe} see the following code.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  ccsys_fd_t    pipefd[2];

  /* Create the pipe. */
  @{
    ccsys_pipe(L, pipefd);
    ccsys_handler_pipedes_init(L, H, pipefd);
  @}

  /* Write to the pipe. */
  @{
    char *    buf = "0123456789";
    size_t    len = strlen(buf);
    size_t    N;
    N = ccsys_write(L, pipefd[1], buf, len);
    assert(N == len);
  @}

  /* Read from the pipe. */
  @{
    size_t    len = 256;
    char      buf[len];
    size_t    N;
    N = ccsys_read(L, pipefd[0], buf, len);
    assert(N == strlen("0123456789"));
    assert(0 == strncmp(buf, "0123456789", N));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io pipes two
@subsection Using @cfunc{ccsys_pipe2}


As usage example of @cfunc{ccsys_pipe2} see the following code.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  ccsys_fd_t          pipefd[2];

  /* Create the pipe. */
  @{
    ccsys_open_flags_t        flags;
    flags.data = CCSYS_O_CLOEXEC;
    ccsys_pipe2(L, pipefd, flags);
    ccsys_handler_pipedes_init(L, H, pipefd);
  @}

  /* Write to the pipe. */
  @{
    char *    buf = "0123456789";
    size_t    len = strlen(buf);
    size_t    N;
    N = ccsys_write(L, pipefd[1], buf, len);
    assert(N == len);
  @}

  /* Read from the pipe. */
  @{
    size_t    len = 256;
    char      buf[len];
    size_t    N;
    N = ccsys_read(L, pipefd[0], buf, len);
    assert(N == strlen("0123456789"));
    assert(0 == strncmp(buf, "0123456789", N));
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io fifos
@section Creating FIFOs


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkfifo (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifo}.  @manpage{mkfifo, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@deftypefun void ccsys_mkfifoat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkfifoat}.  @manpage{mkfifoat, Make a FIFO special file}.

The argument @var{mode} is meant to be a bitwise combination of the constants of type
@objtype{ccsys_open_mode_enum_t}.
@end deftypefun


@menu
* io fifos mkfifo::             Usage example for @cfunc{ccsys_mkfifo}.
* io fifos mkfifoat::           Usage example for @cfunc{ccsys_mkfifoat}.
@end menu

@c page
@node io fifos mkfifo
@subsection Usage example for @cfunc{ccsys_mkfifo}


As example of @cfunc{ccsys_mkfifo} usage consider the following, which:

@enumerate
@item
Creates a named @fifo{}.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{remove};
waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    char const * fifoname);
void sample_child  (char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t fifo_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * fifoname = "fifo.ext";
    ccsys_pid_t         pid;

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t         mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifo(L, fifoname, mode);
      ccsys_handler_remove_init(L, fifo_H, fifoname);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;
        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child  (char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_open(L, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io fifos mkfifoat
@subsection Usage example for @cfunc{ccsys_mkfifoat}


As example of @cfunc{ccsys_mkfifoat} usage consider the following, which:

@enumerate
@item
Creates a directory.

@item
Creates a named @fifo{} in the directory.

@item
Forks a child process using @cfunc{ccsys_fork}.

@item
The child process: opens the @fifo{}; writes to it; closes it; finally terminates.

@item
The parent process: opens the @fifo{}; reads from it; closes it; removes it with @cfunc{unlinkat};
removes the directory; waits for the child process to terminate.
@end enumerate


@smallexample
void sample_parent (cce_destination_t upper_L,
                    ccsys_dirfd_t dirfd, char const * fifoname);
void sample_child  (ccsys_dirfd_t dirfd, char const * fifoname);

void
sample (void)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t dir_H[1];
  cce_cleanup_handler_t dirstream_H[1];
  cce_cleanup_handler_t fifo_H[1];
  ccsys_at_link_t       fifo_unlink_data;

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    static char const * dirname  = "name.d";
    static char const * fifoname = "fifo.ext";
    ccsys_dirfd_t       dirfd;
    ccsys_pid_t         pid;

    /* Create the directory. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRWXU;
      ccsys_mkdir(L, dirname, mode);
      ccsys_handler_rmdir_init(L, dir_H, dirname);
    @}

    /* Open the directory. */
    @{
      ccsys_dir_t *     dirstream;
      dirstream = ccsys_opendir(L, dirname);
      ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
      dirfd = ccsys_dirfd(L, dirstream);
    @}

    /* Create the FIFO. */
    @{
      ccsys_open_mode_t mode;
      mode.data = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
      ccsys_mkfifoat(L, dirfd, fifoname, mode);
      fifo_unlink_data.dirfd    = dirfd;
      fifo_unlink_data.pathname = fifoname;
      ccsys_handler_unlinkat_init(L, fifo_H, &fifo_unlink_data);
    @}

    pid = ccsys_fork(L);
    if (pid.data) @{
      /* We are in the parent process. */
      sample_parent(L, dirfd, fifoname);

      /* Wait for the child process. */
      @{
        ccsys_waitpid_options_t options;
        ccsys_waitpid_status_t  wstatus;

        options.data = 0;
        ccsys_waitpid(L, pid, &wstatus, options);
      @}
    @} else @{
      /* We are in the child process. */
      sample_child(dirfd, fifoname);
    @}
    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_parent (cce_destination_t upper_L,
               ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  ccsys_fd_t            infd;

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    /* Open the FIFO for reading. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_RDONLY;
      mode.data  = 0;
      infd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, infd_H, infd);
    @}

    /* Read from the FIFO. */
    @{
      size_t    len = 11;
      char      inbuf[len];
      ccsys_read (L, infd, inbuf, len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
sample_child (ccsys_dirfd_t dirfd, char const * fifoname)
@{
  cce_location_t        L[1];
  ccsys_fd_t            oufd;
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    /* Open the FIFO for writing. */
    @{
      ccsys_open_flags_t        flags;
      ccsys_open_mode_t         mode;
      flags.data = CCSYS_O_WRONLY;
      mode.data  = 0;
      oufd = ccsys_openat(L, dirfd, fifoname, flags, mode);
      ccsys_handler_filedes_init(L, oufd_H, oufd);
    @}

    /* Write to the FIFO. */
    @{
      size_t    len = 11;
      char *    oubuf = "0123456789";
      ccsys_write(L, oufd, oubuf, len);
    @}
    cce_run_cleanup_handlers(L);
  @}

  /* Terminate the child process. */
  @{
    ccsys_exit_status_t status;
    status.data = CCSYS_EXIT_SUCCESS;
    ccsys_exit(status);
  @}
@}
@end smallexample

@c page
@node io close
@section Closing file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_close (cce_destination_t @var{L}, ccsys_fd_t @var{filedes})
Wrapper for @cfunc{close}.  @manpage{close, Close a file descriptor}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading File descriptor handlers

We can handle file descriptors that must be released with the standard function @cfunc{close} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_open_flags_t  flags;
  ccsys_open_mode_t   mode;
  ccsys_fd_t          fd;

  flags.data = CCSYS_O_CREAT;
  mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd = ccsys_open(L, filename, flags, mode);
  ccsys_handler_filedes_init(L, H, fd);

  /* Do something with "fd" here. */
  cce_run_cleanup_handlers(L);
@}
@end example


@deftypefun void ccsys_cleanup_handler_filedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefunx void ccsys_error_handler_filedes_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_fd_t @var{fd})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the file descriptor @var{fd} using the standard function @cfunc{close}; errors in
@cfunc{close} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_filedes_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_fd_t @var{fd})
@deftypefnx {Preprocessor Macro} void ccsys_handler_filedes_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_fd_t @var{fd})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_filedes_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_filedes_init}.
@end table
@end deftypefn

@c page
@node io read write
@section Reading and writing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun size_t ccsys_read (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{read}; @manpage{read, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{read} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pread (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pread}; @manpage{pread, Read from a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{pread} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_write (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{write}; @manpage{read, Write to a file descriptor}.  Notice the return value of
type @objtype{size_t}: the negative values returned by @cfunc{write} are consumed by this function,
so the return value is an unsigned integer.
@end deftypefun


@deftypefun size_t ccsys_pwrite (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, void const * @var{buffer}, size_t @var{size}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwrite}; @manpage{pwrite, Writing to a file descriptor}.  Notice the return value
of type @objtype{size_t}: the negative values returned by @cfunc{pwrite} are consumed by this
function, so the return value is an unsigned integer.
@end deftypefun


@deftypefun ccsys_off_t ccsys_lseek (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_off_t @var{offset}, ccsys_whence_t @var{whence})
Wrapper for @cfunc{lseek}; @manpage{lseek, Reposition a read/write file offset}.
@end deftypefun

@menu
* io read write one::           @cfunc{ccsys_read} and @cfunc{ccsys_write}.
* io read write two::           @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}.
@end menu

@c page
@node io read write one
@subsection @cfunc{ccsys_read} and @cfunc{ccsys_write}


As example of using @cfunc{ccsys_read} and @cfunc{ccsys_write} see the following code which opens a
file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    N = ccsys_write(L, fd, buf, len);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t    N;
    size_t    len = 1024;
    uint8_t   buf[len];
    N = ccsys_read(L, fd, buf, len);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io read write two
@subsection @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite}


As example of using @cfunc{ccsys_pread} and @cfunc{ccsys_pwrite} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;
    for (size_t i=0; i<len; ++i) @{
      buf[i] = i%256;
    @}
    offset.data = 0;
    N = ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Reading. */
  @{
    size_t            N;
    size_t            len = 1024;
    uint8_t           buf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    N = ccsys_pread(L, fd, buf, len, offset);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather
@section Scatter--gather input/output


@menu
* io scatter gather api::       Scatter--gather input/output @api{}.
* io scatter gather one::       Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}.
* io scatter gather two::       Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}.
@end menu

@c page
@node io scatter gather api
@subsection Scatter--gather input/output @api{}


For all the functions: notice the return value of type @objtype{size_t}: the negative values
returned by the system function is consumed by the wrapper function, so either the return value is
an unsigned integer or an exception is raised.

The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_iovec_t
Wrapper type for @objtype{struct iovec}.
@end deftp


@deftypefun size_t ccsys_readv (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{readv}; @manpage{readv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_writev (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count})
Wrapper for @cfunc{writev}; @manpage{writev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{preadv}; @manpage{preadv, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset})
Wrapper for @cfunc{pwritev}; @manpage{pwritev, Write to a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_preadv2 (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{preadv2}; @manpage{preadv2, Read from a file descriptor using multiple buffers}.
@end deftypefun


@deftypefun size_t ccsys_pwritev2 (cce_destination_t @var{L}, ccsys_fd_t @var{filedes}, ccsys_iovec_t const * @var{vector}, int @var{count}, ccsys_off_t @var{offset}, ccsys_scatter_gather_flags_t @var{flags})
Wrapper for @cfunc{pwritev2}; @manpage{pwritev2, Write to a file descriptor using multiple buffers}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_IOVEC_IOV_BASE
Defined to @code{1} if @objtype{struct iovec} has the field @code{iov_base}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_IOVEC_IOV_LEN
Defined to @code{1} if @objtype{struct iovec} has the field @code{iov_len}; otherwise it is defined
to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Structure field accessors


The following accessors are defined only if the corresponding structure field is defined.


@deftypefun void ccsys_set_iovec_iov_base (ccsys_iovect_t const * @var{S}, void * @var{F})
@deftypefunx void * ccsys_ref_iovec_iov_base (ccsys_iovect_t const * @var{S})
Setter and getter for the field @code{iov_base} in the structure referenced by @var{S}.
@end deftypefun


@deftypefun void ccsys_set_iovec_iov_len (ccsys_iovect_t const * @var{S}, size_t @var{F})
@deftypefunx size_t ccsys_ref_iovec_iov_len (ccsys_iovect_t const * @var{S})
Setter and getter for the field @code{iov_len} in the structure referenced by @var{S}.
@end deftypefun

@c page
@node io scatter gather one
@subsection Using @cfunc{ccsys_readv} and @cfunc{ccsys_writev}


As example of using @cfunc{ccsys_readv} and @cfunc{ccsys_writev} see the following code which opens
a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_writev(L, fd, vec, buf_count);
  @}

  /* Seeking. */
  @{
    ccsys_off_t       offset;
    ccsys_whence_t    whence;
    offset.data = 0;
    whence.data = CCSYS_SEEK_SET;
    offset = ccsys_lseek(L, fd, offset, whence);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    N = ccsys_readv(L, fd, vec, buf_count);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io scatter gather two
@subsection Using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev}


As example of using @cfunc{ccsys_preadv} and @cfunc{ccsys_pwritev} see the following code which
opens a file, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;
    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Writing. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Fill the buffers with some known data. */
    for (size_t i=0; i<buf_count; ++i) @{
      for (size_t j=0; j<buf_len; ++j) @{
        bufs[i][j] = j%256;
      @}
    @}

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_pwritev(L, fd, vec, buf_count, offset);
  @}

  /* Reading. */
  @{
    size_t            buf_count       = 4;
    size_t            buf_len         = 25;
    uint8_t           bufs[buf_count][buf_len];
    ccsys_iovec_t     vec[buf_count];
    ccsys_off_t       offset;
    size_t            N;

    /* Initialise the vector of buffers. */
    for (size_t i=0; i<buf_count; ++i) @{
      *ccsys_iovec_iov_base(&vec[i])  = bufs[i];
      *ccsys_iovec_iov_len(&vec[i])   = buf_len;
    @}

    offset.data = 0;
    N = ccsys_preadv(L, fd, vec, buf_count, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup
@section Duplicating file descriptors


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_fd_t ccsys_dup (cce_destination_t @var{L}, ccsys_fd_t @var{old})
Wrapper for @cfunc{dup}; @manpage{dup, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_destination_t @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new})
Wrapper for @cfunc{dup2}; @manpage{dup2, Duplicate a file descriptor}.
@end deftypefun


@deftypefun ccsys_fd_t ccsys_dup2 (cce_destination_t @var{L}, ccsys_fd_t @var{old}, ccsys_fd_t @var{new}, ccsys_open_flags_t @var{flags})
Wrapper for @cfunc{dup3}; @manpage{dup3, Duplicate a file descriptor}.
@end deftypefun


@menu
* io dup one::                  Using @cfunc{ccsys_dup}.
* io dup two::                  Using @cfunc{ccsys_dup2}.
* io dup three::                Using @cfunc{ccsys_dup3}.
@end menu

@c page
@node io dup one
@subsection Using @cfunc{ccsys_dup}


As example of using @cfunc{ccsys_dup} see the following code which opens a file, duplicates the file
descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
 @} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
   @}

  /* Duplicate the file descriptor. */
  fdx = ccsys_dup(L, fd);

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
   @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
   @}

  cce_run_cleanup_handlers(L);
 @}
@end example

@c page
@node io dup two
@subsection Using @cfunc{ccsys_dup2}


As example of using @cfunc{ccsys_dup2} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    fdx.data = 123;
    fdx = ccsys_dup2(L, fd, fdx);
    assert(123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    size_t            len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io dup three
@subsection Using @cfunc{ccsys_dup3}


As example of using @cfunc{ccsys_dup3} see the following code which opens a file, duplicates the
file descriptor, writes bytes to it, reads bytes from it, closes the file, removes the file.

@example
cce_location_t          L[1];
cce_cleanup_handler_t   filedes_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * filename = "name.ext";
  ccsys_fd_t          fd, fdx;

  /* Create and open the file. */
  @{
    ccsys_open_flags_t        flags;
    ccsys_open_mode_t         mode;

    flags.data = CCSYS_O_CREAT | CCSYS_O_RDWR;
    mode.data  = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
    fd = ccsys_open(L, filename, flags, mode);
    ccsys_handler_filedes_init(L, filedes_H, fd);
    ccsys_handler_remove_init(L, file_H, filename);
  @}

  /* Duplicate the file descriptor. */
  @{
    ccsys_open_flags_t        flags;

    flags.data        = CCSYS_O_CLOEXEC;
    fdx.data          = 123;
    fdx = ccsys_dup3(L, fd, fdx, flags);
    assert(123 == fdx.data);
  @}

  /* Write to the original file descriptor. */
  @{
    size_t            len = 11;
    char const *      buf = "0123456789";
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pwrite(L, fd, buf, len, offset);
  @}

  /* Read from the duplicated file descriptor. */
  @{
    static size_t const len = 11;
    char              inbuf[len];
    ccsys_off_t       offset;

    offset.data = 0;
    ccsys_pread(L, fdx, inbuf, len, offset);
  @}

  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node io select
@section Waiting for input/output


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_select (cce_destination_t @var{L}, int @var{nfds}, ccsys_fd_set_t * @var{read_fds}, ccsys_fd_set_t * @var{write_fds}, ccsys_fd_set_t * @var{except_fds}, ccsys_timeval_t * @var{timeout})
Wrapper for @cfunc{select}; @manpage{select, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun int ccsys_pselect (cce_destination_t @var{L}, int @var{nfds}, ccsys_fd_set_t * @var{read_fds}, ccsys_fd_set_t * @var{write_fds}, ccsys_fd_set_t * @var{except_fds}, ccsys_timespec_t * @var{timeout}, ccsys_sigset_t const * @var{sigmask})
Wrapper for @cfunc{pselect}; @manpage{pselect, Synchronous input/output multiplexing}.
@end deftypefun


@anchor{ccsys_sigset_t}
@deftp {Struct Typedef} ccsys_sigset_t
Wrapper for @code{sigset_t}.
@end deftp


@deftypefun void ccsys_fd_clr (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_CLR}; @manpage{FD_CLR, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun bool ccsys_fd_isset (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_ISSET}; @manpage{FD_ISSET, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun void ccsys_fd_set (ccsys_fd_t @var{fd}, ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_SET}; @manpage{FD_SET, Synchronous input/output multiplexing}.
@end deftypefun


@deftypefun void ccsys_fd_zero (ccsys_fd_set_t * @var{fds})
Wrapper for @cfunc{FD_ZERO}; @manpage{FD_ZERO, Synchronous input/output multiplexing}.
@end deftypefun


@menu
* io select one::               Using @cfunc{ccsys_select}.
* io select two::               Using @cfunc{ccsys_pselect}.
@end menu

@c page
@node io select one
@subsection Using @cfunc{ccsys_select}


As example of using @cfunc{ccsys_select} see the following code which forks a child process and
communicates with it through pipes.

@smallexample
static void doit_parent (cce_destination_t upper_L,
                         ccsys_fd_t infd, ccsys_fd_t oufd);
static void doit_child  (ccsys_fd_t infd, ccsys_fd_t oufd);

void
doit (cce_destination_t upper_L)
@{
  ccsys_fd_t    parent_in_fd, parent_ou_fd;
  ccsys_fd_t     child_in_fd,  child_ou_fd;

  /* Allocate the pipes. */
  @{
    cce_location_t              L[1];
    ccsys_fd_t                  forwards[2];
    ccsys_fd_t                  backwards[2];
    cce_error_handler_t         forwards_H[1];
    cce_error_handler_t         backwards_H[1];

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      ccsys_pipe(L, forwards);
      ccsys_handler_pipedes_init(L, forwards_H, forwards);
      ccsys_pipe(L, backwards);
      ccsys_handler_pipedes_init(L, backwards_H, backwards);
      cce_run_cleanup_handlers(L);
    @}

    /* Here the pipes have been allocated.
       Now split them into their role. */
    parent_in_fd = forwards[0];
    parent_ou_fd = backwards[1];
    child_in_fd  = backwards[0];
    child_ou_fd  = forwards[1];
  @}

  /* Fork the process and call the appropriate functions. */
  @{
    cce_location_t      L[1];
    ccsys_pid_t         pid;

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      pid = ccsys_fork(L);
      if (ccsys_in_parent_after_fork(pid)) @{
        doit_parent(L, parent_in_fd, parent_ou_fd);

        /* Wait for the child process. */
        @{
          ccsys_waitpid_options_t       options;
          ccsys_waitpid_status_t        wstatus;

          options.data = 0;
          ccsys_waitpid(L, pid, &wstatus, options);
        @}
      @} else @{
        doit_child(child_in_fd, child_ou_fd);

        /* Terminate the child process. */
        @{
          ccsys_exit_status_t   status;
          status.data = CCSYS_EXIT_SUCCESS;
          ccsys_exit(status);
        @}
      @}
      cce_run_cleanup_handlers(L);
    @}
  @}
@}

void
doit_parent (cce_destination_t upper_L,
             ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, NULL, &write_fds, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello child";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      nfds                      = ccsys_fd_incr(infd);
      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, &read_fds, NULL, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello parent", N));
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
doit_child (ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      nfds                      = ccsys_fd_incr(infd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, &read_fds, NULL, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello child", N));
    @}

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timeval_t   timeout;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.microseconds      = 0;
      rv = ccsys_select(L, nfds, NULL, &write_fds, NULL, &timeout);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello parent";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node io select two
@subsection Using @cfunc{ccsys_pselect}


As example of using @cfunc{ccsys_pselect} see the following code which forks a child process and
communicates with it through pipes.

@smallexample
static void doit_parent (cce_destination_t upper_L,
                         ccsys_fd_t infd, ccsys_fd_t oufd);
static void doit_child  (ccsys_fd_t infd, ccsys_fd_t oufd);

void
doit (cce_destination_t upper_L)
@{
  ccsys_fd_t    parent_in_fd, parent_ou_fd;
  ccsys_fd_t     child_in_fd,  child_ou_fd;

  /* Allocate the pipes. */
  @{
    cce_location_t              L[1];
    ccsys_fd_t                  forwards[2];
    ccsys_fd_t                  backwards[2];
    cce_error_handler_t         forwards_H[1];
    cce_error_handler_t         backwards_H[1];

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      ccsys_pipe(L, forwards);
      ccsys_handler_pipedes_init(L, forwards_H, forwards);
      ccsys_pipe(L, backwards);
      ccsys_handler_pipedes_init(L, backwards_H, backwards);
      cce_run_cleanup_handlers(L);
    @}

    /* Here the pipes have been allocated.
       Now split them into their role. */
    parent_in_fd = forwards[0];
    parent_ou_fd = backwards[1];
    child_in_fd  = backwards[0];
    child_ou_fd  = forwards[1];
  @}

  /* Fork the process and call the appropriate functions. */
  @{
    cce_location_t      L[1];
    ccsys_pid_t         pid;

    if (cce_location(L)) @{
      cce_run_error_handlers_raise(L, upper_L);
    @} else @{
      pid = ccsys_fork(L);
      if (ccsys_in_parent_after_fork(pid)) @{
        doit_parent(L, parent_in_fd, parent_ou_fd);

        /* Wait for the child process. */
        @{
          ccsys_waitpid_options_t       options;
          ccsys_waitpid_status_t        wstatus;

          options.data = 0;
          ccsys_waitpid(L, pid, &wstatus, options);
        @}
      @} else @{
        doit_child(child_in_fd, child_ou_fd);

        /* Terminate the child process. */
        @{
          ccsys_exit_status_t   status;
          status.data = CCSYS_EXIT_SUCCESS;
          ccsys_exit(status);
        @}
      @}
      cce_run_cleanup_handlers(L);
    @}
  @}
@}

void
doit_parent (cce_destination_t upper_L,
             ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, NULL, &write_fds, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello child";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      nfds                      = ccsys_fd_incr(infd);
      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, &read_fds, NULL, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello parent", N));
    @}

    cce_run_cleanup_handlers(L);
  @}
@}

void
doit_child (ccsys_fd_t infd, ccsys_fd_t oufd)
@{
  cce_location_t        L[1];
  cce_cleanup_handler_t infd_H[1];
  cce_cleanup_handler_t oufd_H[1];

  if (cce_location(L)) @{
    cce_run_error_handlers_final(L);
  @} else @{
    ccsys_handler_filedes_init(L, infd_H, infd);
    ccsys_handler_filedes_init(L, oufd_H, oufd);

    /* Wait for the input file descriptor to be readable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    read_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&read_fds);
      ccsys_fd_set(infd, &read_fds);
      nfds                      = ccsys_fd_incr(infd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, &read_fds, NULL, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(infd, &read_fds));
    @}

    /* Read from the input file descriptor. */
    @{
      size_t    len = 256;
      char      buf[len];
      size_t    N;
      N = ccsys_read(L, infd, buf, len);
      assert(0 == strncmp(buf, "hello child", N));
    @}

    /* Wait for the output file descriptor to be writable. */
    @{
      ccsys_fd_t        nfds;
      ccsys_fd_set_t    write_fds;
      ccsys_timespec_t  timeout;
      ccsys_sigset_t    sigmask;
      int               rv;

      ccsys_fd_zero(&write_fds);
      ccsys_fd_set(oufd, &write_fds);
      nfds                      = ccsys_fd_incr(oufd);
      timeout.seconds           = 1;
      timeout.nanoseconds       = 0;
      rv = ccsys_pselect(L, nfds, NULL, &write_fds, NULL,
                         &timeout, &sigmask);
      assert(1 == rv);
      assert(ccsys_fd_isset(oufd, &write_fds));
    @}

    /* Write to the output file descriptor. */
    @{
      char *    buf = "hello parent";
      size_t    len = strlen(buf);
      size_t    N;
      N = ccsys_write(L, oufd, buf, len);
      assert(N == len);
    @}

    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node io sync
@section Committing file system caches to disk


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_sync (void)
Wrapper for @cfunc{sync}; @manpage{sync, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_syncfs (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{syncfs}; @manpage{syncfs, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_fsync (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{fsync}; @manpage{fsync, Committing file system caches to disk}.
@end deftypefun


@deftypefun void ccsys_fdatasync (cce_destination_t L, ccsys_fd_t fd)
Wrapper for @cfunc{fdatasync}; @manpage{fdatasync, Committing file system caches to disk}.
@end deftypefun

@c page
@node fs
@chapter File system system calls


@menu
* fs dirs working::             The working directory.
* fs dirs reading::             Reading directory entries.
* fs dirs creating::            Creating and deleting directories.
* fs links::                    Operating on links.
* fs removing::                 Removing files.
* fs renaming::                 Renaming files and directories.
* fs attributes::               Reading file attributes.
* fs owner::                    Changing owner.
* fs access perms::             Changing access permissions.
* fs access tests::             Testing access permissions.
* fs trunc::                    Truncating files.
* fs times::                    File times.
* fs temp::                     Temporary files and directories.
@end menu

@c page
@node fs dirs working
@section The working directory


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_getcwd (cce_destination_t @var{L}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{getcwd}; @manpage{getcwd, Get the current working directory}.

If @var{buffer} is @cnull{}: an exception is raised with type @objtype{cce_condition_errno_t} and
code @code{EINVAL}.
@end deftypefun


@deftypefun void ccsys_custom_getcwd (cce_destination_t @var{L}, char * @var{buffer}, size_t @var{size})
Like @cfunc{ccsys_getcwd}, but:

@itemize
@item
If the function is successful: the return value is @true{}.

@item
If the function fails with @code{ERANGE}: no exception is raised and the return value is @false{}.
@end itemize
@end deftypefun


@deftypefun {char *} ccsys_get_current_dir_name (cce_destination_t @var{L})
Wrapper for @cfunc{get_current_dir_name}; @manpage{get_current_dir_name, Get the current working
directory}.

@quotation
@strong{NOTE} This function is a @gnu{} extension.
@end quotation
@end deftypefun


@deftypefun void ccsys_chdir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{chdir}; @manpage{chdir, Change the current working directory}.
@end deftypefun


@deftypefun void ccsys_fchdir (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fchdir}; @manpage{fchdir, Change the current working directory}.
@end deftypefun


@menu
* fs dirs working one::         Getting the working directory examples.
@end menu

@c page
@node fs dirs working one
@subsection Getting the working directory examples


As usage example for @cfunc{ccsys_getcwd} with a previously allocated stack buffer, see the
following code.

@example
size_t  len = CCSYS_PATH_MAX;
char    buf[len];

ccsys_getcwd(upper_L, buf, len);
@end example

As usage example for @cfunc{ccsys_getcwd} with a dynamically allocated stack buffer, see the
following code.

@example
cce_location_t        L[1];
volatile size_t       len = 1;

if (CCE_EXCEPT == cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  cce_location_t      inner_L[1];

  if (cce_location(inner_L)) @{
    if (cce_condition_is_errno(cce_condition(inner_L))) @{
      CCE_PC(cce_condition_errno_t, C, cce_condition(inner_L));
      if (CCSYS_ERANGE == C->errnum) @{
        len *= 2;
        cce_retry(L);
      @}
    @}
    cce_run_error_handlers_raise(inner_L, L);
  @} else @{
    char      buf[len];

    ccsys_getcwd(inner_L, buf, len);

    /* Do something with "buf" here; usually copy it into
       another buffer. */
    cce_run_cleanup_handlers(inner_L);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

As usage example for @cfunc{ccsys_custom_getcwd} see the following code.

@example
size_t        len = 1;

for (bool done = false; false == done; len *= 2) @{
  char        buf[len];

  /* Do something with "buf" here; usually copy it into
     another buffer. */
  done = ccsys_custom_getcwd(upper_L, buf, len);
@}
@end example

As usage example for @cfunc{ccsys_get_current_dir_name} see the following code.

@example
cce_location_t        L[1];
cce_cleanup_handler_t H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char *      buf;

  buf = ccsys_get_current_dir_name(L);
  ccsys_handler_malloc_init(L, H, buf);

  /* Do something with "buf" here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node fs dirs reading
@section Reading directory entries


@menu
* fs dirs reading types::       Directory stream and entry types.
* fs dirs reading api::         Actually reading directory entries.
* fs dirs reading handler::     Directory stream handler.
@end menu

@c page
@node fs dirs reading types
@subsection Directory stream and entry types


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Opaque Type} ccsys_dir_t
Opaque type for a directory stream; replaces @objtype{DIR}.
@end deftp


@deftp {Struct Typedef} ccsys_dirent_t
Type of directory entries; replaces @objtype{struct dirent}.
@end deftp


@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_DIRENT_D_NAME
Defined to @code{1} if @objtype{struct dirent} has the field @code{d_name}; otherwise it is defined
to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Structure field accessors


The following accessors are defined only if the corresponding structure field is defined.


@deftypefun {char const *} ccsys_ref_dirent_d_name (ccsys_dirent_t * @var{entry})
Return a pointer to the field @code{d_name} of a @objtype{struct dirent}.
@end deftypefun

@c page
@node fs dirs reading api
@subsection Actually reading directory entries


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun {ccsys_dir_t *} ccsys_opendir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{opendir}; @manpage{opendir, Open a directory}.
@end deftypefun


@deftypefun {ccsys_dir_t *} ccsys_fdopendir (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd})
Wrapper for @cfunc{fdopendir}; @manpage{fopendir, Open a directory}.
@end deftypefun


@deftypefun {ccsys_dirent_t *} ccsys_readdir (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{readdir}; @manpage{readdir, Read directory entries}.
@end deftypefun


@deftypefun void ccsys_closedir (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{closedir}; @manpage{opendir, Close a directory}.
@end deftypefun


@deftypefun ccsys_dirfd_t ccsys_dirfd (cce_destination_t @var{L}, ccsys_dir_t * @var{dirstream})
Wrapper for @cfunc{dirfd}; @manpage{dirfd, Get a directory stream file descriptor}.
@end deftypefun

@c page
@node fs dirs reading handler
@subsection Directory stream handler


We can read the contents of a directory opening a directory stream with @cfunc{ccsys_opendir} and
closing it with @cfunc{closedir}:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dirstream_H[1];
char const *            pathname = "./";

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_dir_t *         dirstream;
  ccsys_dirent_t *      direntry;

  dirstream = ccsys_opendir(L, pathname);
  ccsys_handler_dirstream_init(L, dirstream_H, dirstream);
  for (direntry = ccsys_readdir(L, dirstream);
       direntry;
       direntry = ccsys_readdir(L, dirstream)) @{
    printf("%s\n", ccsys_ref_dirent_d_name(direntry));
    fflush(stdout);
  @}
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{closedir}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_dirstream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefunx void ccsys_error_handler_dirstream_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
finalise the directory stream using the standard function @cfunc{closedir}; errors in
@cfunc{closedir} are @strong{ignored}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
@deftypefnx {Preprocessor Macro} void ccsys_handler_dirstream_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccsys_dir_t * @var{dirstream})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_dirstream_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_dirstream_init}.
@end table
@end deftypefn

@c page
@node fs dirs creating
@section Creating and deleting directories


@menu
* io dirs creating api::        Actually creating directories.
* io dirs creating handlers::   Handler for directories removal
* io dirs creating one::        Using @cfunc{ccsys_mkdirat}.
@end menu

@c page
@node io dirs creating api
@subsection Actually creating directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_mkdir (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkdir}; @manpage{mkdir, Create a directory}.
@end deftypefun


@deftypefun void ccsys_mkdirat (cce_destination_t @var{L}, ccsys_fd_t @var{fd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{mkdirat}; @manpage{mkdirat, Create a directory}.
@end deftypefun


@deftypefun void ccsys_rmdir (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{rmdir}; @manpage{rmdir, Delete a directory}.
@end deftypefun

@c page
@node io dirs creating handlers
@subsection Handler for directories removal


We can remove @strong{empty} temporary directories with the standard function @cfunc{rmdir} as
follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   dirname_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_mode_t     mode;

  mode.data = CCSYS_S_IRWXU;
  ccsys_mkdir(L, "name.d", mode);
  ccsys_handler_rmdir_init(L, dirname_H, "name.d");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{rmdir}, which is generally bad; we
can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the function @cfunc{mkdtemp}
implemented by the @gnu{} C Library.


@deftypefun void ccsys_cleanup_handler_rmdir_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_rmdir_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the directory whose pathname is @var{pathname} using the standard function @cfunc{rmdir};
errors in @cfunc{rmdir} are @strong{ignored}.  The directory is removed only if it is empty.

The string referenced by @var{pathname} must be an @asciiz{} representation of the directory
pathname; it is @strong{not} duplicated by this function and it must exist for the whole extent of
the usage of @var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_rmdir_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_rmdir_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_rmdir_init}.
@end table
@end deftypefn

@c page
@node io dirs creating one
@subsection Using @cfunc{ccsys_mkdirat}


As usage example of @cfunc{ccsys_mkdirat}, see the following code.

@smallexample
cce_location_t        L[1];
cce_handler_t         dirname1_H[1];
cce_handler_t         dirstream1_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  static char const * dirname1 = "name.d";
  static char const * dirname2 = "subname.d";
  ccsys_dirfd_t       dirfd1;

  /* Create the parent directory. */
  @{
    ccsys_open_mode_t mode;
    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdir(L, dirname1, mode);
    ccsys_cleanup_handler_rmdir_init(L, dirname1_H, dirname1);
  @}

  /* Open the parent directory.  The descriptor in "dirfd1"
     is released automatically when "dirstream" is released. */
  @{
    ccsys_dir_t *     dir;

    dir = ccsys_opendir(L, dirname1);
    ccsys_cleanup_handler_dirstream_init(L, dir_H, dir);
    dirfd1 = ccsys_dirfd(L, dir);
  @}

  /* Create the subdirectory. */
  @{
    ccsys_open_mode_t mode;
    mode.data = CCSYS_S_IRWXU;
    ccsys_mkdirat(L, dirfd1, dirname2, mode);
  @}

  /* Remove the subdirectory. */
  @{
    ccsys_unlinkat_flags_t      flags;
    flags.data = CCSYS_AT_REMOVEDIR;
    ccsys_unlinkat(L, dirfd1, dirname2, flags);
  @}

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fs links
@section Operating on links


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_link (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{link}.
@end deftypefun


@deftypefun void ccsys_linkat (cce_destination_t @var{L}, int @var{olddirfd}, char const * @var{oldname}, int @var{newdirfd}, char const * @var{newname}, int @var{flags})
Wrapper for @cfunc{linkat}.
@end deftypefun


@deftypefun void ccsys_symlink (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{symlink}.
@end deftypefun


@deftypefun void ccsys_symlinkat (cce_destination_t @var{L}, char const * @var{oldname}, int @var{newdirfd}, char const * @var{newname})
Wrapper for @cfunc{symlinkat}.
@end deftypefun


@deftypefun size_t ccsys_readlink (cce_destination_t @var{L}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlink}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun size_t ccsys_readlinkat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, char * @var{buffer}, size_t @var{size})
Wrapper for @cfunc{readlinkat}.  Notice the return value of type @objtype{size_t}, rather than the
original @objtype{ssize_t}: the wrapper function returns a non--negative integer because the error
conditions cause a non--local exit.
@end deftypefun


@deftypefun {char *} ccsys_realpath (cce_destination_t @var{L}, char const * @var{pathname}, char * @var{resolved_path})
Wrapper for @cfunc{realpath}.  Notice that this function never returns @cnull{}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun void ccsys_unlink (cce_destination_t @var{L}, char const * @var{filename})
Wrapper for @cfunc{unlink}.
@end deftypefun


@deftypefun void ccsys_unlinkat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{filename}, ccsys_unlinkat_flags_t @var{flags})
Wrapper for @cfunc{unlinkat}.
@end deftypefun

@c page
@node fs removing
@section Removing files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_remove (cce_destination_t @var{L}, char const * @var{pathname})
Wrapper for @cfunc{remove}.  This function removes both files and empty directories.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for files removal


We can remove temporary files with the standard function @cfunc{remove} as follows:

@example
cce_location_t          L[1];
cce_cleanup_handler_t   fd_H[1];
cce_cleanup_handler_t   file_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccsys_open_flags_t    flags;
  ccsys_open_mode_t     mode;
  ccsys_fd_t            fd;

  flags.data    = CCSYS_O_CREAT;
  mode.data     = CCSYS_S_IRUSR | CCSYS_S_IWUSR;
  fd            = ccsys_open(L, "name.ext", flags, mode);
  ccsys_cleanup_handler_filedes_init(L, fd_H, fd);
  ccsys_cleanup_handler_remove_init(L, file_H, "name.ext");
  cce_run_cleanup_handlers(L);
@}
@end example

The handler documented here will ignore errors returned by @cfunc{remove}, which is generally bad;
we can use the source code of this handler as template to implement a more complete procedure.
Remember that a good way to create temporary files is to use the @posix{} standard function
@cfunc{mkstemp}.

The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_cleanup_handler_remove_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
@deftypefunx void ccsys_error_handler_remove_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, char const * @var{pathname})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
remove the file whose pathname is @var{pathname} using the standard function @cfunc{remove}; errors
in @cfunc{remove} are @strong{ignored}.

The string referenced by @var{pathname} must be an @asciiz{} representation of the file pathname; it
is @strong{not} duplicated by this function and it must exist for the whole extent of the usage of
@var{H}.

If an error occurs while configuring the handler: an exception is raised by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccsys_handler_remove_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, char const * @var{pathname})
@deftypefnx {Preprocessor Macro} void ccsys_handler_remove_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccsys_cleanup_handler_remove_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccsys_error_handler_remove_init}.
@end table
@end deftypefn

@c page
@node fs renaming
@section Renaming files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_rename (cce_destination_t @var{L}, char const * @var{oldname}, char const * @var{newname})
Wrapper for @cfunc{rename}.
@end deftypefun

@c page
@node fs attributes
@section Reading file attributes


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_stat_t
Wrapper type for @objtype{struct stat}.
@end deftp


@deftypefun void ccsys_stat (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{stat}; @manpage{stat, Get file status}.
@end deftypefun


@deftypefun void ccsys_fstat (cce_destination_t @var{L}, ccsys_fd_t @var{fd}, ccsys_stat_t * @var{S})
@deftypefunx void ccsys_fstat (cce_destination_t @var{L}, ccsys_dirfd_t @var{fd}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{fstat}; @manpage{fstat, Get file status}.
@end deftypefun


@deftypefun void ccsys_fstatat (cce_destination_t @var{L}, ccsys_dirfd_t @var{fd}, char const * @var{pathname}, ccsys_stat_t * @var{S}, ccsys_fstatat_flags_t @var{flags})
Wrapper for @cfunc{fstatat}; @manpage{fstatat, Get file status}.
@end deftypefun


@deftypefun void ccsys_lstat (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_stat_t * @var{S})
Wrapper for @cfunc{lstat}; @manpage{lstat, Get file status}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Feature macros


@defmac CCSYS_HAVE_STRUCT_STAT_ST_DEV
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_dev}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_INO
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ino}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MODE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mode}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_NLINK
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_nlink}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_UID
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_uid}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_GID
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_gida}; otherwise it is defined to
@code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_RDEV
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_rdev}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_SIZE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_size}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_BLKSIZE
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_blksize}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_BLOCKS
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_blocks}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_ATIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_atime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MTIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mtime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_CTIME
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ctime}; otherwise it is defined
to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_ATIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_atime_usec}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_MTIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_mtime_usec}; otherwise it is
defined to @code{0}.
@end defmac


@defmac CCSYS_HAVE_STRUCT_STAT_ST_CTIME_USEC
Defined to @samp{1} if @objtype{struct stat} has the field @code{st_ctime_usec}; otherwise it is
defined to @code{0}.
@end defmac

@c ------------------------------------------------------------------------

@subsubheading Setters and getters for @objtype{ccsys_stat_t}


The following field accessors are defined only if @objtype{struct stat} has the associated field;
otherwise they are not implemented.


@deftypefun ccsys_dev_t ccsys_ref_stat_st_dev (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_dev (ccsys_stat_t * @var{S}, ccsys_dev_t @var{F})
Getter and setter for the field @code{st_dev}.
@end deftypefun


@deftypefun ccsys_ino_t ccsys_ref_stat_st_ino (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_ino (ccsys_stat_t * @var{S}, ccsys_ino_t @var{F})
Getter and setter for the field @code{st_ino}.
@end deftypefun


@deftypefun ccsys_open_mode_t ccsys_ref_stat_st_mode (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_mode (ccsys_stat_t * @var{S}, ccsys_open_mode_t @var{F})
Getter and setter for the field @code{st_mode}.
@end deftypefun


@deftypefun ccsys_nlink_t ccsys_ref_stat_st_nlink (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_nlink (ccsys_stat_t * @var{S}, ccsys_nlink_t @var{F})
Getter and setter for the field @code{st_nlink}.
@end deftypefun


@deftypefun ccsys_uid_t ccsys_ref_stat_st_uid (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_uid (ccsys_stat_t * @var{S}, ccsys_uid_t @var{F})
Getter and setter for the field @code{st_uid}.
@end deftypefun


@deftypefun ccsys_gid_t ccsys_ref_stat_st_gid (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_gid (ccsys_stat_t * @var{S}, ccsys_gid_t @var{F})
Getter and setter for the field @code{st_gid}.
@end deftypefun


@deftypefun ccsys_dev_t ccsys_ref_stat_st_rdev (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_rdev (ccsys_stat_t * @var{S}, ccsys_dev_t @var{F})
Getter and setter for the field @code{st_rdev}.
@end deftypefun


@deftypefun ccsys_off_t ccsys_ref_stat_st_size (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_size (ccsys_stat_t * @var{S}, ccsys_off_t @var{F})
Getter and setter for the field @code{st_size}.
@end deftypefun


@deftypefun ccsys_blksize_t ccsys_ref_stat_st_blksize (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_blksize (ccsys_stat_t * @var{S}, ccsys_blksize_t @var{F})
Getter and setter for the field @code{st_blksize}.
@end deftypefun


@deftypefun ccsys_blkcnt_t ccsys_ref_stat_st_blocks (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_blocks (ccsys_stat_t * @var{S}, ccsys_blkcnt_t @var{F})
Getter and setter for the field @code{st_blocks}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_atime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_atime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_atime} and @code{st_atime_usec}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_mtime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_mtime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_mtime} and @code{st_mtime_usec}.
@end deftypefun


@deftypefun ccsys_timeval_t ccsys_ref_stat_st_ctime (ccsys_stat_t const * @var{S})
@deftypefunx void ccsys_set_stat_st_ctime (ccsys_stat_t * @var{S}, ccsys_timeval_t @var{F})
Getter and setter for the fields @code{st_ctime} and @code{st_ctime_usec}.
@end deftypefun

@c page
@node fs owner
@section Changing owner


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chown (cce_destination_t @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{chown}.
@end deftypefun


@deftypefun void ccsys_fchown (cce_destination_t @var{L}, int @var{filedes}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{fchown}.
@end deftypefun


@deftypefun void ccsys_lchown (cce_destination_t @var{L}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group})
Wrapper for @cfunc{lchown}.
@end deftypefun


@deftypefun void ccsys_fchownat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, uid_t @var{owner}, gid_t @var{group}, int @var{flags})
Wrapper for @cfunc{fchownat}.
@end deftypefun

@c page
@node fs access perms
@section Changing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_chmod (cce_destination_t @var{L}, char const * @var{pathname}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{chmod}.
@end deftypefun


@deftypefun void ccsys_fchmod (cce_destination_t @var{L}, int @var{filedes}, ccsys_open_mode_t @var{mode})
Wrapper for @cfunc{fchmod}.
@end deftypefun


@deftypefun void ccsys_fchmodat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, ccsys_open_mode_t @var{mode}, int @var{flags})
Wrapper for @cfunc{fchmodat}.
@end deftypefun

@c page
@node fs access tests
@section Testing access permissions


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_access (cce_destination_t @var{L}, char const * @var{pathname}, int @var{how})
Wrapper for @cfunc{access}.  The return value is @samp{0} if access is denied; the return value is
@samp{-1} if access is granted.
@end deftypefun


@deftypefun int ccsys_faccessat (cce_destination_t @var{L}, ccsys_dirfd_t @var{dirfd}, char const * @var{pathname}, int @var{how}, int @var{flags})
Wrapper for @cfunc{faccessat}.
@end deftypefun

@c page
@node fs trunc
@section Truncating files


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_truncate (cce_destination_t @var{L}, char const * @var{pathname}, off_t @var{length})
Wrapper for @cfunc{truncate}.
@end deftypefun


@deftypefun void ccsys_ftruncate (cce_destination_t @var{L}, int @var{filedes}, off_t @var{length})
Wrapper for @cfunc{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File times


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_utime (cce_destination_t @var{L}, char const * @var{pathname}, const struct utimbuf * @var{times})
Wrapper for @cfunc{utime}.
@end deftypefun


@deftypefun void ccsys_utimes (cce_destination_t @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{utimes}.
@end deftypefun


@deftypefun void ccsys_lutimes (cce_destination_t @var{L}, char const * @var{pathname}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{lutimes}.
@end deftypefun


@deftypefun void ccsys_futimes (cce_destination_t @var{L}, int @var{filedes}, const struct timeval @var{TVP} [2])
Wrapper for @cfunc{futimes}.
@end deftypefun

@c page
@node fs temp
@section Temporary files and directories


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_mkstemp (cce_destination_t @var{L}, char * @var{template})
Wrapper for @cfunc{mkstemp}.  Remember that this call will mutate @var{template}.
@end deftypefun


@deftypefun {char *} ccsys_mkdtemp (cce_destination_t @var{L}, char * @var{template})
Wrapper for @cfunc{mkdtemp}.  This function never returns @cnull{}.  Remember that this call will
mutate @var{template}.

@quotation
@strong{NOTE} This function is implemented by the @gnu{} C Library.  The feature is available only
if the package is configured with @option{--enable-glibc}; otherwise the function will raise an
exception with condition object of type @objtype{ccsys_unimplemented_C_t}.
@end quotation
@end deftypefun

@c page
@node sockets
@chapter Socket system calls


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_bind (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{bind}.
@end deftypefun


@deftypefun void ccsys_getsockname (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{getsockname}.
@end deftypefun


@deftypefun void ccsys_inet_aton (cce_destination_t @var{L}, char const * @var{name}, struct in_addr * @var{addr})
Wrapper for @cfunc{inet_aton}.
@end deftypefun


@deftypefun in_addr_t ccsys_inet_network (cce_destination_t @var{L}, char const * @var{name})
Wrapper for @cfunc{inet_network}.
@end deftypefun


@deftypefun int ccsys_socket (cce_destination_t @var{L}, int @var{namespace}, int @var{style}, int @var{protocol})
Wrapper for @cfunc{socket}.
@end deftypefun


@deftypefun void ccsys_shutdown (cce_destination_t @var{L}, int @var{socket}, int @var{how})
Wrapper for @cfunc{shutdown}.
@end deftypefun


@deftypefun void ccsys_socketpair (cce_destination_t @var{L}, int @var{namespace}, int @var{style}, int @var{protocol}, int @var{filedes}[2])
Wrapper for @cfunc{socketpair}.
@end deftypefun


@deftypefun void ccsys_connect (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{connect}.
@end deftypefun


@deftypefun void ccsys_listen (cce_destination_t @var{L}, int @var{socket}, int @var{N})
Wrapper for @cfunc{listen}.
@end deftypefun


@deftypefun int ccsys_accept (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{accept}.
@end deftypefun


@deftypefun void ccsys_getpeername (cce_destination_t @var{L}, int @var{socket}, struct sockaddr * @var{addr}, socklen_t * @var{length}_ptr)
Wrapper for @cfunc{getpeername}.
@end deftypefun


@deftypefun size_t ccsys_send (cce_destination_t @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{send}.
@end deftypefun


@deftypefun size_t ccsys_recv (cce_destination_t @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags})
Wrapper for @cfunc{recv}.
@end deftypefun


@deftypefun size_t ccsys_sendto (cce_destination_t @var{L}, int @var{socket}, void const * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t @var{length})
Wrapper for @cfunc{sendto}.
@end deftypefun


@deftypefun size_t ccsys_recvfrom (cce_destination_t @var{L}, int @var{socket}, void * @var{buffer}, size_t @var{size}, int @var{flags}, struct sockaddr * @var{addr}, socklen_t * @var{length_ptr})
Wrapper for @cfunc{recvfrom}.
@end deftypefun


@deftypefun void ccsys_getsockopt (cce_destination_t @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void * @var{optval}, socklen_t * @var{optlen_ptr})
Wrapper for @cfunc{getsockopt}.
@end deftypefun


@deftypefun void ccsys_setsockopt (cce_destination_t @var{L}, int @var{socket}, int @var{level}, int @var{optname}, void const * @var{optval}, socklen_t @var{optlen})
Wrapper for @cfunc{setsockopt}.
@end deftypefun

@c page
@node process
@chapter Process system calls


@menu
* process exiting::             Exiting the current process.
* process system::              Executing subprocesses through the shell.
* process forking::             Forking the current process.
* process executing::           Executing a subprocess.
* process waiting::             Waiting for a subprocess.
@end menu

@c page
@node process exiting
@section Exiting the current process


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_exit (ccsys_exit_status_t @var{status})
Wrapper for @cfunc{exit}; @manpage{exit, Cause normal process termination}.
@end deftypefun


@deftypefun void ccsys__exit (ccsys_exit_status_t @var{status})
Wrapper for @cfunc{_exit}; @manpage{_exit, Terminate the calling process}.
@end deftypefun

@c page
@node process system
@section Executing subprocesses through the shell


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun int ccsys_system (cce_destination_t @var{L}, char const * @var{command})
Wrapper for @cfunc{system}.
@end deftypefun

@c page
@node process forking
@section Forking the current process


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun ccsys_pid_t ccsys_fork (cce_location_t * @var{L})
Wrapper for @cfunc{fork}.
@end deftypefun


@deftypefun bool ccsys_in_parent_after_fork (ccsys_pid_t @var{pid})
The argument @var{pid} must be the return value of a call to @cfunc{ccsys_fork}.  Return @true{} if
the current process is the @strong{parent} after the call to @cfunc{ccsys_fork}; otherwise return
@false{}.
@end deftypefun


@deftypefun bool ccsys_in_child_after_fork (ccsys_pid_t @var{pid})
The argument @var{pid} must be the return value of a call to @cfunc{ccsys_fork}.  Return @true{} if
the current process is the @strong{child} after the call to @cfunc{ccsys_fork}; otherwise return
@false{}.
@end deftypefun

@c page
@node process executing
@section Executing a subprocess


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_execv (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execv}.
@end deftypefun


@deftypefun void ccsys_execve (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [], char * const @var{env} [])
Wrapper for @cfunc{execve}.
@end deftypefun


@deftypefun void ccsys_execvp (cce_destination_t @var{L}, char const * @var{filename}, char * const @var{argv} [])
Wrapper for @cfunc{execvp}.
@end deftypefun

@c page
@node process waiting
@section Waiting for a subprocess


The following symbols are defined in the header file @file{ccsys.h}.


@deftypefun void ccsys_waitpid (cce_destination_t @var{L}, pid_t @var{pid}, ccsys_waitpid_status_t * @var{wstatus}, ccsys_waitpid_options_t @var{options})
Wrapper for @cfunc{waitpid}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for exit status


@deftypefun bool ccsys_wifexited (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFEXITED}.
@end deftypefun


@deftypefun uint8_t ccsys_wexitstatus (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WEXITSTATUS}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for signals


@deftypefun bool ccsys_wifsignaled (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFSIGNALED}.
@end deftypefun


@deftypefun ccsys_signum_t ccsys_wtermsig (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WTERMSIG}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing core dumps


@deftypefun bool ccsys_wcoredump (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WCOREDUMP}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Testing for stops


@deftypefun bool ccsys_wifstopped (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WIFSTOPPED}.
@end deftypefun


@deftypefun ccsys_signum_t ccsys_wstopsig (ccsys_waitpid_status_t @var{wstatus})
Wrapper for @cfunc{WSTOPSIG}.
@end deftypefun

@c page
@node time
@chapter Time handling


@menu
* time units::                  Units of time.
* time structs::                Time structures.
@end menu

@c page
@node time units
@section Units of time


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Integer Typedef} ccsys_time_unit_t
The type of time units in the semantic types:

@example
ccsys_seconds_t
ccsys_milliseconds_t
ccsys_microseconds_t
ccsys_nanoseconds_t
@end example

@noindent
it is defined as @code{long int}.
@end deftp


@deftp {Semantic Type} ccsys_seconds_t
A signed exact integer representing a number of seconds.
@end deftp


@deftp {Semantic Type} ccsys_milliseconds_t
A signed exact integer representing a number of milliseconds.
@end deftp


@deftp {Semantic Type} ccsys_microseconds_t
A signed exact integer representing a number of microseconds.
@end deftp


@deftp {Semantic Type} ccsys_nanoseconds_t
A signed exact integer representing a number of nanoseconds.
@end deftp


@deftypefn {Preprocessor Macro} void ccsys_set_seconds (ccsys_seconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of seconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_milliseconds (ccsys_milliseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of milliseconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_microseconds (ccsys_microseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of microseconds in @var{S} to @var{N}.
@end deftypefn


@deftypefn {Preprocessor Macro} void ccsys_set_nanoseconds (ccsys_nanoseconds_t @var{S}, ccsys_time_unit_t @var{N})
Set the number of nanoseconds in @var{S} to @var{N}.
@end deftypefn

@c page
@node time structs
@section Time structures


The following symbols are defined in the header file @file{ccsys.h}.


@deftp {Struct Typedef} ccsys_timeval_t
Replacement of @code{struct timeval}.  It has the following fields:

@table @code
@item ccsys_seconds_t seconds
The number of seconds.

@item ccsys_microseconds_t microseconds
The number of microseconds.
@end table
@end deftp


@deftp {Struct Typedef} ccsys_timespec_t
Replacement of @code{struct timespec}.  It has the following fields:

@table @code
@item ccsys_seconds_t seconds
The number of seconds.

@item ccsys_nanoseconds_t nanoseconds
The number of nanoseconds.
@end table
@end deftp

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

